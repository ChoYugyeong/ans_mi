# 프로젝트 코드 통합 파일 (파트 2/2)
# 생성일시: 2025-07-25 18:05:59
# 프로젝트 경로: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible

## 📄 파일 내용

================================================================================
파일: scripts/generate-inventory.sh
================================================================================
#!/bin/bash
# generate-inventory.sh - Enhanced inventory generator with interactive mode
# Version: 4.0.0 - Supports both interactive and command-line modes

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Default values
DEFAULT_NODE_COUNT=5
DEFAULT_CONSENSUS_NODES=4
DEFAULT_ENVIRONMENT="production"
DEFAULT_MODEL="mitum-currency"
DEFAULT_NODE_USER="ubuntu"
DEFAULT_BASTION_USER="ubuntu"
DEFAULT_NETWORK_ID="mitum"

# Script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"

# Functions
log() { echo -e "${GREEN}[INFO]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
warning() { echo -e "${YELLOW}[WARN]${NC} $*"; }
prompt() { echo -ne "${PURPLE}$*${NC} "; }

usage() {
    cat << EOF
${GREEN}Mitum Inventory Generator${NC}

Generate Ansible inventory for Mitum blockchain deployment.
Supports both interactive mode and command-line options.

${YELLOW}Usage:${NC}
    $0                          # Interactive mode (recommended)
    $0 [OPTIONS]                # Command-line mode

${YELLOW}Required Options (command-line mode):${NC}
    -b, --bastion-ip IP         Bastion host public IP

${YELLOW}Node Configuration (choose one):${NC}
    --node-ips IP1,IP2,IP3      Comma-separated list of node IPs
    --node-subnet SUBNET        Auto-generate IPs from subnet (e.g., 172.16.1)
    --start-ip IP               Starting IP for auto-generation (default: 10)

${YELLOW}Optional Parameters:${NC}
    -n, --nodes COUNT           Total number of nodes (default: $DEFAULT_NODE_COUNT)
    -c, --consensus COUNT       Number of consensus nodes (default: $DEFAULT_CONSENSUS_NODES)
    -e, --environment ENV       Environment name (default: $DEFAULT_ENVIRONMENT)
    -m, --model MODEL           Mitum model type (default: $DEFAULT_MODEL)
    --network-id ID             Network identifier (default: $DEFAULT_NETWORK_ID)
    
${YELLOW}SSH Configuration:${NC}
    --bastion-user USER         Bastion SSH user (default: $DEFAULT_BASTION_USER)
    --node-user USER            Node SSH user (default: $DEFAULT_NODE_USER)
    --node-key-name NAME        Node key filename (default: nodes.pem)
    
${YELLOW}Additional Options:${NC}
    -o, --output FILE           Output file path
    --port-start PORT           Starting port number (default: 4320)
    --monitoring-ip IP          Monitoring server IP
    --use-jump-host             Use -J option instead of ProxyCommand
    --check-keys                Validate SSH keys exist
    --dry-run                   Show what would be generated
    -h, --help                  Show this help

${YELLOW}Examples:${NC}
    # Interactive mode (easiest)
    $0

    # Basic usage with specific IPs
    $0 -b 52.74.123.45 --node-ips 10.0.1.10,10.0.1.11,10.0.1.12

    # Auto-generate IPs from subnet
    $0 -b 52.74.123.45 --node-subnet 192.168.1 -n 5

    # Full configuration
    $0 -b 52.74.123.45 \\
       --node-ips 10.0.1.10,10.0.1.11,10.0.1.12 \\
       -m mitum-currency \\
       --network-id mainnet \\
       -e production \\
       --check-keys

${YELLOW}SSH Key Requirements:${NC}
    Required keys in keys/ssh/{environment}/:
    - bastion.pem: Access to bastion host
    - nodes.pem: Access from bastion to nodes (can be different name)

EOF
}

# Check SSH keys
check_ssh_keys() {
    local env=$1
    local node_key_name=${2:-nodes.pem}
    local keys_dir="$ROOT_DIR/keys/ssh/$env"
    local all_good=true
    
    log "Checking SSH keys for $env environment..."
    
    # Check bastion key
    if [[ -f "$keys_dir/bastion.pem" ]] || [[ -f "$keys_dir/bastion.key" ]]; then
        log "✓ Found bastion key"
    else
        warning "Missing bastion key"
        echo "  To add: ./scripts/manage-keys.sh add $env ~/path/to/key.pem bastion.pem"
        all_good=false
    fi
    
    # Check node key
    if [[ -f "$keys_dir/$node_key_name" ]]; then
        log "✓ Found node key: $node_key_name"
    else
        warning "Missing node key: $node_key_name"
        echo "  To add: ./scripts/manage-keys.sh add $env ~/path/to/key.pem $node_key_name"
        all_good=false
    fi
    
    if [[ "$all_good" == "false" ]]; then
        return 1
    fi
    return 0
}

# Interactive mode
interactive_mode() {
    echo -e "${GREEN}=== Mitum Ansible Inventory Generation Assistant ===${NC}"
    echo -e "${YELLOW}Please provide the required information step by step.${NC}\n"
    
    # Environment selection
    prompt "Select environment [production/staging/development] (default: production):"
    read -r env_input
    ENVIRONMENT=${env_input:-production}
    
    # Bastion information
    prompt "Enter Bastion server's public IP address:"
    read -r BASTION_IP
    while [[ ! "$BASTION_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; do
        error "Invalid IP address format."
        prompt "Please enter Bastion IP again:"
        read -r BASTION_IP
    done
    
    prompt "Bastion server SSH username (default: ubuntu):"
    read -r bastion_user_input
    BASTION_USER=${bastion_user_input:-ubuntu}
    
    # Node information
    echo -e "\n${YELLOW}Enter node server information.${NC}"
    prompt "Enter node internal IPs separated by commas (e.g., 192.168.50.88,192.168.50.89,192.168.50.90):"
    read -r node_ips_input
    IFS=',' read -ra NODE_IPS <<< "$node_ips_input"
    NODE_COUNT=${#NODE_IPS[@]}
    
    prompt "Node server SSH username (default: ubuntu):"
    read -r node_user_input
    NODE_USER=${node_user_input:-ubuntu}
    
    # SSH key configuration
    echo -e "\n${YELLOW}SSH Key Configuration${NC}"
    echo -e "Current project key directory: ${BLUE}$ROOT_DIR/keys/ssh/$ENVIRONMENT/${NC}"
    
    # Check/add bastion key
    local bastion_key_path="$ROOT_DIR/keys/ssh/$ENVIRONMENT/bastion.pem"
    if [[ ! -f "$bastion_key_path" ]]; then
        warning "Bastion SSH key not found."
        prompt "Enter bastion key file path (e.g., ~/Downloads/my-key.pem):"
        read -r bastion_key_source
        
        if [[ -f "$bastion_key_source" ]]; then
            mkdir -p "$ROOT_DIR/keys/ssh/$ENVIRONMENT"
            cp "$bastion_key_source" "$bastion_key_path"
            chmod 600 "$bastion_key_path"
            log "Bastion key copied successfully."
        else
            error "Key file not found: $bastion_key_source"
            exit 1
        fi
    else
        log "Bastion key found: bastion.pem"
    fi
    
    # Check node key
    prompt "Do nodes use a different SSH key than bastion? [y/N]:"
    read -r use_different_key
    
    if [[ "$use_different_key" =~ ^[Yy]$ ]]; then
        USE_NODE_KEY=true
        
        # Node key name
        prompt "Enter node SSH key filename (default: nodes.pem):"
        read -r node_key_name_input
        NODE_KEY_NAME=${node_key_name_input:-nodes.pem}
        
        # Method to obtain node key
        echo -e "\n${YELLOW}Select how to obtain the node key:${NC}"
        echo "1) Copy from Bastion server (recommended)"
        echo "2) Copy from local file"
        echo "3) Add manually later"
        prompt "Select [1-3]:"
        read -r key_option
        
        case "$key_option" in
            1)
                prompt "Enter node key path on Bastion server (e.g., /home/ubuntu/.ssh/imfact-dev-01):"
                read -r remote_key_path
                
                log "Copying key from Bastion server..."
                local node_key_path="$ROOT_DIR/keys/ssh/$ENVIRONMENT/$NODE_KEY_NAME"
                scp -i "$bastion_key_path" "$BASTION_USER@$BASTION_IP:$remote_key_path" "$node_key_path"
                chmod 600 "$node_key_path"
                log "Node key copied successfully: $NODE_KEY_NAME"
                ;;
            2)
                prompt "Enter local node key file path:"
                read -r local_key_path
                
                if [[ -f "$local_key_path" ]]; then
                    local node_key_path="$ROOT_DIR/keys/ssh/$ENVIRONMENT/$NODE_KEY_NAME"
                    cp "$local_key_path" "$node_key_path"
                    chmod 600 "$node_key_path"
                    log "Node key copied successfully: $NODE_KEY_NAME"
                else
                    error "Key file not found: $local_key_path"
                    exit 1
                fi
                ;;
            3)
                warning "You need to add the node key later:"
                echo "  cp ~/your-node-key.pem $ROOT_DIR/keys/ssh/$ENVIRONMENT/$NODE_KEY_NAME"
                echo "  chmod 600 $ROOT_DIR/keys/ssh/$ENVIRONMENT/$NODE_KEY_NAME"
                ;;
        esac
    else
        USE_NODE_KEY=false
        NODE_KEY_NAME="bastion.pem"
    fi
    
    # Consensus nodes
    local default_consensus=$((NODE_COUNT < 3 ? NODE_COUNT : 3))
    local max_consensus=$((NODE_COUNT - 1))
    prompt "Number of consensus nodes (1-$max_consensus, default: $default_consensus):"
    read -r consensus_input
    CONSENSUS_COUNT=${consensus_input:-$default_consensus}
    
    # Network configuration
    echo -e "\n${YELLOW}Mitum Network Configuration${NC}"
    prompt "Network ID (default: testnet):"
    read -r network_id_input
    NETWORK_ID=${network_id_input:-testnet}
    
    prompt "Model Type [mitum-currency/mitum-nft/mitum-document] (default: mitum-currency):"
    read -r model_input
    MODEL_TYPE=${model_input:-mitum-currency}
    
    # Port configuration
    prompt "Starting port number (default: 4320):"
    read -r port_input
    PORT_START=${port_input:-4320}
    
    # Monitoring
    prompt "Do you want to setup monitoring? [y/N]:"
    read -r has_monitoring
    if [[ "$has_monitoring" =~ ^[Yy]$ ]]; then
        SETUP_MONITORING=true
        prompt "Enter monitoring server IP (leave empty to use first node):"
        read -r MONITORING_IP
        
        if [[ -z "$MONITORING_IP" ]]; then
            MONITORING_IP="${NODE_IPS[0]}"
            log "Using first node as monitoring server: $MONITORING_IP"
        fi
        
        # AWX integration
        prompt "Enable AWX integration? [y/N]:"
        read -r enable_awx
        if [[ "$enable_awx" =~ ^[Yy]$ ]]; then
            AWX_ENABLED=true
            prompt "Enter AWX URL (e.g., http://awx.example.com):"
            read -r AWX_URL
            prompt "Enter AWX Token (will be stored in vault):"
            read -s AWX_TOKEN
            echo ""  # New line after password input
        else
            AWX_ENABLED=false
        fi
    else
        SETUP_MONITORING=false
        MONITORING_IP=""
        AWX_ENABLED=false
    fi
    
    # Confirmation
    echo -e "\n${GREEN}=== Configuration Summary ===${NC}"
    echo "Environment: $ENVIRONMENT"
    echo "Bastion: $BASTION_USER@$BASTION_IP"
    echo "Nodes: ${#NODE_IPS[@]} nodes (${NODE_IPS[*]})"
    echo "Consensus nodes: $CONSENSUS_COUNT"
    echo "Node user: $NODE_USER"
    echo "Network ID: $NETWORK_ID"
    echo "Model Type: $MODEL_TYPE"
    echo "Starting port: $PORT_START"
    echo "Use separate node key: $([ "$USE_NODE_KEY" == "true" ] && echo "Yes ($NODE_KEY_NAME)" || echo "No")"
    echo "Monitoring: $([ "$SETUP_MONITORING" == "true" ] && echo "Yes (Server: $MONITORING_IP)" || echo "No")"
    [[ "$AWX_ENABLED" == "true" ]] && echo "AWX Integration: Yes ($AWX_URL)"
    
    prompt "\nProceed with these settings? [Y/n]:"
    read -r confirm
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        echo "Cancelled."
        exit 0
    fi
    
    # Set variables for generate_inventory function
    OUTPUT_FILE="$ROOT_DIR/inventories/$ENVIRONMENT/hosts.yml"
    DRY_RUN=false
    USE_JUMP_HOST=false
    
    # Generate inventory
    generate_inventory
}

# Parse command-line arguments
parse_args() {
    # Initialize variables
    BASTION_IP=""
    NODE_IPS=()
    NODE_SUBNET=""
    START_IP=10
    NODE_COUNT=$DEFAULT_NODE_COUNT
    CONSENSUS_COUNT=$DEFAULT_CONSENSUS_NODES
    ENVIRONMENT=$DEFAULT_ENVIRONMENT
    MODEL_TYPE=$DEFAULT_MODEL
    NETWORK_ID=$DEFAULT_NETWORK_ID
    BASTION_USER=$DEFAULT_BASTION_USER
    NODE_USER=$DEFAULT_NODE_USER
    NODE_KEY_NAME="nodes.pem"
    PORT_START=4320
    MONITORING_IP=""
    OUTPUT_FILE=""
    DRY_RUN=false
    USE_JUMP_HOST=false
    CHECK_KEYS=false
    SETUP_MONITORING=false
    AWX_ENABLED=false
    AWX_URL=""
    AWX_TOKEN=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -b|--bastion-ip)
                BASTION_IP="$2"
                shift 2
                ;;
            --node-ips)
                IFS=',' read -ra NODE_IPS <<< "$2"
                shift 2
                ;;
            --node-subnet)
                NODE_SUBNET="$2"
                shift 2
                ;;
            --start-ip)
                START_IP="$2"
                shift 2
                ;;
            -n|--nodes)
                NODE_COUNT="$2"
                shift 2
                ;;
            -c|--consensus)
                CONSENSUS_COUNT="$2"
                shift 2
                ;;
            -e|--environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            -m|--model)
                MODEL_TYPE="$2"
                shift 2
                ;;
            --network-id)
                NETWORK_ID="$2"
                shift 2
                ;;
            --bastion-user)
                BASTION_USER="$2"
                shift 2
                ;;
            --node-user)
                NODE_USER="$2"
                shift 2
                ;;
            --node-key-name)
                NODE_KEY_NAME="$2"
                shift 2
                ;;
            --port-start)
                PORT_START="$2"
                shift 2
                ;;
            --monitoring-ip)
                MONITORING_IP="$2"
                SETUP_MONITORING=true
                shift 2
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --use-jump-host)
                USE_JUMP_HOST=true
                shift
                ;;
            --check-keys)
                CHECK_KEYS=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Set default output file
    if [[ -z "$OUTPUT_FILE" ]]; then
        OUTPUT_FILE="$ROOT_DIR/inventories/$ENVIRONMENT/hosts.yml"
    fi

    # Validation
    if [[ -z "$BASTION_IP" ]]; then
        error "Bastion IP is required (-b option)"
        usage
        exit 1
    fi

    # Validate IP configuration
    if [[ ${#NODE_IPS[@]} -eq 0 ]] && [[ -z "$NODE_SUBNET" ]]; then
        error "Either --node-ips or --node-subnet must be specified"
        usage
        exit 1
    fi

    # If using specific IPs, adjust node count
    if [[ ${#NODE_IPS[@]} -gt 0 ]]; then
        NODE_COUNT=${#NODE_IPS[@]}
        log "Node count set to ${NODE_COUNT} based on provided IPs"
    fi

    # Generate IPs if using subnet
    if [[ -n "$NODE_SUBNET" ]] && [[ ${#NODE_IPS[@]} -eq 0 ]]; then
        for ((i=0; i<NODE_COUNT; i++)); do
            NODE_IPS+=("${NODE_SUBNET}.$(($START_IP + i))")
        done
    fi

    # Validate consensus count
    if [[ $CONSENSUS_COUNT -ge $NODE_COUNT ]]; then
        CONSENSUS_COUNT=$((NODE_COUNT - 1))
        warning "Adjusted consensus count to $CONSENSUS_COUNT (must be less than total nodes)"
    fi

    # Check keys if requested
    if [[ "$CHECK_KEYS" == "true" ]]; then
        if ! check_ssh_keys "$ENVIRONMENT" "$NODE_KEY_NAME"; then
            error "SSH keys are missing. Please add them before continuing."
            exit 1
        fi
    fi
}

# Get key paths
get_key_paths() {
    local env=$1
    local node_key_name=${2:-nodes.pem}
    local keys_dir="$ROOT_DIR/keys/ssh/$env"
    
    # Bastion key
    BASTION_KEY_PATH=""
    for key_name in "bastion.pem" "bastion.key"; do
        if [[ -f "$keys_dir/$key_name" ]]; then
            BASTION_KEY_PATH="$keys_dir/$key_name"
            break
        fi
    done
    
    # Node key
    NODE_KEY_PATH=""
    if [[ -f "$keys_dir/$node_key_name" ]]; then
        NODE_KEY_PATH="$keys_dir/$node_key_name"
    fi
}

# Generate inventory file
generate_inventory() {
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN - Would generate inventory with:"
        echo "  Environment: $ENVIRONMENT"
        echo "  Bastion: $BASTION_USER@$BASTION_IP"
        echo "  Nodes: ${NODE_IPS[*]}"
        echo "  Model: $MODEL_TYPE"
        echo "  Network ID: $NETWORK_ID"
        echo "  Output: $OUTPUT_FILE"
        return
    fi

    log "Generating inventory..."
    log "  Environment: $ENVIRONMENT"
    log "  Network ID: $NETWORK_ID"
    log "  Model Type: $MODEL_TYPE"
    log "  Total Nodes: $NODE_COUNT ($CONSENSUS_COUNT consensus)"
    log "  Node IPs: ${NODE_IPS[*]}"

    # Create directory
    local output_dir=$(dirname "$OUTPUT_FILE")
    mkdir -p "$output_dir/group_vars" "$output_dir/host_vars"

    # Get key paths
    get_key_paths "$ENVIRONMENT" "${NODE_KEY_NAME:-nodes.pem}"

    # Determine SSH connection method
    local node_ssh_args=""
    if [[ "$USE_JUMP_HOST" == "true" ]]; then
        # Simpler -J syntax
        node_ssh_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -J $BASTION_USER@$BASTION_IP"
    else
        # ProxyCommand
        node_ssh_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyCommand=\"ssh -W %h:%p -o StrictHostKeyChecking=no -i $BASTION_KEY_PATH $BASTION_USER@$BASTION_IP\""
    fi

    # Generate inventory
    cat > "$OUTPUT_FILE" << EOF
---
# Mitum Inventory - Generated $(date)
# Environment: $ENVIRONMENT
# Network ID: $NETWORK_ID
# Model: $MODEL_TYPE

all:
  children:
    bastion:
      hosts:
        bastion:
          ansible_host: $BASTION_IP
          ansible_user: $BASTION_USER
          ansible_ssh_private_key_file: $BASTION_KEY_PATH
          ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
    
    mitum_nodes:
      hosts:
EOF

    # Add nodes
    local current_port=$PORT_START
    for ((i=0; i<NODE_COUNT; i++)); do
        local node_name="node$i"
        local node_ip="${NODE_IPS[$i]}"
        local is_api_node="false"
        
        if [[ $i -ge $CONSENSUS_COUNT ]]; then
            is_api_node="true"
        fi
        
        cat >> "$OUTPUT_FILE" << EOF
        $node_name:
          ansible_host: $node_ip
          ansible_user: $NODE_USER
          ansible_ssh_common_args: '$node_ssh_args'
EOF
        
        # Add node key if different from bastion
        if [[ -n "$NODE_KEY_PATH" ]] && [[ "$NODE_KEY_PATH" != "$BASTION_KEY_PATH" ]]; then
            echo "          ansible_ssh_private_key_file: $NODE_KEY_PATH" >> "$OUTPUT_FILE"
        fi
        
        cat >> "$OUTPUT_FILE" << EOF
          mitum_node_id: $i
          mitum_node_port: $current_port
          mitum_api_enabled: $is_api_node
EOF
        
        if [[ "$is_api_node" == "true" ]]; then
            echo "          mitum_api_port: 54320" >> "$OUTPUT_FILE"
        fi
        
        echo "" >> "$OUTPUT_FILE"
        ((current_port++))
    done

    # Add group variables
    cat >> "$OUTPUT_FILE" << EOF
      vars:
        mitum_network_id: "$NETWORK_ID"
        mitum_model_type: "$MODEL_TYPE"
        mitum_bind_host: "0.0.0.0"
        mitum_mongodb_replica_set: "mitum-rs"
        mitum_mongodb_auth_enabled: true
        mitum_consensus:
          threshold: 67
          interval_broadcast_ballot: "1.5s"
EOF

    # Add monitoring section if enabled
    if [[ "$SETUP_MONITORING" == "true" ]]; then
        cat >> "$OUTPUT_FILE" << EOF

    monitoring:
      hosts:
        monitor:
          ansible_host: $MONITORING_IP
          ansible_user: $NODE_USER
          ansible_ssh_common_args: '$node_ssh_args'
EOF
        
        # Add monitoring node key if needed
        if [[ -n "$NODE_KEY_PATH" ]] && [[ "$NODE_KEY_PATH" != "$BASTION_KEY_PATH" ]]; then
            echo "          ansible_ssh_private_key_file: $NODE_KEY_PATH" >> "$OUTPUT_FILE"
        fi
        
        cat >> "$OUTPUT_FILE" << EOF
      vars:
        prometheus_port: 9090
        grafana_port: 3000
        alertmanager_port: 9093
        prometheus_version: "2.45.0"
        alertmanager_version: "0.26.0"
        grafana_version: "10.2.0"
EOF
    fi

    log "Inventory generated: $OUTPUT_FILE"
    
    # Generate additional files
    generate_group_vars "$output_dir"
    generate_ssh_config "$output_dir"
    generate_ansible_cfg "$output_dir"
    
    # Display summary
    display_summary
}

# Generate group_vars
generate_group_vars() {
    local output_dir=$1
    local group_vars_file="$output_dir/group_vars/all.yml"
    
    cat > "$group_vars_file" << EOF
---
# Environment-specific variables for $ENVIRONMENT
# Generated: $(date)

# Mitum configuration
mitum_service_name: "mitum"
mitum_version: "latest"
mitum_environment: "$ENVIRONMENT"
mitum_network_id: "$NETWORK_ID"
mitum_model_type: "$MODEL_TYPE"
mitum_install_method: "binary"

# Paths
mitum_install_dir: "/opt/mitum"
mitum_data_dir: "/opt/mitum/data"
mitum_config_dir: "/opt/mitum/config"
mitum_keys_dir: "/opt/mitum/keys"
mitum_log_dir: "/var/log/mitum"
mitum_backup_dir: "/var/backups/mitum"

# Service configuration
mitum_service_user: "mitum"
mitum_service_group: "mitum"

# Network configuration
mitum_nodes_subnet: "${NODE_SUBNET:-${NODE_IPS[0]%.*}}"
mitum_bastion_host: "$BASTION_IP"
mitum_bastion_user: "$BASTION_USER"
mitum_nodes_count: $NODE_COUNT
mitum_consensus_nodes: $CONSENSUS_COUNT

# SSH configuration
mitum_ssh_via_bastion: true
mitum_bastion_key: "keys/ssh/$ENVIRONMENT/bastion.pem"

# MongoDB configuration
mitum_mongodb_version: "7.0"
mitum_mongodb_replica_set: "mitum-rs"
mitum_mongodb_auth_enabled: false
mitum_mongodb_bind_ip: "0.0.0.0"
mitum_mongodb_port: 27017
mitum_mongodb_database: "mitum"
mitum_mongodb_user: "mitum"
mitum_mongodb_password: "mitum123"
mitum_mongodb_admin_user: "admin"
mitum_mongodb_admin_password: "admin123"
mitum_mongodb_keyfile: "/opt/mitum/mongodb-keyfile"

# Key generation
mitum_keygen_strategy: "centralized"
mitum_threshold: 67

# Consensus configuration
mitum_consensus:
  threshold: 67
  interval_broadcast_ballot: "1.5s"
  interval_broadcast_proposal: "5s"
  wait_broadcast_ballot: "10s"
  wait_broadcast_proposal: "10s"

# API configuration
mitum_api:
  bind: "0.0.0.0"
  port: 54320
  cache_size: 1000
  timeout: "30s"

# Storage
mitum_storage:
  database: "mongodb://localhost:27017/mitum"
  blockdata_path: "{{ mitum_data_dir }}/blockdata"

# Network settings
mitum_network:
  bind: "0.0.0.0"
  publish: "{{ ansible_default_ipv4.address }}"
  tls_insecure: true

# Feature flags based on model
mitum_features:
  enable_api: true
  enable_digest: true
  enable_metrics: true
  enable_profiler: false
EOF

    # Add model-specific features
    case "$MODEL_TYPE" in
        mitum-currency-operations)
            cat >> "$group_vars_file" << EOF
  enable_operations: true
  enable_contract: false
EOF
            ;;
        mitum-nft)
            cat >> "$group_vars_file" << EOF
  enable_nft: true
  enable_collection: true
EOF
            ;;
        mitum-document)
            cat >> "$group_vars_file" << EOF
  enable_document: true
  enable_storage: true
EOF
            ;;
    esac

    cat >> "$group_vars_file" << EOF

# Monitoring configuration
mitum_monitoring:
  enabled: $SETUP_MONITORING
  prometheus_enabled: $SETUP_MONITORING
  prometheus_port: 9099
  node_exporter_port: 9100
  prometheus_server: "${MONITORING_IP:-localhost}"

# Logging
mitum_logging:
  level: "info"
  format: "json"
  output: "stdout"
  file_enabled: true
  file_path: "{{ mitum_log_dir }}/mitum.log"
  file_max_size: "100MB"
  file_max_age: 30
  file_max_backups: 10

# Backup configuration
mitum_backup:
  enabled: false
  schedule: "0 2 * * *"
  retention_days: 7
  path: "/var/backups/mitum"

# Key generation settings
mitum_keys_threshold: 100
mitum_keygen_type: "btc"

# AWX Integration
awx_integration_enabled: $AWX_ENABLED
EOF

    if [[ "$AWX_ENABLED" == "true" ]]; then
        cat >> "$group_vars_file" << EOF
awx_base_url: "$AWX_URL"
# AWX token should be stored in vault
# awx_token: "{{ vault_awx_token }}"

# AWX webhook for maintenance notifications
mitum_maintenance_webhook: "$AWX_URL/api/v2/webhooks/"
EOF
        
        # Create vault file for sensitive data
        local vault_file="$output_dir/group_vars/vault.yml"
        if [[ -n "$AWX_TOKEN" ]]; then
            echo "---" > "$vault_file"
            echo "vault_awx_token: \"$AWX_TOKEN\"" >> "$vault_file"
            echo "" >> "$vault_file"
            warning "Created vault.yml with AWX token. Encrypt it with: ansible-vault encrypt $vault_file"
        fi
    fi

    log "Created group_vars: $group_vars_file"
}

# Generate SSH config
generate_ssh_config() {
    local output_dir=$1
    local ssh_config_file="$output_dir/ssh_config"
    
    cat > "$ssh_config_file" << EOF
# SSH configuration for $ENVIRONMENT environment
# Generated: $(date)

Host bastion
    HostName $BASTION_IP
    User $BASTION_USER
    IdentityFile $BASTION_KEY_PATH
    ForwardAgent yes
    ControlMaster auto
    ControlPath ~/.ssh/mitum-%r@%h:%p
    ControlPersist 30m
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null

EOF

    # Add node configurations
    for ((i=0; i<NODE_COUNT; i++)); do
        cat >> "$ssh_config_file" << EOF
Host node$i
    HostName ${NODE_IPS[$i]}
    User $NODE_USER
    ProxyJump bastion
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOF
        
        # Add identity file if using different key
        if [[ -n "$NODE_KEY_PATH" ]] && [[ "$NODE_KEY_PATH" != "$BASTION_KEY_PATH" ]]; then
            echo "    IdentityFile $NODE_KEY_PATH" >> "$ssh_config_file"
        fi
        
        echo "" >> "$ssh_config_file"
    done

    # Add monitoring host if configured
    if [[ -n "$MONITORING_IP" ]]; then
        cat >> "$ssh_config_file" << EOF
Host monitor
    HostName $MONITORING_IP
    User $NODE_USER
    ProxyJump bastion
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOF
        
        if [[ -n "$NODE_KEY_PATH" ]] && [[ "$NODE_KEY_PATH" != "$BASTION_KEY_PATH" ]]; then
            echo "    IdentityFile $NODE_KEY_PATH" >> "$ssh_config_file"
        fi
    fi

    log "Created SSH config: $ssh_config_file"
}

# Generate ansible.cfg
generate_ansible_cfg() {
    local output_dir=$1
    local ansible_cfg_file="$output_dir/ansible.cfg"
    
    cat > "$ansible_cfg_file" << EOF
[defaults]
inventory = hosts.yml
host_key_checking = False
retry_files_enabled = False
gathering = smart
fact_caching = jsonfile
fact_caching_connection = .ansible_cache
fact_caching_timeout = 86400
stdout_callback = yaml
callback_whitelist = profile_tasks, timer
interpreter_python = auto_silent

[inventory]
enable_plugins = host_list, yaml, ini, auto

[ssh_connection]
ssh_args = -F ssh_config -o ControlMaster=auto -o ControlPersist=30m
control_path = ~/.ssh/mitum-%%r@%%h:%%p
pipelining = True

[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False
EOF

    log "Created ansible.cfg: $ansible_cfg_file"
}

# Display summary
display_summary() {
    local output_dir=$(dirname "$OUTPUT_FILE")
    
    echo ""
    echo -e "${GREEN}=== Inventory Generation Complete ===${NC}"
    echo ""
    echo "Configuration Summary:"
    echo "  Environment: $ENVIRONMENT"
    echo "  Network ID: $NETWORK_ID"
    echo "  Model Type: $MODEL_TYPE"
    echo "  Total Nodes: $NODE_COUNT"
    echo "  - Consensus: $CONSENSUS_COUNT (node0-node$((CONSENSUS_COUNT-1)))"
    echo "  - API/Syncer: $((NODE_COUNT-CONSENSUS_COUNT)) (node${CONSENSUS_COUNT}+)"
    echo ""
    echo "Network Configuration:"
    echo "  Bastion: $BASTION_USER@$BASTION_IP"
    echo "  Nodes:"
    for ((i=0; i<NODE_COUNT; i++)); do
        local role="Consensus"
        [[ $i -ge $CONSENSUS_COUNT ]] && role="API"
        echo "    - node$i: ${NODE_IPS[$i]} ($role)"
    done
    if [[ -n "$MONITORING_IP" ]]; then
        echo "  Monitoring: $MONITORING_IP"
    fi
    echo ""
    echo "Files created:"
    echo "  - $OUTPUT_FILE"
    echo "  - $output_dir/group_vars/all.yml"
    echo "  - $output_dir/ssh_config"
    echo "  - $output_dir/ansible.cfg"
    echo ""
    echo -e "${YELLOW}SSH Key Setup:${NC}"
    if [[ -n "$BASTION_KEY_PATH" ]]; then
        echo "  ✓ Bastion key: $BASTION_KEY_PATH"
    else
        echo "  ✗ Bastion key: Not found"
    fi
    if [[ -n "$NODE_KEY_PATH" ]]; then
        echo "  ✓ Node key: $NODE_KEY_PATH"
    else
        echo "  ✗ Node key: Not found"
    fi
    echo ""
    echo -e "${YELLOW}Next steps:${NC}"
    echo "1. Test connectivity:"
    echo "   ansible -i $OUTPUT_FILE all -m ping"
    echo ""
    echo "2. Deploy Mitum:"
    echo "   cd $ROOT_DIR"
    echo "   source venv/bin/activate"
    echo "   make keygen"
    echo "   make deploy"
    echo ""
    echo "Alternative connection methods:"
    echo "  # Using SSH config"
    echo "  ssh -F $output_dir/ssh_config bastion"
    echo "  ssh -F $output_dir/ssh_config node0"
    echo ""
    echo "  # Using ansible.cfg"
    echo "  cd $output_dir && ansible all -m ping"
}

# Main execution
main() {
    # Interactive mode if no arguments
    if [[ $# -eq 0 ]]; then
        interactive_mode
    else
        # Command-line mode
        parse_args "$@"
        generate_inventory
    fi
}

# Execute
main "$@"

================================================================================
파일: scripts/interactive-setup.sh
================================================================================
#!/bin/bash

# 🚀 Mitum Ansible Interactive Setup Script
# User-friendly initial setup assistant

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# 이모지와 함께 출력하는 함수들
print_header() {
    echo -e "\n${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}🎯 $1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_question() {
    echo -e "${MAGENTA}❓ $1${NC}"
}

# 대시보드 출력
show_dashboard() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"
    __  _______ ______ __  __ __  ___       _      _   __ _____ ____ ____   __    ______
   /  |/  /  _//_  __// / / //  |/  /      / \    / | / // ___//  _// __ ) / /   / ____/
  / /|_/ // /   / /  / / / // /|_/ /      / _ \  /  |/ / \__ \ / / / __  |/ /   / __/   
 / /  / // /   / /  / /_/ // /  / /      / ___ \/ /|  / ___/ // / / /_/ // /___/ /___   
/_/  /_/___/  /_/   \____//_/  /_/      /_/   \_\_/ |_//____/___//_____//_____/_____/   
                                                                                         
EOF
    echo -e "${NC}"
    echo -e "${GREEN}🎉 Mitum 블록체인 배포 자동화 시스템에 오신 것을 환영합니다!${NC}"
    echo -e "${BLUE}📖 이 스크립트는 초기 설정을 도와드립니다.${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

# 프로그레스 바 표시
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    
    printf "\r["
    printf "%${filled}s" | tr ' ' '='
    printf "%$((width - filled))s" | tr ' ' ' '
    printf "] %d%%" $percentage
}

# 환경 선택
select_environment() {
    print_header "환경 선택"
    echo "어떤 환경을 설정하시겠습니까?"
    echo
    echo "  1) 🏗️  Development (개발 환경)"
    echo "  2) 🧪 Staging (스테이징 환경)"
    echo "  3) 🚀 Production (프로덕션 환경)"
    echo
    
    while true; do
        print_question "선택해주세요 (1-3): "
        read -r env_choice
        
        case $env_choice in
            1)
                ENVIRONMENT="development"
                print_success "개발 환경을 선택하셨습니다."
                break
                ;;
            2)
                ENVIRONMENT="staging"
                print_success "스테이징 환경을 선택하셨습니다."
                break
                ;;
            3)
                ENVIRONMENT="production"
                print_warning "프로덕션 환경을 선택하셨습니다. 신중하게 진행해주세요!"
                break
                ;;
            *)
                print_error "잘못된 선택입니다. 1-3 중에서 선택해주세요."
                ;;
        esac
    done
}

# 노드 수 입력
input_node_count() {
    print_header "노드 구성"
    echo "몇 개의 노드를 구성하시겠습니까?"
    echo
    print_info "권장사항:"
    echo "  • 개발 환경: 1-3개"
    echo "  • 스테이징 환경: 3-5개"
    echo "  • 프로덕션 환경: 5개 이상"
    echo
    
    while true; do
        print_question "노드 수를 입력해주세요 (1-10): "
        read -r node_count
        
        if [[ "$node_count" =~ ^[0-9]+$ ]] && [ "$node_count" -ge 1 ] && [ "$node_count" -le 10 ]; then
            print_success "$node_count개의 노드를 구성합니다."
            break
        else
            print_error "1에서 10 사이의 숫자를 입력해주세요."
        fi
    done
}

# 네트워크 설정
configure_network() {
    print_header "네트워크 설정"
    
    # 네트워크 ID
    print_question "네트워크 ID를 입력해주세요 (기본값: mitum-test): "
    read -r network_id
    NETWORK_ID=${network_id:-mitum-test}
    print_success "네트워크 ID: $NETWORK_ID"
    
    # 체인 ID
    print_question "체인 ID를 입력해주세요 (기본값: 100): "
    read -r chain_id
    CHAIN_ID=${chain_id:-100}
    print_success "체인 ID: $CHAIN_ID"
}

# SSH 설정
configure_ssh() {
    print_header "SSH 연결 설정"
    
    print_question "SSH 키를 자동으로 생성하시겠습니까? (Y/n): "
    read -r generate_ssh
    
    if [[ "$generate_ssh" != "n" && "$generate_ssh" != "N" ]]; then
        print_info "SSH 키를 생성합니다..."
        
        SSH_KEY_PATH="keys/ssh/$ENVIRONMENT/mitum_key"
        mkdir -p "keys/ssh/$ENVIRONMENT"
        
        if [ ! -f "$SSH_KEY_PATH" ]; then
            ssh-keygen -t ed25519 -f "$SSH_KEY_PATH" -N "" -q
            print_success "SSH 키가 생성되었습니다: $SSH_KEY_PATH"
        else
            print_warning "SSH 키가 이미 존재합니다: $SSH_KEY_PATH"
        fi
    else
        print_info "기존 SSH 키를 사용합니다."
        print_question "SSH 키 경로를 입력해주세요: "
        read -r ssh_key_path
        SSH_KEY_PATH=$ssh_key_path
    fi
}

# 인벤토리 생성
create_inventory() {
    print_header "인벤토리 파일 생성"
    
    INVENTORY_FILE="inventories/$ENVIRONMENT/hosts.yml"
    mkdir -p "inventories/$ENVIRONMENT/group_vars"
    mkdir -p "inventories/$ENVIRONMENT/host_vars"
    
    cat > "$INVENTORY_FILE" << EOF
---
# $ENVIRONMENT 환경 인벤토리
# 자동 생성: $(date)

all:
  vars:
    ansible_user: ubuntu
    ansible_ssh_private_key_file: ../../$SSH_KEY_PATH
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    
    # Mitum 설정
    mitum_environment: $ENVIRONMENT
    mitum_network_id: $NETWORK_ID
    mitum_chain_id: $CHAIN_ID

mitum_nodes:
  hosts:
EOF
    
    # 노드 추가
    for i in $(seq 1 "$node_count"); do
        echo "    node$((i-1)):" >> "$INVENTORY_FILE"
        
        print_question "node$((i-1))의 IP 주소를 입력해주세요: "
        read -r node_ip
        
        echo "      ansible_host: $node_ip" >> "$INVENTORY_FILE"
        
        if [ "$i" -le 3 ]; then
            echo "      mitum_node_type: consensus" >> "$INVENTORY_FILE"
        else
            echo "      mitum_node_type: api" >> "$INVENTORY_FILE"
        fi
        echo >> "$INVENTORY_FILE"
    done
    
    print_success "인벤토리 파일이 생성되었습니다: $INVENTORY_FILE"
}

# 검증
validate_setup() {
    print_header "설정 검증"
    
    echo "설정을 검증하는 중..."
    echo
    
    # 프로그레스 바 표시
    items=("Python 버전" "Ansible 설치" "SSH 키" "인벤토리 파일" "네트워크 연결")
    total=${#items[@]}
    
    for i in "${!items[@]}"; do
        show_progress $((i+1)) $total
        sleep 0.5
        
        case $i in
            0) python3 --version &>/dev/null && status="✅" || status="❌" ;;
            1) [ -f "venv/bin/ansible" ] && status="✅" || status="❌" ;;
            2) [ -f "$SSH_KEY_PATH" ] && status="✅" || status="❌" ;;
            3) [ -f "$INVENTORY_FILE" ] && status="✅" || status="❌" ;;
            4) status="✅" ;; # 네트워크는 나중에 실제로 테스트
        esac
    done
    
    echo -e "\n"
    print_success "검증 완료!"
}

# 다음 단계 안내
show_next_steps() {
    print_header "🎉 설정 완료!"
    
    echo -e "${GREEN}축하합니다! 초기 설정이 완료되었습니다.${NC}"
    echo
    echo -e "${CYAN}📋 설정 요약:${NC}"
    echo "  • 환경: $ENVIRONMENT"
    echo "  • 노드 수: $node_count"
    echo "  • 네트워크 ID: $NETWORK_ID"
    echo "  • 체인 ID: $CHAIN_ID"
    echo
    echo -e "${YELLOW}🚀 다음 단계:${NC}"
    echo
    echo "1. 가상 환경 활성화:"
    echo -e "   ${BLUE}source venv/bin/activate${NC}"
    echo
    echo "2. 연결 테스트:"
    echo -e "   ${BLUE}make test ENV=$ENVIRONMENT${NC}"
    echo
    echo "3. 시스템 준비:"
    echo -e "   ${BLUE}make prepare ENV=$ENVIRONMENT${NC}"
    echo
    echo "4. Mitum 배포:"
    echo -e "   ${BLUE}make deploy ENV=$ENVIRONMENT${NC}"
    echo
    echo -e "${GREEN}💡 도움이 필요하시면 'make help'를 실행해주세요.${NC}"
    echo
}

# 메인 실행
main() {
    show_dashboard
    
    print_question "설정을 시작하시겠습니까? (Y/n): "
    read -r confirm
    
    if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
        print_info "설정을 취소했습니다."
        exit 0
    fi
    
    select_environment
    input_node_count
    configure_network
    configure_ssh
    create_inventory
    validate_setup
    show_next_steps
    
    # 설정 저장
    cat > ".last_setup" << EOF
ENVIRONMENT=$ENVIRONMENT
NODE_COUNT=$node_count
NETWORK_ID=$NETWORK_ID
CHAIN_ID=$CHAIN_ID
SETUP_DATE=$(date)
EOF
}

# 스크립트 실행
main 

================================================================================
파일: scripts/manage-keys.sh
================================================================================
#!/bin/bash
# Key management helper script

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
KEYS_DIR="$ROOT_DIR/keys"

usage() {
    cat << USAGE
${GREEN}SSH Key Management Helper${NC}

Manage SSH keys for Mitum Ansible deployments.

${YELLOW}Usage:${NC} 
    $0 [COMMAND] [OPTIONS]

${YELLOW}Commands:${NC}
    add <env> <source> [name]   Add SSH key to project
    list                        List all SSH keys
    check                       Check key permissions
    fix                         Fix key permissions (set to 600)
    show <env>                  Show keys for specific environment
    remove <env> <name>         Remove a key

${YELLOW}Arguments:${NC}
    env         Environment (production, staging, development)
    source      Source key file path
    name        Target key name (default: keeps original name)

${YELLOW}Examples:${NC}
    # Add AWS key as bastion key for production
    $0 add production ~/Downloads/aws-key.pem bastion.pem
    
    # Add same key for nodes
    $0 add production ~/Downloads/aws-key.pem nodes.pem
    
    # List all keys
    $0 list
    
    # Check permissions
    $0 check
    
    # Fix permissions
    $0 fix
    
    # Show production keys
    $0 show production
    
    # Remove a key
    $0 remove staging old-key.pem

${YELLOW}Key Naming Convention:${NC}
    bastion.pem     - For bastion host access
    nodes.pem       - For node access
    <custom>.pem    - Custom key names

USAGE
}

# Add key function
add_key() {
    local env=$1
    local source=$2
    local name=${3:-}
    
    # Validate environment
    if [[ ! "$env" =~ ^(production|staging|development)$ ]]; then
        echo -e "${RED}Error: Invalid environment '$env'${NC}"
        echo "Valid environments: production, staging, development"
        exit 1
    fi
    
    # Check source file
    if [[ ! -f "$source" ]]; then
        echo -e "${RED}Error: Source key file not found: $source${NC}"
        exit 1
    fi
    
    # Determine target name
    if [[ -z "$name" ]]; then
        name=$(basename "$source")
    fi
    
    # Validate key extension
    if [[ ! "$name" =~ \.(pem|key)$ ]]; then
        echo -e "${YELLOW}Warning: Key file should have .pem or .key extension${NC}"
    fi
    
    # Create directory if needed
    mkdir -p "$KEYS_DIR/ssh/$env"
    
    # Target path
    local target="$KEYS_DIR/ssh/$env/$name"
    
    # Check if exists
    if [[ -f "$target" ]]; then
        echo -ne "${YELLOW}Key already exists. Overwrite? [y/N]: ${NC}"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Cancelled"
            exit 0
        fi
    fi
    
    # Copy key
    cp "$source" "$target"
    chmod 600 "$target"
    
    echo -e "${GREEN}✓ Key added successfully${NC}"
    echo -e "  Environment: ${BLUE}$env${NC}"
    echo -e "  Key name: ${BLUE}$name${NC}"
    echo -e "  Location: ${BLUE}$target${NC}"
    
    # Show usage hint
    if [[ "$name" == "bastion.pem" ]] || [[ "$name" == "nodes.pem" ]]; then
        echo -e "\n${YELLOW}This key will be automatically used when generating inventory for $env environment${NC}"
    fi
}

# List keys function
list_keys() {
    echo -e "${GREEN}=== SSH Keys in Project ===${NC}\n"
    
    local found_any=false
    
    for env in production staging development; do
        echo -e "${BLUE}[$env]${NC}"
        
        if [[ -d "$KEYS_DIR/ssh/$env" ]]; then
            local found=false
            for key in "$KEYS_DIR/ssh/$env"/*.pem "$KEYS_DIR/ssh/$env"/*.key 2>/dev/null; do
                if [[ -f "$key" ]]; then
                    found=true
                    found_any=true
                    local perms=$(stat -c %a "$key" 2>/dev/null || stat -f %p "$key" 2>/dev/null | tail -c 4)
                    local size=$(du -h "$key" | cut -f1)
                    local modified=$(stat -c %y "$key" 2>/dev/null || stat -f "%Sm" "$key" 2>/dev/null)
                    modified=${modified%% *}  # Get just the date
                    
                    local name=$(basename "$key")
                    local status="OK"
                    local color=$GREEN
                    
                    if [[ "$perms" != "600" ]]; then
                        status="Wrong permissions"
                        color=$RED
                    fi
                    
                    printf "  %-20s %s %-5s %-10s %s\n" \
                        "$name" \
                        "($perms)" \
                        "$size" \
                        "$modified" \
                        "$(echo -e "$color$status$NC")"
                fi
            done
            
            if [[ "$found" == "false" ]]; then
                echo "  (no keys)"
            fi
        else
            echo "  (no keys)"
        fi
        echo ""
    done
    
    if [[ "$found_any" == "false" ]]; then
        echo -e "${YELLOW}No SSH keys found in project${NC}"
        echo -e "Add keys using: $0 add <environment> <key-file>"
    fi
}

# Show specific environment
show_env() {
    local env=$1
    
    if [[ ! "$env" =~ ^(production|staging|development)$ ]]; then
        echo -e "${RED}Error: Invalid environment '$env'${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}SSH Keys for $env:${NC}\n"
    
    if [[ -d "$KEYS_DIR/ssh/$env" ]]; then
        local found=false
        for key in "$KEYS_DIR/ssh/$env"/*.pem "$KEYS_DIR/ssh/$env"/*.key 2>/dev/null; do
            if [[ -f "$key" ]]; then
                found=true
                local name=$(basename "$key")
                local perms=$(stat -c %a "$key" 2>/dev/null || stat -f %p "$key" 2>/dev/null | tail -c 4)
                local fingerprint=$(ssh-keygen -l -f "$key" 2>/dev/null | awk '{print $2}' || echo "N/A")
                
                echo -e "${BLUE}$name${NC}"
                echo "  Path: $key"
                echo "  Permissions: $perms"
                echo "  Fingerprint: $fingerprint"
                echo ""
            fi
        done
        
        if [[ "$found" == "false" ]]; then
            echo "(no keys found)"
        fi
    else
        echo "(no keys directory)"
    fi
}

# Check permissions
check_permissions() {
    echo -e "${GREEN}Checking SSH key permissions...${NC}\n"
    
    local errors=0
    local checked=0
    
    find "$KEYS_DIR/ssh" -type f \( -name "*.pem" -o -name "*.key" \) 2>/dev/null | while IFS= read -r key; do
        ((checked++))
        local perms=$(stat -c %a "$key" 2>/dev/null || stat -f %p "$key" 2>/dev/null | tail -c 4)
        local relpath=${key#$KEYS_DIR/ssh/}
        
        if [[ "$perms" != "600" ]]; then
            echo -e "${RED}✗ Wrong permissions ($perms):${NC} $relpath"
            ((errors++))
        else
            echo -e "${GREEN}✓ OK:${NC} $relpath"
        fi
    done
    
    if [[ $checked -eq 0 ]]; then
        echo -e "${YELLOW}No SSH keys found to check${NC}"
    elif [[ $errors -eq 0 ]]; then
        echo -e "\n${GREEN}All $checked keys have correct permissions (600)${NC}"
    else
        echo -e "\n${RED}Found $errors keys with incorrect permissions${NC}"
        echo -e "Run '${BLUE}$0 fix${NC}' to fix permissions automatically"
    fi
}

# Fix permissions
fix_permissions() {
    echo -e "${GREEN}Fixing SSH key permissions...${NC}\n"
    
    local fixed=0
    
    find "$KEYS_DIR/ssh" -type f \( -name "*.pem" -o -name "*.key" \) 2>/dev/null | while IFS= read -r key; do
        local perms=$(stat -c %a "$key" 2>/dev/null || stat -f %p "$key" 2>/dev/null | tail -c 4)
        local relpath=${key#$KEYS_DIR/ssh/}
        
        if [[ "$perms" != "600" ]]; then
            chmod 600 "$key"
            echo -e "${GREEN}✓ Fixed:${NC} $relpath (was $perms, now 600)"
            ((fixed++))
        fi
    done
    
    if [[ $fixed -eq 0 ]]; then
        echo -e "${GREEN}All keys already have correct permissions${NC}"
    else
        echo -e "\n${GREEN}Fixed permissions for $fixed key(s)${NC}"
    fi
}

# Remove key
remove_key() {
    local env=$1
    local name=$2
    
    if [[ ! "$env" =~ ^(production|staging|development)$ ]]; then
        echo -e "${RED}Error: Invalid environment '$env'${NC}"
        exit 1
    fi
    
    local key_path="$KEYS_DIR/ssh/$env/$name"
    
    if [[ ! -f "$key_path" ]]; then
        echo -e "${RED}Error: Key not found: $key_path${NC}"
        exit 1
    fi
    
    echo -ne "${YELLOW}Remove key '$name' from $env? [y/N]: ${NC}"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -f "$key_path"
        echo -e "${GREEN}✓ Key removed${NC}"
    else
        echo "Cancelled"
    fi
}

# Main execution
case "${1:-help}" in
    add)
        if [[ $# -lt 3 ]]; then
            echo -e "${RED}Error: Missing arguments${NC}"
            echo "Usage: $0 add <environment> <source-key-file> [target-name]"
            echo "Example: $0 add production ~/Downloads/aws-key.pem bastion.pem"
            exit 1
        fi
        add_key "$2" "$3" "${4:-}"
        ;;
    
    list)
        list_keys
        ;;
    
    show)
        if [[ $# -lt 2 ]]; then
            echo -e "${RED}Error: Missing environment${NC}"
            echo "Usage: $0 show <environment>"
            exit 1
        fi
        show_env "$2"
        ;;
    
    check)
        check_permissions
        ;;
    
    fix)
        fix_permissions
        ;;
    
    remove)
        if [[ $# -lt 3 ]]; then
            echo -e "${RED}Error: Missing arguments${NC}"
            echo "Usage: $0 remove <environment> <key-name>"
            exit 1
        fi
        remove_key "$2" "$3"
        ;;
    
    help|--help|-h)
        usage
        ;;
    
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}"
        usage
        exit 1
        ;;
esac

================================================================================
파일: scripts/master-cleanup.sh
================================================================================
#!/bin/bash

# Mitum Ansible Master Cleanup and Optimization Script
# Version: 1.1.0 - macOS Compatible
#
# This script performs the following tasks:
# 1. Remove duplicate files
# 2. Optimize project structure
# 3. Improve performance
# 4. Enhance security
# 5. Generate documentation
# 6. Final validation

set -e

# Detect OS and set appropriate settings
UNAME=$(uname -s)
if [[ "$UNAME" == "Darwin" ]]; then
    # macOS specific settings
    OS_TYPE="macOS"
    # Use different locale for macOS
    export LC_ALL=en_US.UTF-8
    export LANG=en_US.UTF-8
    SED_CMD="sed -i.bak"
else
    OS_TYPE="Linux"
    SED_CMD="sed -i"
fi

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Log functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
}

log_success() {
    echo -e "${CYAN}[SUCCESS]${NC} $1"
}

log_header() {
    echo -e "${PURPLE}[HEADER]${NC} $1"
}

# Create backup
create_backup() {
    log_step "Creating backup..."
    BACKUP_DIR="backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$BACKUP_DIR"
    
    # Backup important files (with macOS compatibility)
    for item in ansible.cfg Makefile requirements.txt playbooks roles inventories keys scripts; do
        if [ -e "$item" ]; then
            cp -r "$item" "$BACKUP_DIR/" 2>/dev/null || true
        fi
    done
    
    if [ -d "core-files" ]; then
        cp -r core-files "$BACKUP_DIR/" 2>/dev/null || true
    fi
    
    log_info "Backup created in $BACKUP_DIR"
}

# Remove duplicate files
remove_duplicates() {
    log_step "Removing duplicate files..."
    
    # .DS_Store files removal (macOS specific)
    if [[ "$OS_TYPE" == "macOS" ]]; then
        DS_STORE_COUNT=$(find . -name ".DS_Store" -type f 2>/dev/null | wc -l | tr -d ' ')
        if [ "$DS_STORE_COUNT" -gt 0 ]; then
            log_info "Found $DS_STORE_COUNT .DS_Store files"
            find . -name ".DS_Store" -type f -delete 2>/dev/null || true
            log_info ".DS_Store files removed"
        fi
        
        # Remove other macOS system files
        find . -name "._*" -type f -delete 2>/dev/null || true
        find . -name ".Spotlight-V100" -type d -exec rm -rf {} + 2>/dev/null || true
        find . -name ".Trashes" -type d -exec rm -rf {} + 2>/dev/null || true
    fi
    
    # Remove core-files directory (duplicate of root)
    if [ -d "core-files" ]; then
        log_info "Removing core-files directory (duplicate of root)..."
        rm -rf core-files
        log_info "core-files directory removed"
    fi
    
    # Clean empty directories
    EMPTY_DIRS=$(find . -type d -empty -not -path "./.git*" -not -path "./venv*" 2>/dev/null || true)
    if [ -n "$EMPTY_DIRS" ]; then
        echo "$EMPTY_DIRS" | xargs rmdir 2>/dev/null || true
        log_info "Empty directories cleaned"
    fi
}

# Optimize project structure
optimize_structure() {
    log_step "Optimizing project structure..."
    
    # Create standard directory structure
    mkdir -p {logs,tmp,cache,backups} 2>/dev/null || true
    
    # Improve environment-specific directory structure
    for env in development staging production; do
        if [ -d "inventories/$env" ]; then
            mkdir -p "inventories/$env"/{group_vars,host_vars,ssh_keys} 2>/dev/null || true
        fi
    done
    
    # Improve keys directory structure
    mkdir -p keys/{development,staging,production,testnet} 2>/dev/null || true
    
    log_info "Directory structure optimized"
}

# Improve performance
improve_performance() {
    log_step "Improving performance..."
    
    # Optimize Ansible configuration
    if [ -f "ansible.cfg" ]; then
        # Improve parallel processing
        if ! grep -q "forks = 50" ansible.cfg 2>/dev/null; then
            $SED_CMD 's/forks = [0-9]*/forks = 50/' ansible.cfg 2>/dev/null || true
        fi
        
        # Improve cache settings
        if ! grep -q "fact_caching = jsonfile" ansible.cfg 2>/dev/null; then
            echo "" >> ansible.cfg
            echo "[defaults]" >> ansible.cfg
            echo "fact_caching = jsonfile" >> ansible.cfg
            echo "fact_caching_connection = .ansible_cache" >> ansible.cfg
            echo "fact_caching_timeout = 86400" >> ansible.cfg
        fi
    fi
    
    # Optimize Makefile
    if [ -f "Makefile" ]; then
        # Add performance flags
        if ! grep -q "PARALLEL_FORKS" Makefile 2>/dev/null; then
            $SED_CMD '/^# === Configuration ===/a\
# Performance optimization options\
PARALLEL_FORKS ?= 50\
CACHE_ENABLED ?= yes\
FACT_CACHING ?= jsonfile' Makefile 2>/dev/null || true
        fi
    fi
    
    log_info "Performance improved"
}

# Enhance security
enhance_security() {
    log_step "Enhancing security..."
    
    # Set SSH key permissions
    find keys/ -name "*.pem" -exec chmod 600 {} \; 2>/dev/null || true
    find keys/ -name "*.key" -exec chmod 600 {} \; 2>/dev/null || true
    
    # Create Vault file if it doesn't exist
    if [ ! -f ".vault_pass" ]; then
        log_info "Creating Ansible Vault password file..."
        echo "mitum-vault-$(date +%s)" > .vault_pass
        chmod 600 .vault_pass
    fi
    
    # Update .gitignore
    if [ -f ".gitignore" ]; then
        # Add security-related files
        for pattern in ".vault_pass" "*.pem" "*.key" "secrets/" "vault*.yml"; do
            if ! grep -q "$pattern" .gitignore 2>/dev/null; then
                echo "$pattern" >> .gitignore
            fi
        done
        
        # Add macOS specific exclusions
        if [[ "$OS_TYPE" == "macOS" ]]; then
            for pattern in ".DS_Store" ".DS_Store?" "._*" ".Spotlight-V100" ".Trashes"; do
                if ! grep -q "$pattern" .gitignore 2>/dev/null; then
                    echo "$pattern" >> .gitignore
                fi
            done
        fi
    fi
    
    log_info "Security enhanced"
}

# Improve code quality
improve_code_quality() {
    log_step "Improving code quality..."
    
    # Validate YAML files
    YAML_ERRORS=0
    find . -name "*.yml" -type f 2>/dev/null | while read -r file; do
        if command -v yamllint >/dev/null 2>&1; then
            if ! yamllint "$file" >/dev/null 2>&1; then
                log_warn "YAML syntax error: $file"
                YAML_ERRORS=$((YAML_ERRORS + 1))
            fi
        fi
    done
    
    # Validate Ansible syntax
    ANSIBLE_ERRORS=0
    if command -v ansible-playbook >/dev/null 2>&1; then
        find playbooks/ -name "*.yml" -type f 2>/dev/null | while read -r playbook; do
            if ! ansible-playbook --syntax-check "$playbook" >/dev/null 2>&1; then
                log_warn "Ansible syntax error: $playbook"
                ANSIBLE_ERRORS=$((ANSIBLE_ERRORS + 1))
            fi
        done
    fi
    
    if [ "$YAML_ERRORS" -eq 0 ] && [ "$ANSIBLE_ERRORS" -eq 0 ]; then
        log_info "Code quality improved"
    else
        log_warn "Some code quality issues found"
    fi
}

# Generate documentation
generate_documentation() {
    log_step "Generating documentation..."
    
    # Project structure documentation
    cat > PROJECT_STRUCTURE.md << 'EOF'
# Mitum Ansible Project Structure (Optimized Version)

## Overview
This document describes the structure of the optimized Mitum Ansible project.

## Directory Structure

```
mitum-ansible/
├── ansible.cfg              # Ansible configuration file (optimized)
├── Makefile                 # Build and deployment commands (optimized)
├── requirements.txt         # Python dependencies
├── README.md               # Project documentation
├── .gitignore              # Git exclude file (security enhanced)
├── .vault_pass             # Ansible Vault password
├── playbooks/              # Ansible playbooks
│   ├── site.yml           # Main deployment playbook
│   ├── deploy-mitum.yml   # Mitum deployment
│   ├── backup.yml         # Backup
│   └── ...
├── roles/                  # Ansible roles
│   └── mitum/             # Mitum node role
├── inventories/            # Inventory
│   ├── development/       # Development environment
│   ├── staging/          # Staging environment
│   └── production/       # Production environment
├── keys/                  # SSH keys and Mitum keys
├── logs/                  # Log files
├── scripts/               # Utility scripts
└── tools/                 # Tools and scripts
```

## Key Improvements

### 1. Duplicate Removal
- core-files directory removed
- .DS_Store files cleaned
- Duplicate configuration files merged

### 2. Performance Optimization
- Parallel processing improved (forks = 50)
- Fact caching enabled
- Connection reuse optimization

### 3. Security Enhancement
- SSH key permissions set (600)
- Vault encryption support
- Sensitive files excluded from .gitignore

### 4. Structure Improvement
- Standard directory structure
- Environment separation
- Clear file organization

## Usage

### Basic Commands
```bash
# Project optimization
make optimize

# Duplicate removal
make deduplicate

# Deployment
make deploy

# Backup
make backup
```

### Environment-specific Usage
```bash
# Development environment
ENV=development make deploy

# Production environment
ENV=production make deploy
```
EOF

    # Optimization guide documentation
    cat > OPTIMIZATION_GUIDE.md << 'EOF'
# Mitum Ansible Optimization Guide

## Overview
This guide explains how to optimize the Mitum Ansible project.

## Optimization Steps

### 1. Duplicate Removal
```bash
# Clean duplicate files
./cleanup-duplicates.sh

# Or use Makefile
make deduplicate
```

### 2. Performance Optimization
```bash
# Optimize Ansible configuration
make optimize-config

# Set parallel processing
PARALLEL_FORKS=100 make deploy
```

### 3. Security Enhancement
```bash
# Optimize security settings
make optimize-security

# Setup Vault
make setup-vault
```

### 4. Code Quality Improvement
```bash
# Syntax validation
make validate

# Code quality check
yamllint playbooks/
ansible-lint playbooks/
```

## Monitoring and Maintenance

### Regular Cleanup
```bash
# Weekly cleanup
make clean

# Monthly deep cleanup
make clean-all
```

### Backup Management
```bash
# Automated backup
make backup BACKUP_TYPE=scheduled

# Backup restoration
make restore BACKUP_TIMESTAMP=20231201-120000
```

## Troubleshooting

### Common Issues
1. **Duplicate file errors**: Run `make deduplicate`
2. **Performance issues**: Adjust `PARALLEL_FORKS` value
3. **Security issues**: Run `make optimize-security`
4. **Syntax errors**: Run `make validate`

### Log Checking
```bash
# View logs
make logs

# Specific node logs
ansible mitum_nodes[0] -m shell -a "tail -f /var/log/mitum/mitum.log"
```
EOF

    log_info "Documentation generated"
}

# Final validation
final_validation() {
    log_step "Final validation..."
    
    # Check required files
    REQUIRED_FILES=("ansible.cfg" "Makefile" "requirements.txt")
    for file in "${REQUIRED_FILES[@]}"; do
        if [ ! -f "$file" ]; then
            log_error "Required file missing: $file"
            return 1
        fi
    done
    
    # Check directory structure
    REQUIRED_DIRS=("playbooks" "roles" "inventories" "keys" "scripts")
    for dir in "${REQUIRED_DIRS[@]}"; do
        if [ ! -d "$dir" ]; then
            log_warn "Recommended directory missing: $dir"
        fi
    done
    
    # Check for duplicate files
    if [ -d "core-files" ]; then
        log_warn "core-files directory still exists"
    fi
    
    # Check .DS_Store files
    if [[ "$OS_TYPE" == "macOS" ]]; then
        DS_STORE_COUNT=$(find . -name ".DS_Store" -type f 2>/dev/null | wc -l | tr -d ' ')
        if [ "$DS_STORE_COUNT" -gt 0 ]; then
            log_warn "$DS_STORE_COUNT .DS_Store files remain"
        fi
    fi
    
    log_info "Final validation completed"
}

# Show summary
show_summary() {
    log_header "Cleanup and optimization completed!"
    
    echo ""
    echo "=== Cleanup Results ==="
    echo "✅ Duplicate files removed"
    echo "✅ Project structure optimized"
    echo "✅ Performance improved"
    echo "✅ Security enhanced"
    echo "✅ Code quality improved"
    echo "✅ Documentation generated"
    echo ""
    
    # Current directory size
    if command -v du >/dev/null 2>&1; then
        TOTAL_SIZE=$(du -sh . 2>/dev/null | cut -f1 || echo "Unknown")
        echo "📁 Current project size: $TOTAL_SIZE"
    fi
    
    # File count
    FILE_COUNT=$(find . -type f -not -path "./.git*" -not -path "./venv*" 2>/dev/null | wc -l | tr -d ' ')
    echo "📄 Total file count: $FILE_COUNT"
    
    # Directory count
    DIR_COUNT=$(find . -type d -not -path "./.git*" -not -path "./venv*" 2>/dev/null | wc -l | tr -d ' ')
    echo "📂 Total directory count: $DIR_COUNT"
    
    # Generated documentation
    echo ""
    echo "📚 Generated documentation:"
    echo "  - PROJECT_STRUCTURE.md"
    echo "  - OPTIMIZATION_GUIDE.md"
    
    # Next steps
    echo ""
    echo "🚀 Next steps:"
    echo "  1. make help - Check available commands"
    echo "  2. make setup - Initial setup"
    echo "  3. make test - Connectivity test"
    echo "  4. make deploy - Start deployment"
}

# macOS specific confirmation function
confirm_action() {
    echo ""
    echo "$1"
    echo "This script will perform the following tasks:"
    echo "1. Remove duplicate files"
    echo "2. Optimize project structure"
    echo "3. Improve performance"
    echo "4. Enhance security"
    echo "5. Improve code quality"
    echo "6. Generate documentation"
    echo "7. Final validation"
    echo ""
    echo "Continue? (y/N): "
    read -r REPLY
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Operation cancelled"
        exit 0
    fi
}

# Main execution function
main() {
    echo "🧹 Mitum Ansible Master Cleanup and Optimization Script"
    echo "================================================"
    echo "Running on: $OS_TYPE"
    echo ""
    
    # Check current directory
    if [ ! -f "ansible.cfg" ] && [ ! -f "Makefile" ]; then
        log_error "This script must be run from the mitum-ansible project root"
        exit 1
    fi
    
    # User confirmation with macOS compatibility
    confirm_action "🚨 IMPORTANT: This will modify your project files!"
    
    # Create backup
    create_backup
    
    # Execute cleanup and optimization tasks
    remove_duplicates
    optimize_structure
    improve_performance
    enhance_security
    improve_code_quality
    generate_documentation
    final_validation
    
    # Show summary
    show_summary
    
    log_success "Master cleanup and optimization completed!"
}

# Execute script
main "$@" 

================================================================================
파일: scripts/optimize-project.sh
================================================================================
#!/bin/bash

# Mitum Ansible Project Optimization Script
# Version: 1.0.0
#
# This script performs the following tasks:
# 1. Project structure optimization
# 2. Duplicate code removal
# 3. Performance improvement
# 4. Security enhancement

set -e

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Log functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
}

# Project structure optimization
optimize_structure() {
    log_step "Optimizing project structure..."
    
    # Create standard directory structure
    mkdir -p {logs,tmp,cache,backups}
    
    # Improve environment-specific directory structure
    for env in development staging production; do
        if [ -d "inventories/$env" ]; then
            mkdir -p "inventories/$env/{group_vars,host_vars,ssh_keys}"
        fi
    done
    
    log_info "Directory structure has been optimized"
}

# Remove duplicate code
remove_duplicates() {
    log_step "Removing duplicate code..."
    
    # Remove core-files directory if it exists (duplicate of root)
    if [ -d "core-files" ]; then
        log_info "Removing core-files directory (duplicate of root)..."
        rm -rf core-files
    fi
    
    # Remove .DS_Store files
    find . -name ".DS_Store" -type f -delete 2>/dev/null || true
    
    log_info "Duplicate code has been removed"
}

# Performance improvement
improve_performance() {
    log_step "Improving performance..."
    
    # Optimize Ansible configuration
    if [ -f "ansible.cfg" ]; then
        # Improve cache settings
        if ! grep -q "fact_caching = jsonfile" ansible.cfg; then
            echo "" >> ansible.cfg
            echo "[defaults]" >> ansible.cfg
            echo "fact_caching = jsonfile" >> ansible.cfg
            echo "fact_caching_connection = .ansible_cache" >> ansible.cfg
            echo "fact_caching_timeout = 86400" >> ansible.cfg
        fi
        
        # Improve parallel processing
        if ! grep -q "forks = 50" ansible.cfg; then
            sed -i.bak 's/forks = [0-9]*/forks = 50/' ansible.cfg
        fi
    fi
    
    log_info "Performance has been improved"
}

# Security enhancement
enhance_security() {
    log_step "Enhancing security..."
    
    # Set SSH key permissions
    find keys/ -name "*.pem" -exec chmod 600 {} \; 2>/dev/null || true
    find keys/ -name "*.key" -exec chmod 600 {} \; 2>/dev/null || true
    
    # Create Vault file if it doesn't exist
    if [ ! -f ".vault_pass" ]; then
        log_info "Creating Ansible Vault password file..."
        echo "mitum-vault-$(date +%s)" > .vault_pass
        chmod 600 .vault_pass
    fi
    
    # Update .gitignore
    if [ -f ".gitignore" ]; then
        # Add security-related files
        for pattern in ".vault_pass" "*.pem" "*.key" "secrets/" "vault*.yml"; do
            if ! grep -q "$pattern" .gitignore; then
                echo "$pattern" >> .gitignore
            fi
        done
    fi
    
    log_info "Security has been enhanced"
}

# Code quality improvement
improve_code_quality() {
    log_step "Improving code quality..."
    
    # Validate YAML files
    find . -name "*.yml" -type f | while read -r file; do
        if command -v yamllint >/dev/null 2>&1; then
            yamllint "$file" >/dev/null 2>&1 || log_warn "YAML syntax error: $file"
        fi
    done
    
    # Validate Ansible syntax
    if command -v ansible-playbook >/dev/null 2>&1; then
        find playbooks/ -name "*.yml" -type f | while read -r playbook; do
            ansible-playbook --syntax-check "$playbook" >/dev/null 2>&1 || log_warn "Ansible syntax error: $playbook"
        done
    fi
    
    log_info "Code quality has been improved"
}

# Generate documentation
generate_documentation() {
    log_step "Generating documentation..."
    
    # Project structure documentation
    cat > PROJECT_STRUCTURE.md << 'EOF'
# Mitum Ansible Project Structure

## Directory Structure

```
mitum-ansible/
├── ansible.cfg              # Ansible configuration file
├── Makefile                 # Build and deployment commands
├── requirements.txt         # Python dependencies
├── README.md               # Project documentation
├── .gitignore              # Git exclude file
├── .vault_pass             # Ansible Vault password
├── playbooks/              # Ansible playbooks
│   ├── site.yml           # Main deployment playbook
│   ├── deploy-mitum.yml   # Mitum deployment
│   ├── backup.yml         # Backup
│   └── ...
├── roles/                  # Ansible roles
│   └── mitum/             # Mitum node role
├── inventories/            # Inventory
│   ├── development/       # Development environment
│   ├── staging/          # Staging environment
│   └── production/       # Production environment
├── keys/                  # SSH keys and Mitum keys
├── logs/                  # Log files
├── scripts/               # Utility scripts
└── tools/                 # Tools and scripts
```

## Key File Descriptions

- `ansible.cfg`: Ansible configuration (security, performance optimization)
- `Makefile`: Deployment and management commands
- `playbooks/`: Ansible playbook collection
- `roles/mitum/`: Mitum node configuration role
- `inventories/`: Environment-specific host and variable definitions
- `keys/`: SSH key and Mitum key storage
EOF

    log_info "Documentation has been generated"
}

# Main execution function
main() {
    echo "🚀 Mitum Ansible Project Optimization Script"
    echo "============================================"
    echo ""
    
    # Check current directory
    if [ ! -f "ansible.cfg" ] && [ ! -f "Makefile" ]; then
        log_error "This script must be run from the mitum-ansible project root"
        exit 1
    fi
    
    # User confirmation
    echo "This script will perform the following tasks:"
    echo "1. Project structure optimization"
    echo "2. Duplicate code removal"
    echo "3. Performance improvement"
    echo "4. Security enhancement"
    echo "5. Code quality improvement"
    echo "6. Documentation generation"
    echo ""
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Operation cancelled"
        exit 0
    fi
    
    # Execute optimization tasks
    remove_duplicates
    optimize_structure
    improve_performance
    enhance_security
    improve_code_quality
    generate_documentation
    
    log_info "Project optimization completed!"
    echo ""
    echo "=== Optimization Results ==="
    echo "✅ Duplicate code removed"
    echo "✅ Project structure optimized"
    echo "✅ Performance improved"
    echo "✅ Security enhanced"
    echo "✅ Code quality improved"
    echo "✅ Documentation generated"
}

# Execute script
main "$@" 

================================================================================
파일: scripts/setup.sh
================================================================================
#!/bin/bash
# setup.sh - Mitum Ansible initial setup script with MitumJS support
# Version: 2.2.0 - macOS support added

set -euo pipefail

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"

# OS detection - macOS support added
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        OS="darwin"
        VER=$(sw_vers -productVersion)
    elif [[ -f /etc/os-release ]]; then
        . /etc/os-release
        OS=$ID
        VER=$VERSION_ID
    else
        echo -e "${RED}Unsupported OS.${NC}"
        exit 1
    fi
}

detect_os

echo -e "${GREEN}Starting Mitum Ansible setup with MitumJS${NC}"
echo "OS: $OS $VER"
echo ""

# Install Python and pip
install_python() {
    echo -e "${YELLOW}>>> Installing Python...${NC}"
    
    case "$OS" in
        ubuntu|debian)
            sudo apt-get update
            sudo apt-get install -y python3 python3-pip python3-venv
            ;;
        centos|rhel|fedora)
            sudo yum install -y python3 python3-pip
            ;;
        darwin)
            if ! command -v brew &> /dev/null; then
                echo -e "${RED}Homebrew is required. Install from https://brew.sh${NC}"
                exit 1
            fi
            brew install python3
            ;;
        *)
            echo -e "${RED}Unsupported OS: $OS${NC}"
            exit 1
            ;;
    esac
}

# Install Node.js for MitumJS
install_nodejs() {
    echo -e "${YELLOW}>>> Installing Node.js for MitumJS...${NC}"
    
    if command -v node &> /dev/null; then
        NODE_VERSION=$(node --version | grep -oE '[0-9]+' | head -1)
        if [[ $NODE_VERSION -ge 14 ]]; then
            echo -e "${GREEN}✓ Node.js already installed ($(node --version))${NC}"
            return
        fi
    fi
    
    case "$OS" in
        ubuntu|debian)
            curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
            sudo apt-get install -y nodejs
            ;;
        centos|rhel|fedora)
            curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo bash -
            sudo yum install -y nodejs
            ;;
        darwin)
            brew install node
            ;;
    esac
    
    echo -e "${GREEN}✓ Node.js installation complete: $(node --version)${NC}"
}

# Install Ansible
install_ansible() {
    echo -e "${YELLOW}>>> Installing Ansible...${NC}"
    
    # Create virtual environment
    if [[ ! -d venv ]]; then
        python3 -m venv venv
    fi
    
    # Activate virtual environment
    source venv/bin/activate
    
    # Upgrade pip
    pip install --upgrade pip
    
    # Install Ansible and dependencies
    pip install ansible ansible-lint jmespath netaddr
    
    echo -e "${GREEN}✓ Ansible installation complete${NC}"
    ansible --version
}

# Install additional tools
install_tools() {
    echo -e "${YELLOW}>>> Installing additional tools...${NC}"
    
    case "$OS" in
        ubuntu|debian)
            sudo apt-get install -y jq git curl sshpass make
            ;;
        centos|rhel|fedora)
            sudo yum install -y jq git curl sshpass make
            ;;
        darwin)
            # sshpass is not available on macOS for security reasons
            for tool in jq git curl make; do
                if ! command -v $tool &> /dev/null; then
                    brew install $tool
                fi
            done
            echo -e "${YELLOW}Note: sshpass is not available on macOS. Please use SSH key authentication.${NC}"
            ;;
    esac
}

# Install MitumJS and related tools
install_mitumjs() {
    echo -e "${YELLOW}>>> Installing MitumJS SDK...${NC}"
    
    # Create tools directory
    mkdir -p "${ROOT_DIR}/tools/mitumjs"
    
    # Copy MitumJS files
    if [[ -f "${ROOT_DIR}/roles/mitum/files/package.json" ]]; then
        cp "${ROOT_DIR}/roles/mitum/files/package.json" "${ROOT_DIR}/tools/mitumjs/"
        cp "${ROOT_DIR}/roles/mitum/files/mitum-config.sh" "${ROOT_DIR}/tools/mitumjs/"
        cp "${ROOT_DIR}/roles/mitum/files/mitum-keygen.js" "${ROOT_DIR}/tools/mitumjs/"
        
        # Make scripts executable
        chmod +x "${ROOT_DIR}/tools/mitumjs/mitum-config.sh"
        
        # Install dependencies
        cd "${ROOT_DIR}/tools/mitumjs"
        npm install
        cd "${ROOT_DIR}"
        
        echo -e "${GREEN}✓ MitumJS SDK installed${NC}"
    else
        echo -e "${YELLOW}MitumJS files will be installed during role execution${NC}"
    fi
}

# Install Ansible Galaxy roles
install_galaxy_roles() {
    echo -e "${YELLOW}>>> Installing Ansible Galaxy roles...${NC}"
    
    # Create requirements.yml if not exists
    if [[ ! -f requirements.yml ]]; then
        cat > requirements.yml << 'EOF'
---
collections:
  - name: community.general
  - name: community.crypto
  - name: ansible.posix

roles: []
EOF
    fi
    
    ansible-galaxy install -r requirements.yml
    echo -e "${GREEN}✓ Galaxy roles installed${NC}"
}

# Create directory structure
create_structure() {
    echo -e "${YELLOW}>>> Creating directory structure...${NC}"
    
    # Main directories
    mkdir -p {logs,backups,artifacts,reports}
    mkdir -p inventories/{production,staging,development}/{group_vars,host_vars}
    mkdir -p playbooks
    mkdir -p roles/mitum/{tasks,handlers,templates,files,vars,defaults}
    mkdir -p tools/{mitumjs,scripts}
    
    # Create SSH keys directory structure
    mkdir -p keys/{ssh,mitum}/{production,staging,development}
    chmod 700 keys/ssh
    
    # Create .gitignore for keys directory
    cat > keys/.gitignore << 'EOF'
# Ignore all key files
*.pem
*.key
*.pub
id_*
*_rsa
*_dsa
*_ecdsa
*_ed25519

# But track README files
!README.md
!.gitignore
EOF
    
    # Create README for keys directory
    cat > keys/README.md << 'EOF'
# Keys Directory

This directory stores SSH keys and Mitum blockchain keys.

## Directory Structure

```
keys/
├── ssh/                    # SSH keys for server access
│   ├── production/        # Production environment keys
│   │   ├── bastion.pem   # Bastion host SSH key
│   │   └── nodes.pem     # Node SSH keys
│   ├── staging/          # Staging environment keys
│   └── development/      # Development environment keys
└── mitum/                 # Mitum blockchain keys (auto-generated)
    ├── production/       # Production blockchain keys
    ├── staging/         # Staging blockchain keys
    └── development/     # Development blockchain keys
```

## Adding SSH Keys

1. Copy your PEM files to the appropriate environment folder:
   ```bash
   cp ~/Downloads/my-aws-key.pem keys/ssh/production/bastion.pem
   chmod 600 keys/ssh/production/bastion.pem
   ```

2. The inventory generator will automatically look for keys in:
   - `keys/ssh/{environment}/bastion.pem`
   - `keys/ssh/{environment}/nodes.pem`

## Security Notes

- All key files are ignored by git (see .gitignore)
- Keep permissions at 600 for all key files
- Never commit keys to version control
- Use different keys for each environment
EOF
    
    # Create example inventory
    if [[ ! -f inventories/development/hosts.yml ]]; then
        cat > inventories/development/hosts.yml << 'EOF'
---
all:
  children:
    mitum_nodes:
      hosts:
        node0:
          ansible_host: 127.0.0.1
          ansible_port: 2222
          mitum_node_id: 0
          mitum_node_port: 4320
          mitum_api_enabled: true
          mitum_api_port: 54320
        node1:
          ansible_host: 127.0.0.1
          ansible_port: 2223
          mitum_node_id: 1
          mitum_node_port: 4321
          mitum_api_enabled: false
      vars:
        ansible_user: vagrant
        ansible_ssh_private_key_file: ~/.vagrant.d/insecure_private_key
        mitum_network_id: "mitum-dev"
        mitum_keygen_strategy: "centralized"
        mitum_mongodb_install_method: "docker"
EOF
        echo -e "${GREEN}✓ Development inventory created${NC}"
    fi
    
    # Create group_vars/all.yml
    if [[ ! -f inventories/development/group_vars/all.yml ]]; then
        cat > inventories/development/group_vars/all.yml << 'EOF'
---
# Mitum configuration
mitum_version: "latest"
mitum_model_type: "mitum-currency"
mitum_install_method: "source"

# Key generation
mitum_keygen_strategy: "centralized"
mitum_nodejs_version: "18"
mitum_mitumjs_version: "^2.1.15"

# Paths
mitum_install_dir: "/opt/mitum"
mitum_data_dir: "/opt/mitum/data"
mitum_config_dir: "/opt/mitum/config"
mitum_keys_dir: "/opt/mitum/keys"
mitum_log_dir: "/var/log/mitum"

# MongoDB
mitum_mongodb_version: "7.0"
mitum_mongodb_install_method: "native"
mitum_mongodb_replica_set: "mitum"

# Service
mitum_service_name: "mitum"
mitum_service_user: "mitum"
mitum_service_group: "mitum"

# Monitoring
mitum_monitoring:
  enabled: false
  prometheus_enabled: false
EOF
        echo -e "${GREEN}✓ Default variables created${NC}"
    fi
}

# Setup SSH
setup_ssh() {
    echo -e "${YELLOW}>>> Setting up SSH...${NC}"
    
    # Create SSH config file
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    
    if [[ ! -f ~/.ssh/config ]]; then
        touch ~/.ssh/config
        chmod 600 ~/.ssh/config
    fi
    
    # Add StrictHostKeyChecking setting (for development)
    if ! grep -q "StrictHostKeyChecking" ~/.ssh/config; then
        cat >> ~/.ssh/config << 'EOF'

# Mitum Ansible Development
Host 127.0.0.1 localhost
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOF
    fi
}

# Create configuration file
create_config() {
    echo -e "${YELLOW}>>> Creating configuration file...${NC}"
    
    if [[ ! -f .mitum-ansible.conf ]]; then
        cat > .mitum-ansible.conf << 'EOF'
# Mitum Ansible Configuration
# This file is used by mitum.sh script

# Default inventory
DEFAULT_INVENTORY="inventories/production"

# Default Mitum version
DEFAULT_VERSION="latest"

# Key generation settings
KEYGEN_STRATEGY="centralized"
MITUMJS_VERSION="^2.1.15"

# SSH Keys location
SSH_KEYS_DIR="keys/ssh"
MITUM_KEYS_DIR="keys/mitum"

# Ansible options
ANSIBLE_OPTS=""

# Log settings
LOG_LEVEL="info"
LOG_DIR="logs"

# Backup settings
BACKUP_DIR="backups"
BACKUP_RETENTION_DAYS=7

# MongoDB settings
MONGODB_VERSION="7.0"
MONGODB_INSTALL_METHOD="native"

# AWX settings (optional)
#AWX_URL="http://awx.example.com"
#AWX_TOKEN="your-token-here"

# Prometheus settings (optional)
#PROMETHEUS_URL="http://prometheus.example.com:9090"

# MitumJS tool location
MITUMJS_TOOL_DIR="tools/mitumjs"
EOF
        echo -e "${GREEN}✓ Configuration file created${NC}"
    fi
}

# Create ansible.cfg
create_ansible_cfg() {
    echo -e "${YELLOW}>>> Creating ansible.cfg...${NC}"
    
    if [[ ! -f ansible.cfg ]]; then
        cat > ansible.cfg << 'EOF'
[defaults]
inventory = inventories/production/hosts.yml
roles_path = roles
host_key_checking = False
retry_files_enabled = False
gathering = smart
fact_caching = jsonfile
fact_caching_connection = .ansible_cache
fact_caching_timeout = 86400
stdout_callback = yaml
callback_whitelist = profile_tasks, timer
interpreter_python = auto_silent

[inventory]
enable_plugins = host_list, yaml, ini, auto

[ssh_connection]
pipelining = True
control_path = /tmp/ansible-ssh-%%h-%%p-%%r
ssh_args = -o ControlMaster=auto -o ControlPersist=60s

[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False
EOF
        echo -e "${GREEN}✓ ansible.cfg created${NC}"
    fi
}

# Create example playbooks
create_example_playbooks() {
    echo -e "${YELLOW}>>> Creating example playbooks...${NC}"
    
    # Test playbook
    if [[ ! -f playbooks/test.yml ]]; then
        cat > playbooks/test.yml << 'EOF'
---
- name: Test connectivity and setup
  hosts: mitum_nodes
  gather_facts: yes
  tasks:
    - name: Test connection
      ping:
    
    - name: Show system info
      debug:
        msg: |
          Hostname: {{ ansible_hostname }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          CPU: {{ ansible_processor_vcpus }} cores
          Memory: {{ ansible_memtotal_mb }} MB
    
    - name: Check required tools
      command: "{{ item }} --version"
      loop:
        - python3
        - node
        - jq
      register: tool_versions
      changed_when: false
      failed_when: false
    
    - name: Display tool versions
      debug:
        msg: "{{ item.item }}: {{ item.stdout_lines[0] | default('Not installed') }}"
      loop: "{{ tool_versions.results }}"
EOF
    fi
    
    # Site playbook
    if [[ ! -f playbooks/site.yml ]]; then
        cat > playbooks/site.yml << 'EOF'
---
# Main site playbook - includes all components
- import_playbook: deploy-mitum.yml
EOF
    fi
}

# Create helper script for key management - macOS compatible version
create_key_helper() {
    echo -e "${YELLOW}>>> Creating key management helper...${NC}"
    
    mkdir -p scripts
    
    cat > scripts/manage-keys.sh << 'EOF'
#!/bin/bash
# Key management helper script - macOS compatible version

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
KEYS_DIR="$ROOT_DIR/keys"

# OS detection
if [[ "$OSTYPE" == "darwin"* ]]; then
    IS_MACOS=true
else
    IS_MACOS=false
fi

usage() {
    cat << USAGE
${GREEN}SSH Key Management Helper${NC}

Usage: $0 [COMMAND] [OPTIONS]

Commands:
    add     Add SSH key to project
    list    List all SSH keys
    check   Check key permissions
    fix     Fix key permissions

Examples:
    $0 add production ~/Downloads/my-aws-key.pem
    $0 list
    $0 check
    $0 fix

USAGE
}

add_key() {
    local env=$1
    local source=$2
    local name=${3:-}
    
    if [[ ! -f "$source" ]]; then
        echo -e "${RED}Error: Key file not found: $source${NC}"
        exit 1
    fi
    
    # Determine target name
    if [[ -z "$name" ]]; then
        name=$(basename "$source")
    fi
    
    # Create directory if needed
    mkdir -p "$KEYS_DIR/ssh/$env"
    
    # Copy key
    cp "$source" "$KEYS_DIR/ssh/$env/$name"
    chmod 600 "$KEYS_DIR/ssh/$env/$name"
    
    echo -e "${GREEN}✓ Key added: $KEYS_DIR/ssh/$env/$name${NC}"
}

list_keys() {
    echo -e "${YELLOW}SSH Keys in project:${NC}"
    echo ""
    
    for env in production staging development; do
        echo "[$env]"
        if [[ -d "$KEYS_DIR/ssh/$env" ]]; then
            for key in "$KEYS_DIR/ssh/$env"/*.pem "$KEYS_DIR/ssh/$env"/*.key 2>/dev/null; do
                if [[ -f "$key" ]]; then
                    if [[ "$IS_MACOS" == "true" ]]; then
                        local perms=$(stat -f %Lp "$key")
                    else
                        local perms=$(stat -c %a "$key")
                    fi
                    echo "  $(basename "$key") (permissions: $perms)"
                fi
            done
        else
            echo "  (no keys)"
        fi
        echo ""
    done
}

check_permissions() {
    local errors=0
    
    echo -e "${YELLOW}Checking key permissions...${NC}"
    
    find "$KEYS_DIR/ssh" -type f \( -name "*.pem" -o -name "*.key" \) -print0 | while IFS= read -r -d '' key; do
        if [[ "$IS_MACOS" == "true" ]]; then
            local perms=$(stat -f %Lp "$key")
        else
            local perms=$(stat -c %a "$key")
        fi
        
        if [[ "$perms" != "600" ]]; then
            echo -e "${RED}✗ Wrong permissions ($perms): $key${NC}"
            ((errors++))
        else
            echo -e "${GREEN}✓ OK: $key${NC}"
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        echo -e "\n${GREEN}All keys have correct permissions!${NC}"
    else
        echo -e "\n${RED}Found $errors keys with wrong permissions${NC}"
        echo "Run '$0 fix' to fix permissions"
    fi
}

fix_permissions() {
    echo -e "${YELLOW}Fixing key permissions...${NC}"
    
    find "$KEYS_DIR/ssh" -type f \( -name "*.pem" -o -name "*.key" \) -exec chmod 600 {} \;
    
    echo -e "${GREEN}✓ All key permissions fixed${NC}"
}

# Main
case "${1:-help}" in
    add)
        if [[ $# -lt 3 ]]; then
            echo -e "${RED}Error: Missing arguments${NC}"
            echo "Usage: $0 add <environment> <source-key-file> [target-name]"
            exit 1
        fi
        add_key "$2" "$3" "${4:-}"
        ;;
    list)
        list_keys
        ;;
    check)
        check_permissions
        ;;
    fix)
        fix_permissions
        ;;
    *)
        usage
        ;;
esac
EOF
    
    chmod +x scripts/manage-keys.sh
    echo -e "${GREEN}✓ Key management helper created${NC}"
}

# Verify installation
verify_installation() {
    echo -e "${YELLOW}>>> Verifying installation...${NC}"
    
    local errors=0
    
    # Check commands
    for cmd in python3 ansible ansible-playbook jq node npm; do
        if command -v "$cmd" &> /dev/null; then
            echo -e "${GREEN}✓${NC} $cmd installed"
        else
            echo -e "${RED}✗${NC} $cmd not installed"
            ((errors++))
        fi
    done
    
    # Check directories
    for dir in logs backups inventories playbooks roles tools keys/ssh keys/mitum; do
        if [[ -d "$dir" ]]; then
            echo -e "${GREEN}✓${NC} $dir directory exists"
        else
            echo -e "${RED}✗${NC} $dir directory missing"
            ((errors++))
        fi
    done
    
    # Check MitumJS
    if [[ -d "tools/mitumjs/node_modules" ]]; then
        echo -e "${GREEN}✓${NC} MitumJS SDK installed"
    else
        echo -e "${YELLOW}!${NC} MitumJS SDK not yet installed (will install during deployment)"
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo -e "\n${GREEN}✓ All setup complete!${NC}"
        echo -e "\nQuick start commands:"
        echo -e "  ${BLUE}source venv/bin/activate${NC}    # Activate Python environment"
        echo -e "  ${BLUE}./scripts/manage-keys.sh${NC}    # Manage SSH keys"
        echo -e "  ${BLUE}make test${NC}                   # Test connectivity"
        echo -e "  ${BLUE}make keygen${NC}                 # Generate keys"
        echo -e "  ${BLUE}make deploy${NC}                 # Deploy nodes"
        echo -e "  ${BLUE}make help${NC}                   # Show all commands"
        echo -e "\n${PURPLE}SSH Key Setup:${NC}"
        echo -e "  1. Copy your SSH keys to: ${YELLOW}keys/ssh/<environment>/${NC}"
        echo -e "  2. Example: ${BLUE}cp ~/my-key.pem keys/ssh/production/bastion.pem${NC}"
        echo -e "  3. Fix permissions: ${BLUE}./scripts/manage-keys.sh fix${NC}"
    else
        echo -e "\n${RED}✗ Some components missing.${NC}"
        exit 1
    fi
}

# Main execution
main() {
    echo -e "${GREEN}=== Mitum Ansible Setup with MitumJS ===${NC}\n"
    
    # Check and install Python
    if ! command -v python3 &> /dev/null; then
        install_python
    else
        echo -e "${GREEN}✓ Python already installed${NC}"
    fi
    
    # Install Node.js for MitumJS
    install_nodejs
    
    # Install Ansible
    install_ansible
    
    # Install additional tools
    install_tools
    
    # Install MitumJS
    install_mitumjs
    
    # Install Galaxy roles
    install_galaxy_roles
    
    # Create directory structure
    create_structure
    
    # Setup SSH
    setup_ssh
    
    # Create configuration files
    create_config
    create_ansible_cfg
    
    # Create example playbooks
    create_example_playbooks
    
    # Create key management helper
    create_key_helper
    
    # Verify installation
    verify_installation
    
    echo -e "\n${GREEN}=== Setup Complete! ===${NC}"
    echo -e "\n${PURPLE}Next steps:${NC}"
    echo -e "1. Add SSH keys: ${BLUE}./scripts/manage-keys.sh add production ~/your-key.pem${NC}"
    echo -e "2. Edit inventory file: ${BLUE}inventories/production/hosts.yml${NC}"
    echo -e "3. Configure variables: ${BLUE}inventories/production/group_vars/all.yml${NC}"
    echo -e "4. Test connection: ${BLUE}make test${NC}"
    echo -e "5. Generate keys: ${BLUE}make keygen${NC}"
    echo -e "6. Deploy Mitum: ${BLUE}make deploy${NC}"
}

# Execute
main

================================================================================
파일: scripts/ssh-pool.sh
================================================================================
#!/bin/bash
# SSH connection pool manager for Mitum Ansible

set -euo pipefail

SOCKET_DIR="/tmp/ansible-ssh-sockets"
INVENTORY="${INVENTORY:-inventories/production/hosts.yml}"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Functions
log() { echo -e "${GREEN}[INFO]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
warning() { echo -e "${YELLOW}[WARN]${NC} $*"; }

# Get hosts from inventory
get_hosts() {
    if [[ ! -f "$INVENTORY" ]]; then
        error "Inventory file not found: $INVENTORY"
        exit 1
    fi
    
    # Extract hostnames from inventory
    grep -E "^[[:space:]]*node[0-9]+:" "$INVENTORY" | sed 's/://g' | tr -d ' '
}

case "${1:-help}" in
    start)
        log "Starting SSH connection pool..."
        mkdir -p "$SOCKET_DIR"
        
        # Start bastion connection first
        log "Establishing bastion connection..."
        ssh -M -N -f -o ControlPath="$SOCKET_DIR/bastion.sock" \
            -o ControlPersist=1800s \
            -o ServerAliveInterval=60 \
            bastion 2>/dev/null || true
        
        # Start connections to all nodes
        HOSTS=$(get_hosts)
        for host in $HOSTS; do
            log "Establishing connection to $host..."
            ssh -M -N -f -o ControlPath="$SOCKET_DIR/$host.sock" \
                -o ControlPersist=1800s \
                -o ProxyJump=bastion \
                "$host" 2>/dev/null || true
        done
        log "Connection pool established."
        ;;
        
    stop)
        log "Stopping SSH connection pool..."
        if [[ -d "$SOCKET_DIR" ]]; then
            for sock in "$SOCKET_DIR"/*.sock; do
                if [[ -e "$sock" ]]; then
                    ssh -O exit -o ControlPath="$sock" localhost 2>/dev/null || true
                fi
            done
            rm -rf "$SOCKET_DIR"
        fi
        log "Connection pool stopped."
        ;;
        
    status)
        echo "SSH connection pool status:"
        if [[ -d "$SOCKET_DIR" ]]; then
            for sock in "$SOCKET_DIR"/*.sock; do
                if [[ -e "$sock" ]]; then
                    host=$(basename "$sock" .sock)
                    if ssh -O check -o ControlPath="$sock" localhost 2>/dev/null; then
                        echo -e "  $host: ${GREEN}Active${NC}"
                    else
                        echo -e "  $host: ${RED}Inactive${NC}"
                    fi
                fi
            done
        else
            warning "No connection pool found"
        fi
        ;;
        
    restart)
        $0 stop
        sleep 2
        $0 start
        ;;
        
    *)
        echo "Usage: $0 {start|stop|status|restart}"
        echo ""
        echo "Manages SSH connection multiplexing for faster Ansible operations."
        echo "Connections are maintained for 30 minutes (1800s)."
        exit 1
        ;;
esac

================================================================================
파일: scripts/start.sh
================================================================================
#!/bin/bash
# start.sh - Simple start script for Mitum deployment
# This script provides the easiest way to start Mitum deployment

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Detect script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

echo -e "${CYAN}"
echo "╔══════════════════════════════════════════╗"
echo "║     Welcome to Mitum Blockchain!         ║"
echo "║     Easy Deployment Tool v4.0.0          ║"
echo "╚══════════════════════════════════════════╝"
echo -e "${NC}"

echo -e "${GREEN}This script will help you deploy Mitum blockchain easily.${NC}"
echo ""

# Check if this is first run
if [[ ! -d "$SCRIPT_DIR/venv" ]]; then
    echo -e "${YELLOW}First time setup detected!${NC}"
    echo "Running initial setup..."
    echo ""
    
    if [[ -f "$SCRIPT_DIR/scripts/setup.sh" ]]; then
        bash "$SCRIPT_DIR/scripts/setup.sh"
    else
        echo "Please run: make setup"
        exit 1
    fi
fi

# Run interactive deployment
echo -e "${GREEN}Starting interactive deployment...${NC}"
echo ""

if [[ -f "$SCRIPT_DIR/scripts/deploy-mitum.sh" ]]; then
    bash "$SCRIPT_DIR/scripts/deploy-mitum.sh" --interactive
else
    echo "Error: deploy-mitum.sh not found!"
    exit 1
fi

================================================================================
파일: scripts/visual-status.sh
================================================================================
#!/bin/bash

# 🎨 Mitum Visual Status Display Script
# Displays node status visually for easy monitoring

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# 환경 변수
ENV=${ENV:-production}
INVENTORY="inventories/$ENV/hosts.yml"

# 아이콘 정의
ICON_OK="✅"
ICON_WARNING="⚠️ "
ICON_ERROR="❌"
ICON_RUNNING="🟢"
ICON_STOPPED="🔴"
ICON_UNKNOWN="🟡"

# 헤더 출력
print_header() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}🎯 Mitum 네트워크 상태 대시보드${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "📅 시간: $(date '+%Y-%m-%d %H:%M:%S')"
    echo -e "🌍 환경: ${GREEN}$ENV${NC}"
    echo
}

# 노드 상태 체크
check_node_status() {
    local node=$1
    local status_output=$(ansible $node -i $INVENTORY -m shell -a "systemctl is-active mitum || echo inactive" 2>/dev/null | tail -1)
    
    case $status_output in
        active)
            echo "$ICON_RUNNING"
            ;;
        inactive)
            echo "$ICON_STOPPED"
            ;;
        *)
            echo "$ICON_UNKNOWN"
            ;;
    esac
}

# 노드 정보 가져오기
get_node_info() {
    local node=$1
    
    # 블록 높이 가져오기
    local block_height=$(ansible $node -i $INVENTORY -m shell -a "curl -s http://localhost:54321/block/last | jq -r '.height' 2>/dev/null || echo 'N/A'" 2>/dev/null | tail -1)
    
    # 연결된 피어 수
    local peer_count=$(ansible $node -i $INVENTORY -m shell -a "curl -s http://localhost:54321/node | jq -r '.suffrage.nodes | length' 2>/dev/null || echo '0'" 2>/dev/null | tail -1)
    
    echo "$block_height|$peer_count"
}

# 메인 대시보드
show_dashboard() {
    print_header
    
    echo -e "${YELLOW}📊 노드 상태 요약${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # 테이블 헤더
    printf "%-15s %-10s %-15s %-10s %-15s\n" "노드명" "상태" "블록 높이" "피어 수" "타입"
    echo -e "${CYAN}─────────────────────────────────────────────────────────────────────${NC}"
    
    # 노드 정보 표시
    local nodes=$(ansible all -i $INVENTORY --list-hosts 2>/dev/null | grep -v "hosts" | sed 's/^ *//')
    local total_nodes=0
    local running_nodes=0
    
    for node in $nodes; do
        ((total_nodes++))
        
        # 노드 상태 체크
        local status=$(check_node_status $node)
        [[ "$status" == "$ICON_RUNNING" ]] && ((running_nodes++))
        
        # 노드 정보 가져오기
        local info=$(get_node_info $node)
        local block_height=$(echo $info | cut -d'|' -f1)
        local peer_count=$(echo $info | cut -d'|' -f2)
        
        # 노드 타입 결정
        local node_type="Consensus"
        if ansible $node -i $INVENTORY -m debug -a "var=mitum_api_enabled" 2>/dev/null | grep -q "true"; then
            node_type="API"
        fi
        
        # 출력
        printf "%-15s %-10s %-15s %-10s %-15s\n" \
            "$node" "$status" "$block_height" "$peer_count" "$node_type"
    done
    
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    
    # 요약 정보
    echo -e "${YELLOW}📈 네트워크 요약${NC}"
    echo "• 전체 노드: $total_nodes"
    echo "• 실행 중: ${GREEN}$running_nodes${NC}"
    echo "• 중지됨: ${RED}$((total_nodes - running_nodes))${NC}"
    
    # 상태에 따른 메시지
    echo
    if [ $running_nodes -eq $total_nodes ]; then
        echo -e "${GREEN}$ICON_OK 모든 노드가 정상적으로 실행 중입니다!${NC}"
    elif [ $running_nodes -eq 0 ]; then
        echo -e "${RED}$ICON_ERROR 실행 중인 노드가 없습니다!${NC}"
    else
        echo -e "${YELLOW}$ICON_WARNING 일부 노드가 중지되어 있습니다.${NC}"
    fi
    
    echo
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# 실시간 모니터링 모드
monitor_mode() {
    while true; do
        show_dashboard
        echo
        echo -e "${BLUE}🔄 5초 후 새로고침... (Ctrl+C로 종료)${NC}"
        sleep 5
    done
}

# 메인 실행
main() {
    if [ "$1" == "--monitor" ] || [ "$1" == "-m" ]; then
        monitor_mode
    else
        show_dashboard
        echo
        echo -e "${BLUE}💡 팁: 실시간 모니터링을 원하시면 '$0 --monitor'를 사용하세요.${NC}"
    fi
}

# 스크립트 실행
main "$@" 


================================================================================
## 📊 파트 2 통계

- 이 파트의 파일 수: 9개
- 이 파트의 라인 수: 3,544줄
- 이 파트의 크기: 103,018 bytes


================================================================================
## 📊 통계 정보

- 총 파일 수: 104개
- 총 라인 수: 19,349줄
- 출력 파일 크기: 490,490 bytes

### 파일 타입별 분포:
  - .yml: 57개
  - .sh: 14개
  - .md: 11개
  - .json: 11개
  - .txt: 3개
  - no_ext: 2개
  - .cfg: 2개
  - .py: 2개
  - .conf: 1개
  - .js: 1개
