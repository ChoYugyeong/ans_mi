# í”„ë¡œì íŠ¸ ì½”ë“œ í†µí•© íŒŒì¼ (íŒŒíŠ¸ 1/2)
# ìƒì„±ì¼ì‹œ: 2025-07-25 18:05:59
# í”„ë¡œì íŠ¸ ê²½ë¡œ: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible

## ðŸ“ ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
.gitlab-ci.yml
.mitum-ansible.conf
CLAUDE_IMPROVEMENT_PROMPTS.md
CLEANUP_README.md
IDENTIFIED_ISSUES.md
IMPROVEMENTS_SUMMARY.md
Makefile
PROJECT_STRUCTURE.md
QUICK_START.md
README.md
TROUBLESHOOTING.md
ansible.cfg
awx/
  README.md
  credentials/
    mitum_credentials.md
  inventories/
    dynamic_inventory.py
  surveys/
    deployment_survey.json
    upgrade_survey.json
  workflows/
    automated_recovery.json
    full_deployment.json
  core-files/
backup_20250725_145148/
    Makefile
    ansible.cfg
    backup.yml
    deploy-mitum.yml
    prepare-system.yml
    requirements.txt
    restore.yml
        tasks/
      mitum/
    roles/
          backup-node.yml
          configure-nodes.yml
          generate-configs.yml
          keygen-centralized.yml
          keygen.yml
          mongodb.yml
          service.yml
          system-prepare.yml
    rolling-upgrade.yml
    setup-monitoring.yml
    site.yml
    group_vars/
  development/
inventories/
      all.yml
    hosts.yml
    group_vars/
  production/
      all.yml
    hosts.yml
keys/
  README.md
  testnet/
    config-key.txt
    genesis-account.json
    keys-summary.json
    keys-summary.yml
    node-keys.json
    node0/
      node.json
    node1/
      node.json
    node2/
      node.json
merge_code.py
playbooks/
  awx-integration.yml
  backup.yml
  cleanup.yml
  configure-only.yml
  deploy-mitum.yml
  keygen-only.yml
  pre-deploy-check.yml
  prepare-system.yml
  recovery.yml
  restore.yml
  rolling-upgrade.yml
  setup-bastion.yml
  setup-monitoring-alerts.yml
  setup-monitoring.yml
  site.yml
  test.yml
  validate.yml
requirements.txt
    defaults/
  mitum/
roles/
      main.yml
    files/
      mitum-config.sh
      mitum-keygen.js
      package.json
    handlers/
      main.yml
    tasks/
      backup-node.yml
      common-package-install.yml
      common-validation.yml
      configure-nodes.yml
      generate-configs.yml
      install-mitumjs.yml
      install-nodejs.yml
      install.yml
      keygen-centralized.yml
      keygen-distribute.yml
      keygen.yml
      main.yml
      mongodb.yml
      monitoring-prometheus.yml
      service.yml
      system-prepare.yml
      validate.yml
scripts/
  add-key.sh
  autocomplete.sh
  deploy-mitum.sh
  generate-group-vars.sh
  generate-inventory.sh
  interactive-setup.sh
  manage-keys.sh
  master-cleanup.sh
  optimize-project.sh
  setup.sh
  ssh-pool.sh
  start.sh
  visual-status.sh
```

## ðŸ“„ íŒŒì¼ ë‚´ìš©

================================================================================
íŒŒì¼: .gitlab-ci.yml
================================================================================
stages:
  - validate
  - test
  - security
  - deploy
  - notify

variables:
  ANSIBLE_VERSION: "2.13"
  PYTHON_VERSION: "3.9"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  paths:
    - .cache/pip
    - venv/

before_script:
  - python3 -m venv venv
  - source venv/bin/activate
  - pip install --upgrade pip
  - pip install -r requirements.txt

# Validation Stage
ansible-lint:
  stage: validate
  script:
    - pip install ansible-lint
    - ansible-lint playbooks/*.yml
  only:
    - merge_requests
    - main
    - develop

yaml-lint:
  stage: validate
  script:
    - pip install yamllint
    - yamllint -c .yamllint .
  only:
    - merge_requests
    - main
    - develop

# Test Stage
syntax-check:
  stage: test
  script:
    - ansible-playbook playbooks/site.yml --syntax-check
    - ansible-playbook playbooks/deploy-mitum.yml --syntax-check
  only:
    - merge_requests
    - main
    - develop

molecule-test:
  stage: test
  services:
    - docker:dind
  script:
    - pip install molecule[docker] pytest-testinfra
    - cd roles/mitum
    - molecule test
  only:
    - merge_requests
    - main

# Security Stage
security-scan:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy fs --exit-code 1 --no-progress .
  only:
    - main
    - develop

vault-check:
  stage: security
  script:
    - |
      find . -name "*.vault" -o -name "*vault*" | while read file; do
        if file "$file" | grep -q "ASCII text"; then
          echo "ERROR: Unencrypted vault file found: $file"
          exit 1
        fi
      done
  only:
    - main
    - develop

# Deploy Stage
deploy-dev:
  stage: deploy
  script:
    - ansible-playbook -i inventories/development/hosts.yml playbooks/site.yml
  environment:
    name: development
    url: https://dev.mitum.example.com
  only:
    - develop
  when: manual

deploy-staging:
  stage: deploy
  script:
    - ansible-playbook -i inventories/staging/hosts.yml playbooks/site.yml
  environment:
    name: staging
    url: https://staging.mitum.example.com
  only:
    - main
  when: manual

deploy-prod:
  stage: deploy
  script:
    - ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml --check
    - ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml
  environment:
    name: production
    url: https://mitum.example.com
  only:
    - tags
  when: manual

# Notify Stage
slack-notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"Pipeline $CI_PIPELINE_STATUS for $CI_PROJECT_NAME - $CI_COMMIT_REF_NAME\"}" \
        $SLACK_WEBHOOK_URL
  when: always
  only:
    - main
    - develop 

================================================================================
íŒŒì¼: .mitum-ansible.conf
================================================================================
# Mitum Ansible Configuration
# This file is used by mitum.sh script

# Default inventory
DEFAULT_INVENTORY="inventories/production"

# Default Mitum version
DEFAULT_VERSION="latest"

# Key generation settings
KEYGEN_STRATEGY="centralized"
MITUMJS_VERSION="^2.1.15"

# SSH Keys location
SSH_KEYS_DIR="keys/ssh"
MITUM_KEYS_DIR="keys/mitum"

# Ansible options
ANSIBLE_OPTS=""

# Log settings
LOG_LEVEL="info"
LOG_DIR="logs"

# Backup settings
BACKUP_DIR="backups"
BACKUP_RETENTION_DAYS=7

# MongoDB settings
MONGODB_VERSION="7.0"
MONGODB_INSTALL_METHOD="native"

# AWX settings (optional)
#AWX_URL="http://awx.example.com"
#AWX_TOKEN="your-token-here"

# Prometheus settings (optional)
#PROMETHEUS_URL="http://prometheus.example.com:9090"

# MitumJS tool location
MITUMJS_TOOL_DIR="tools/mitumjs"

================================================================================
íŒŒì¼: CLAUDE_IMPROVEMENT_PROMPTS.md
================================================================================
# Claude Improvement Prompts for Mitum Ansible Project

This document contains comprehensive prompts for Claude to analyze and improve different aspects of the Mitum Ansible project.

---

## ðŸ” Project Analysis Prompt

```
Analyze this Mitum Ansible deployment project and provide a comprehensive report on:

1. **Architecture Assessment**
   - Evaluate the overall project structure and organization
   - Identify architectural strengths and weaknesses
   - Suggest improvements for scalability and maintainability

2. **Code Quality Analysis**
   - Review Ansible playbooks, roles, and tasks for best practices
   - Identify code duplication and suggest refactoring opportunities
   - Check for proper error handling and idempotency

3. **Security Evaluation**
   - Assess security implementations (Ansible Vault, SSH keys, firewall rules)
   - Identify potential security vulnerabilities
   - Suggest security hardening improvements

4. **Performance Optimization**
   - Analyze Ansible configuration for performance bottlenecks
   - Suggest optimizations for faster deployments
   - Review resource allocation and parallel processing

5. **Documentation Review**
   - Evaluate completeness and clarity of documentation
   - Identify missing documentation areas
   - Suggest improvements for user experience

Please provide specific, actionable recommendations with code examples where applicable.
```

---

## ðŸ—ï¸ Architecture Improvement Prompt

```
Review the Mitum Ansible project architecture and suggest improvements for:

1. **Modular Design**
   - Analyze current role and playbook organization
   - Suggest better separation of concerns
   - Recommend reusable component design patterns

2. **Scalability**
   - Evaluate support for large-scale deployments (100+ nodes)
   - Suggest improvements for multi-region deployments
   - Recommend horizontal scaling strategies

3. **Flexibility**
   - Assess support for different Mitum models and versions
   - Suggest improvements for configuration management
   - Recommend plugin architecture for extensibility

4. **Dependency Management**
   - Review external dependencies and version pinning
   - Suggest dependency isolation strategies
   - Recommend upgrade path management

5. **Environment Separation**
   - Evaluate current environment handling (dev/staging/prod)
   - Suggest improvements for environment-specific configurations
   - Recommend secrets management strategies

Provide detailed architectural diagrams and implementation plans.
```

---

## ðŸ”§ Code Quality Enhancement Prompt

```
Perform a comprehensive code review of the Mitum Ansible project focusing on:

1. **Ansible Best Practices**
   - Review playbook structure and organization
   - Check for proper use of handlers, tags, and conditionals
   - Evaluate variable precedence and naming conventions

2. **Error Handling**
   - Assess current error handling strategies
   - Suggest improvements for graceful failure handling
   - Recommend rollback mechanisms

3. **Idempotency**
   - Verify all tasks are idempotent
   - Identify tasks that may cause inconsistent states
   - Suggest improvements for state management

4. **Code Duplication**
   - Identify repeated code patterns across playbooks
   - Suggest refactoring opportunities
   - Recommend shared modules and includes

5. **Testing Strategy**
   - Evaluate current testing approach (if any)
   - Suggest comprehensive testing strategy
   - Recommend test automation improvements

6. **Documentation in Code**
   - Review inline documentation and comments
   - Suggest improvements for code readability
   - Recommend documentation standards

Provide specific code examples and refactoring suggestions.
```

---

## ðŸ›¡ï¸ Security Hardening Prompt

```
Conduct a security audit of the Mitum Ansible project and provide recommendations for:

1. **Secrets Management**
   - Review current Ansible Vault usage
   - Suggest improvements for key rotation
   - Recommend external secrets management integration

2. **Access Control**
   - Evaluate SSH key management and permissions
   - Suggest improvements for least privilege access
   - Recommend RBAC implementation

3. **Network Security**
   - Review firewall configurations and port management
   - Suggest network segmentation improvements
   - Recommend VPN/bastion host optimizations

4. **Encryption**
   - Assess data-in-transit and data-at-rest encryption
   - Suggest certificate management improvements
   - Recommend encryption key lifecycle management

5. **Audit and Compliance**
   - Evaluate logging and audit trail capabilities
   - Suggest compliance framework alignment
   - Recommend security monitoring improvements

6. **Vulnerability Management**
   - Review dependency scanning and update procedures
   - Suggest automated vulnerability detection
   - Recommend patch management strategies

Provide security implementation guidelines and compliance checklists.
```

---

## âš¡ Performance Optimization Prompt

```
Analyze the Mitum Ansible project for performance bottlenecks and suggest optimizations for:

1. **Deployment Speed**
   - Review current deployment times and identify slow tasks
   - Suggest parallelization improvements
   - Recommend caching strategies

2. **Resource Utilization**
   - Analyze CPU, memory, and network usage during deployments
   - Suggest resource allocation optimizations
   - Recommend infrastructure sizing guidelines

3. **Ansible Configuration**
   - Review ansible.cfg for performance settings
   - Suggest connection optimizations (SSH multiplexing, pipelining)
   - Recommend fact gathering optimizations

4. **Database Performance**
   - Evaluate MongoDB configuration and tuning
   - Suggest indexing and query optimization
   - Recommend replication performance improvements

5. **Monitoring Efficiency**
   - Review monitoring stack resource consumption
   - Suggest metric collection optimizations
   - Recommend alerting efficiency improvements

6. **Backup/Restore Performance**
   - Analyze backup and restore operation speeds
   - Suggest compression and incremental backup strategies
   - Recommend storage optimization techniques

Provide performance benchmarking plans and optimization roadmaps.
```

---

## ðŸ”„ DevOps Enhancement Prompt

```
Improve the DevOps practices in the Mitum Ansible project by addressing:

1. **CI/CD Pipeline Optimization**
   - Review current GitHub Actions and GitLab CI configurations
   - Suggest pipeline efficiency improvements
   - Recommend advanced deployment strategies (blue-green, canary)

2. **Testing Automation**
   - Design comprehensive testing strategy (unit, integration, e2e)
   - Suggest test automation framework implementation
   - Recommend test data management strategies

3. **Infrastructure as Code**
   - Evaluate current IaC practices
   - Suggest Terraform integration for infrastructure provisioning
   - Recommend cloud provider optimizations

4. **Monitoring and Observability**
   - Enhance monitoring stack with advanced features
   - Suggest distributed tracing implementation
   - Recommend SRE practices and SLIs/SLOs

5. **Deployment Strategies**
   - Improve rolling update mechanisms
   - Suggest disaster recovery automation
   - Recommend multi-region deployment strategies

6. **Developer Experience**
   - Enhance local development setup
   - Suggest developer tooling improvements
   - Recommend contribution workflow optimization

Provide implementation timelines and migration strategies.
```

---

## ðŸ“Š Monitoring Enhancement Prompt

```
Enhance the monitoring and observability capabilities of the Mitum Ansible project:

1. **Metrics Collection**
   - Expand Prometheus metrics collection
   - Suggest custom metrics for Mitum-specific monitoring
   - Recommend metrics aggregation and retention strategies

2. **Dashboard Improvements**
   - Design comprehensive Grafana dashboards
   - Suggest real-time alerting visualizations
   - Recommend user role-based dashboard access

3. **Alerting Strategy**
   - Improve AlertManager configuration
   - Suggest intelligent alert routing and escalation
   - Recommend alert fatigue reduction strategies

4. **Log Management**
   - Implement centralized logging with ELK stack
   - Suggest log parsing and analysis improvements
   - Recommend log retention and archival strategies

5. **Performance Monitoring**
   - Add application performance monitoring (APM)
   - Suggest database performance monitoring
   - Recommend infrastructure monitoring enhancements

6. **Incident Response**
   - Design automated incident response workflows
   - Suggest runbook automation
   - Recommend post-incident analysis improvements

Provide monitoring architecture diagrams and implementation guides.
```

---

## ðŸŒ Cloud Integration Prompt

```
Design cloud-native enhancements for the Mitum Ansible project:

1. **Multi-Cloud Support**
   - Add support for AWS, GCP, and Azure deployments
   - Suggest cloud-agnostic configuration management
   - Recommend cloud provider migration strategies

2. **Container Orchestration**
   - Design Kubernetes deployment manifests
   - Suggest Docker containerization improvements
   - Recommend service mesh integration

3. **Serverless Integration**
   - Identify serverless opportunities (AWS Lambda, Google Functions)
   - Suggest event-driven automation improvements
   - Recommend cost optimization strategies

4. **Cloud Storage**
   - Integrate cloud storage for backups and data
   - Suggest data lifecycle management
   - Recommend cross-region replication strategies

5. **Auto-scaling**
   - Design auto-scaling mechanisms for node clusters
   - Suggest load-based scaling triggers
   - Recommend cost-aware scaling strategies

6. **Cloud Security**
   - Implement cloud-native security services
   - Suggest identity and access management improvements
   - Recommend cloud compliance frameworks

Provide cloud architecture diagrams and migration roadmaps.
```

---

## ðŸ§ª Testing Strategy Prompt

```
Design a comprehensive testing strategy for the Mitum Ansible project:

1. **Test Pyramid Implementation**
   - Design unit tests for Ansible roles and tasks
   - Suggest integration testing strategies
   - Recommend end-to-end testing approaches

2. **Molecule Testing**
   - Implement Molecule scenarios for role testing
   - Suggest test matrix for different OS and configurations
   - Recommend test data and fixture management

3. **Infrastructure Testing**
   - Design infrastructure validation tests
   - Suggest chaos engineering practices
   - Recommend disaster recovery testing

4. **Performance Testing**
   - Implement deployment performance benchmarks
   - Suggest load testing for deployed networks
   - Recommend performance regression testing

5. **Security Testing**
   - Design security validation tests
   - Suggest vulnerability scanning automation
   - Recommend penetration testing integration

6. **Test Automation**
   - Implement automated test execution in CI/CD
   - Suggest test result reporting and analysis
   - Recommend test maintenance strategies

Provide test implementation examples and automation frameworks.
```

---

## ðŸ“š Documentation Enhancement Prompt

```
Improve the documentation ecosystem of the Mitum Ansible project:

1. **User Documentation**
   - Enhance getting started guides with video tutorials
   - Suggest interactive documentation with examples
   - Recommend troubleshooting knowledge base

2. **Developer Documentation**
   - Create comprehensive API documentation
   - Suggest code contribution guidelines
   - Recommend development environment setup guides

3. **Operations Documentation**
   - Design operational runbooks and procedures
   - Suggest incident response documentation
   - Recommend maintenance and upgrade guides

4. **Architecture Documentation**
   - Create detailed architecture decision records (ADRs)
   - Suggest system design documentation
   - Recommend dependency and integration maps

5. **Documentation Automation**
   - Implement automated documentation generation
   - Suggest documentation testing and validation
   - Recommend documentation versioning strategies

6. **Community Documentation**
   - Design community contribution guides
   - Suggest FAQ and common issues documentation
   - Recommend user feedback collection systems

Provide documentation templates and automation tools.
```

---

## ðŸ”§ Maintenance and Lifecycle Prompt

```
Design maintenance and lifecycle management improvements for the Mitum Ansible project:

1. **Dependency Management**
   - Implement automated dependency updates
   - Suggest vulnerability scanning for dependencies
   - Recommend dependency pinning and testing strategies

2. **Version Management**
   - Design semantic versioning strategy
   - Suggest release management automation
   - Recommend backward compatibility guidelines

3. **Maintenance Automation**
   - Implement automated maintenance tasks
   - Suggest health check and self-healing mechanisms
   - Recommend proactive maintenance scheduling

4. **Upgrade Strategies**
   - Design zero-downtime upgrade procedures
   - Suggest feature flag management
   - Recommend rollback and recovery strategies

5. **EOL and Migration**
   - Design end-of-life management procedures
   - Suggest migration path planning
   - Recommend legacy system handling

6. **Support and Community**
   - Design community support systems
   - Suggest user feedback collection and processing
   - Recommend community contribution facilitation

Provide maintenance schedules and lifecycle management plans.
```

---

## Usage Instructions

1. **Select the appropriate prompt** based on the specific area you want to improve
2. **Provide the prompt to Claude** along with relevant project files
3. **Review the recommendations** and prioritize based on your project needs
4. **Implement improvements incrementally** with proper testing
5. **Document changes** and update these prompts as needed

## Notes

- These prompts can be combined for comprehensive analysis
- Customize prompts based on specific project requirements
- Use prompts iteratively for continuous improvement
- Share results with the development team for collaborative enhancement 

================================================================================
íŒŒì¼: CLEANUP_README.md
================================================================================
# Mitum Ansible Cleanup and Optimization Guide

## ðŸ“‹ Overview

This project provides scripts to remove duplicate code and optimize performance in the Mitum Ansible codebase.

## ðŸ” Identified Issues

### 1. Duplicate Files
- `ansible.cfg` â†” `core-files/ansible.cfg` (completely identical)
- `Makefile` â†” `core-files/Makefile` (completely identical)
- `requirements.txt` â†” `core-files/requirements.txt` (completely identical)
- All playbook files duplicated
- All role task files duplicated

### 2. Unnecessary Files
- `.DS_Store` files (macOS system files)
- `core-files/` directory entire (completely duplicate of root)

### 3. Structural Issues
- Complex directory structure
- Lack of performance optimization
- Insufficient security settings

## ðŸ› ï¸ Provided Scripts

### 1. `cleanup-duplicates.sh` - Duplicate File Cleanup
```bash
# Grant execution permission
chmod +x cleanup-duplicates.sh

# Execute
./cleanup-duplicates.sh
```

**Features:**
- Remove .DS_Store files
- Remove core-files directory (duplicate elimination)
- Check and clean duplicate files
- Optimize directory structure

### 2. `scripts/optimize-project.sh` - Project Optimization
```bash
# Grant execution permission
chmod +x scripts/optimize-project.sh

# Execute
./scripts/optimize-project.sh
```

**Features:**
- Project structure optimization
- Duplicate code removal
- Performance improvement
- Security enhancement
- Code quality improvement
- Documentation generation

### 3. `scripts/master-cleanup.sh` - Master Cleanup Script
```bash
# Grant execution permission
chmod +x scripts/master-cleanup.sh

# Execute
./scripts/master-cleanup.sh
```

**Features:**
- Execute all cleanup tasks integrated
- Create backup
- Remove duplicate files
- Optimize project structure
- Improve performance
- Enhance security
- Improve code quality
- Generate documentation
- Final validation

## ðŸ“ Improved Files

### 1. `Makefile.optimized` - Optimized Makefile
```bash
# Backup existing Makefile
cp Makefile Makefile.backup

# Apply new Makefile
cp Makefile.optimized Makefile
```

**Key Improvements:**
- Duplicate removal and structure optimization
- Performance enhancement (parallel processing, caching)
- Security hardening (Vault, key management)
- Automated cleanup and optimization
- Cross-platform compatibility

### 2. `.gitignore.optimized` - Improved .gitignore
```bash
# Backup existing .gitignore
cp .gitignore .gitignore.backup

# Apply new .gitignore
cp .gitignore.optimized .gitignore
```

**Key Improvements:**
- Exclude system files (.DS_Store, Thumbs.db, etc.)
- Exclude security-related files (keys, passwords, etc.)
- Exclude temporary files (cache, logs, etc.)
- Exclude development environment files

## ðŸš€ Usage Instructions

### Step-by-Step Cleanup

#### Step 1: Create Backup
```bash
# Backup current state
cp -r . ../mitum-ansible-backup-$(date +%Y%m%d)
```

#### Step 2: Clean Duplicate Files
```bash
# Clean duplicate files
./cleanup-duplicates.sh
```

#### Step 3: Optimize Project
```bash
# Optimize project
./scripts/optimize-project.sh
```

#### Step 4: Apply Optimized Files
```bash
# Apply Makefile
cp Makefile.optimized Makefile

# Apply .gitignore
cp .gitignore.optimized .gitignore
```

#### Step 5: Final Validation
```bash
# Execute master cleanup script
./scripts/master-cleanup.sh
```

### One-Click Cleanup (Recommended)
```bash
# Execute all cleanup tasks at once
./scripts/master-cleanup.sh
```

## ðŸ“Š Expected Results

### Before Cleanup
```
mitum-ansible/
â”œâ”€â”€ ansible.cfg
â”œâ”€â”€ Makefile
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ core-files/          # Duplicate directory
â”‚   â”œâ”€â”€ ansible.cfg      # Duplicate file
â”‚   â”œâ”€â”€ Makefile         # Duplicate file
â”‚   â””â”€â”€ ...
â”œâ”€â”€ .DS_Store            # Unnecessary file
â””â”€â”€ ...
```

### After Cleanup
```
mitum-ansible/
â”œâ”€â”€ ansible.cfg          # Optimized
â”œâ”€â”€ Makefile             # Optimized
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .gitignore           # Security enhanced
â”œâ”€â”€ PROJECT_STRUCTURE.md # Newly created
â”œâ”€â”€ OPTIMIZATION_GUIDE.md # Newly created
â”œâ”€â”€ playbooks/
â”œâ”€â”€ roles/
â”œâ”€â”€ inventories/
â”œâ”€â”€ keys/
â”œâ”€â”€ logs/
â”œâ”€â”€ scripts/
â””â”€â”€ ...
```

## ðŸ”§ Additional Optimization Options

### Makefile Optimization Commands
```bash
# Full project optimization
make optimize

# Remove duplicate files
make deduplicate

# Optimize Ansible configuration
make optimize-config

# Security optimization
make optimize-security
```

### Performance Tuning
```bash
# Parallel processing settings
PARALLEL_FORKS=100 make deploy

# Enable cache
CACHE_ENABLED=yes make deploy

# Dry run mode
DRY_RUN=yes make deploy
```

## âš ï¸ Precautions

### 1. Backup Required
- Always create backup before cleanup operations
- Scripts automatically create backup, but manual backup is also recommended

### 2. Check Git Status
- Check Git status before cleanup operations
- Commit important changes if any

### 3. Environment Testing
- Test in development environment first
- Verify thoroughly before applying to production environment

## ðŸ› Troubleshooting

### Common Issues

#### 1. Permission Errors
```bash
# Grant execution permission
chmod +x *.sh
chmod +x scripts/*.sh
```

#### 2. Duplicate File Errors
```bash
# Manually check duplicate files
find . -name "*.yml" -exec md5sum {} \; | sort | uniq -w32 -d
```

#### 3. Performance Issues
```bash
# Adjust parallel processing settings
PARALLEL_FORKS=20 make deploy
```

#### 4. Security Issues
```bash
# Set SSH key permissions
find keys/ -name "*.pem" -exec chmod 600 {} \;
```

## ðŸ“ž Support

### Log Checking
```bash
# Cleanup script logs
tail -f logs/cleanup.log

# Ansible logs
tail -f logs/ansible.log
```

### Issue Reporting
If problems occur during cleanup, please report with the following information:
1. Script name executed
2. Error message
3. System information (OS, version, etc.)
4. Project status

## ðŸ“ˆ Performance Improvement Effects

### Expected Improvements
- **File Size**: Approximately 30-40% reduction
- **Deployment Speed**: Approximately 20-30% improvement
- **Memory Usage**: Approximately 15-20% reduction
- **Maintainability**: Significantly improved
- **Security**: Greatly enhanced

### Monitoring
```bash
# Check project size
du -sh .

# Check file count
find . -type f | wc -l

# Check directory count
find . -type d | wc -l
```

---

**Last Updated**: December 2024
**Version**: 5.0.0
**Author**: AI Assistant 

================================================================================
íŒŒì¼: IDENTIFIED_ISSUES.md
================================================================================
# Identified Issues and Improvement Areas

## ðŸš¨ Critical Issues

### 1. Incorrect defaults/main.yml in roles/mitum/defaults/
**Issue**: The defaults/main.yml file contains task definitions instead of default variables.
**Impact**: This breaks Ansible role conventions and may cause unexpected behavior.
**Priority**: HIGH
**Action Required**: Create proper default variables file.

### 2. Missing Molecule Testing Framework
**Issue**: No automated testing for Ansible roles and playbooks.
**Impact**: Risk of deployment failures and regressions.
**Priority**: HIGH
**Action Required**: Implement Molecule testing with Docker scenarios.

### 3. Inconsistent Error Handling
**Issue**: Some playbooks lack proper error handling and rollback mechanisms.
**Impact**: Failed deployments may leave systems in inconsistent states.
**Priority**: MEDIUM
**Action Required**: Standardize error handling across all playbooks.

## âš ï¸ Medium Priority Issues

### 4. Performance Bottlenecks
**Issue**: Sequential task execution in some playbooks.
**Impact**: Slow deployment times, especially for large clusters.
**Priority**: MEDIUM
**Action Required**: Implement more parallel task execution.

### 5. Missing Health Check Endpoints
**Issue**: Limited health check mechanisms for deployed services.
**Impact**: Difficulty in monitoring and automated recovery.
**Priority**: MEDIUM
**Action Required**: Add comprehensive health check endpoints.

### 6. Insufficient Backup Validation
**Issue**: Backup creation but limited restore validation.
**Impact**: Potential data loss if backups are corrupted.
**Priority**: MEDIUM
**Action Required**: Implement backup integrity checks and restore testing.

## ðŸ” Minor Issues

### 7. Documentation Gaps
**Issue**: Some advanced features lack detailed documentation.
**Impact**: User confusion and support burden.
**Priority**: LOW
**Action Required**: Expand documentation with more examples.

### 8. Hard-coded Values
**Issue**: Some configuration values are hard-coded in playbooks.
**Impact**: Reduced flexibility for different environments.
**Priority**: LOW
**Action Required**: Move hard-coded values to variables.

### 9. Limited Multi-Cloud Support
**Issue**: Primarily designed for single cloud provider.
**Impact**: Vendor lock-in and limited deployment options.
**Priority**: LOW
**Action Required**: Add multi-cloud configuration support.

## ðŸŽ¯ Enhancement Opportunities

### 10. Container Support
**Issue**: No containerized deployment option.
**Impact**: Missing modern deployment paradigm.
**Priority**: ENHANCEMENT
**Action Required**: Add Docker/Kubernetes deployment manifests.

### 11. GitOps Integration
**Issue**: Manual deployment process.
**Impact**: Less automated and auditable deployments.
**Priority**: ENHANCEMENT
**Action Required**: Implement GitOps workflows.

### 12. Advanced Monitoring
**Issue**: Basic monitoring setup.
**Impact**: Limited observability for complex issues.
**Priority**: ENHANCEMENT
**Action Required**: Add distributed tracing and APM.

## ðŸ“Š Technical Debt

### 13. Outdated Dependencies
**Issue**: Some dependencies may be outdated.
**Impact**: Security vulnerabilities and missing features.
**Priority**: MAINTENANCE
**Action Required**: Regular dependency updates and scanning.

### 14. Code Duplication (Remaining)
**Issue**: Still some duplicated patterns across playbooks.
**Impact**: Maintenance overhead and consistency issues.
**Priority**: MAINTENANCE
**Action Required**: Continue refactoring duplicated code.

### 15. Legacy Script Compatibility
**Issue**: Some scripts may have compatibility issues with newer systems.
**Impact**: Deployment failures on newer OS versions.
**Priority**: MAINTENANCE
**Action Required**: Update scripts for modern OS compatibility.

## ðŸ”§ Recommended Action Plan

### Phase 1 (Immediate - 1-2 weeks)
1. Fix roles/mitum/defaults/main.yml
2. Implement basic Molecule testing
3. Standardize error handling

### Phase 2 (Short-term - 1 month)
4. Optimize performance bottlenecks
5. Add health check endpoints
6. Implement backup validation

### Phase 3 (Medium-term - 2-3 months)
7. Expand documentation
8. Remove hard-coded values
9. Add multi-cloud support

### Phase 4 (Long-term - 3-6 months)
10. Implement container support
11. Add GitOps integration
12. Enhance monitoring stack

### Continuous (Ongoing)
13. Regular dependency updates
14. Ongoing code refactoring
15. Legacy compatibility updates

## ðŸ“ Notes

- Issues are prioritized based on impact to deployment reliability and user experience
- Some issues may be addressed in parallel
- Regular review of this list is recommended
- Consider user feedback when prioritizing enhancements 

================================================================================
íŒŒì¼: IMPROVEMENTS_SUMMARY.md
================================================================================
# Mitum Ansible Project Improvements Summary

## Overview
This document summarizes all the improvements and optimizations made to the Mitum Ansible project.

## 1. Code Deduplication âœ…

### Created Common Task Files:
- `roles/mitum/tasks/common-validation.yml` - Shared validation logic
- `roles/mitum/tasks/common-package-install.yml` - OS-agnostic package installation

### Benefits:
- Reduced code repetition across playbooks
- Easier maintenance and updates
- Consistent behavior across environments

## 2. CI/CD Pipeline Integration âœ…

### GitHub Actions (`.github/workflows/ci.yml`):
- Automated linting (ansible-lint, yamllint)
- Security scanning with Trivy
- Molecule testing for different scenarios
- Automated deployment to test environments
- Slack notifications

### GitLab CI (`.gitlab-ci.yml`):
- Multi-stage pipeline (validate â†’ test â†’ security â†’ deploy â†’ notify)
- Environment-specific deployments
- Manual approval for production
- Comprehensive caching strategy

### Key Features:
- Syntax validation
- Security checks for unencrypted vault files
- Automated testing with Molecule
- Progressive deployment (dev â†’ staging â†’ prod)

## 3. Enhanced Monitoring & Alerting âœ…

### New Monitoring Stack (`playbooks/setup-monitoring-alerts.yml`):
- **Prometheus** - Metrics collection
- **Grafana** - Visualization dashboards
- **AlertManager** - Alert routing and notifications

### Custom Mitum Alerts:
- Node down detection
- Block height stalling
- High memory usage (>85%)
- Low disk space (<15%)
- Low peer count (<2)

### Notification Channels:
- Slack integration
- PagerDuty for critical alerts
- Customizable alert routing

## 4. User Experience Improvements âœ…

### Interactive Setup Script:
- `scripts/interactive-setup.sh` - Guided setup wizard
- Visual progress indicators
- Environment selection
- Automatic SSH key generation
- Inventory file creation

### Visual Status Dashboard:
- `scripts/visual-status.sh` - Real-time node status
- Emoji indicators for quick status recognition
- Live monitoring mode with auto-refresh
- Network health summary

### Enhanced Documentation:
- `QUICK_START.md` - 3-minute quick start guide
- `TROUBLESHOOTING.md` - Common issues and solutions
- Improved README with clear getting started section

### Autocomplete Support:
- `scripts/autocomplete.sh` - Bash completion for make commands
- Environment and option value completion
- Easy installation instructions

## 5. Project Structure Optimization âœ…

### Removed:
- `core-files/` directory (complete duplicate)
- 25 `.DS_Store` files
- 8 empty directories
- Duplicate Makefile versions

### Added:
- Standard directory structure (`logs/`, `tmp/`, `cache/`, `backups/`)
- Proper `.gitignore` configuration
- Environment-specific directory organization

## 6. Performance Enhancements âœ…

### Ansible Configuration:
- Parallel processing (forks = 50)
- Fact caching enabled
- SSH connection reuse
- Pipelining enabled

### Makefile Improvements:
- Replaced with optimized version
- Added new targets: `optimize`, `deduplicate`, `dashboard`, `monitor`
- Better help system with emojis and categories

## 7. Language Standardization âœ…

### Translated to English:
- All script comments
- README.md
- Makefile help messages
- Error messages and prompts

### Benefits:
- International team collaboration
- Wider community adoption
- Consistent documentation language

## Usage Examples

### Quick Start:
```bash
# Interactive setup for beginners
make interactive-setup

# Quick deployment with defaults
make quick-deploy

# Visual status dashboard
make dashboard

# Real-time monitoring
./scripts/visual-status.sh --monitor
```

### CI/CD:
```bash
# Run linting locally
make lint

# Security scan
make security-scan

# Full test suite
make test-all
```

### Monitoring:
```bash
# Deploy monitoring stack
ansible-playbook playbooks/setup-monitoring-alerts.yml

# Access dashboards
# Grafana: http://monitoring-host:3000
# Prometheus: http://monitoring-host:9090
# AlertManager: http://monitoring-host:9093
```

## Next Steps

1. **Web Dashboard**: Consider adding a web-based management interface
2. **API Integration**: RESTful API for programmatic control
3. **Kubernetes Support**: Container orchestration option
4. **Multi-cloud Support**: AWS, GCP, Azure specific optimizations
5. **Automated Testing**: Expand test coverage with more scenarios

## Conclusion

The project is now more:
- **User-friendly**: Interactive setup, visual feedback, clear documentation
- **Maintainable**: Reduced duplication, standardized structure
- **Reliable**: CI/CD pipelines, automated testing, monitoring
- **Scalable**: Performance optimizations, proper abstractions
- **Professional**: English documentation, industry best practices

Total improvements implemented: **50+** across various categories. 

================================================================================
íŒŒì¼: Makefile
================================================================================
# Mitum Ansible Makefile (Optimized Version)
# Version: 5.0.0 - Enhanced with deduplication, performance, and security
# 
# Key improvements:
# 1. Duplicate code removal and structure optimization
# 2. Performance enhancement (parallel processing, caching)
# 3. Security hardening (Vault, key management)
# 4. Automated cleanup and optimization
# 5. Cross-platform compatibility

.PHONY: help setup test keygen deploy status logs backup restore clean upgrade inventory optimize deduplicate

# === Configuration ===
# Environment variables - defaults and overridable
ENV ?= production
INVENTORY ?= inventories/$(ENV)/hosts.yml
PLAYBOOK_DIR = playbooks
VENV = venv
ANSIBLE = $(VENV)/bin/ansible
ANSIBLE_PLAYBOOK = $(VENV)/bin/ansible-playbook
ANSIBLE_VAULT = $(VENV)/bin/ansible-vault

# OS detection - Mac and Linux differentiation
UNAME := $(shell uname -s)
ifeq ($(UNAME),Darwin)
    OS_TYPE = macos
    PACKAGE_MANAGER = brew
    SERVICE_MANAGER = launchctl
    SED_CMD = sed -i.bak
else
    OS_TYPE = linux
    PACKAGE_MANAGER = apt-get
    SERVICE_MANAGER = systemctl
    SED_CMD = sed -i
endif

# Security options - enabled by default
STRICT_HOST_KEY_CHECKING ?= yes
USE_VAULT ?= yes
VAULT_PASSWORD_FILE ?= .vault_pass

# Safe mode - additional confirmation for destructive operations
SAFE_MODE ?= yes
DRY_RUN ?= no

# Performance optimization options
PARALLEL_FORKS ?= 50
CACHE_ENABLED ?= yes
FACT_CACHING ?= jsonfile

# Color definitions
GREEN = \033[0;32m
RED = \033[0;31m
YELLOW = \033[1;33m
BLUE = \033[0;34m
NC = \033[0m

# === Helper Functions ===
# Safety confirmation function - used before destructive operations
define confirm_action
	@if [ "$(SAFE_MODE)" = "yes" ]; then \
		echo "$(RED)WARNING: $(1)$(NC)"; \
		echo "$(YELLOW)This action cannot be undone!$(NC)"; \
		read -p "Type 'yes' to confirm: " confirm; \
		if [ "$$confirm" != "yes" ]; then \
			echo "$(GREEN)Operation cancelled.$(NC)"; \
			exit 1; \
		fi \
	fi
endef

# Dry run check function
define check_dry_run
	$(if $(filter yes,$(DRY_RUN)),--check)
endef

# Performance optimization function
define performance_flags
	--forks $(PARALLEL_FORKS) \
	$(if $(filter yes,$(CACHE_ENABLED)),--fact-cache .ansible_cache) \
	--timeout 30
endef

# Default target
.DEFAULT_GOAL := help

# === Main Targets ===

help: ## Show help message with categorized commands
	@echo ""
	@echo "$(CYAN)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@echo "$(GREEN)ðŸš€ Mitum Ansible Automation System v5.0.0$(NC)"
	@echo "$(CYAN)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@echo "ðŸ“Œ OS: $(GREEN)$(OS_TYPE)$(NC) | Package Manager: $(GREEN)$(PACKAGE_MANAGER)$(NC)"
	@echo ""
	@echo "$(YELLOW)ðŸš€ Quick Start:$(NC)"
	@echo "  $(BLUE)interactive-setup$(NC)     ðŸ’¬ Interactive setup (recommended for beginners!)"
	@echo "  $(BLUE)quick-deploy$(NC)          âš¡ Quick deployment (uses default settings)"
	@echo ""
	@echo "$(YELLOW)ðŸ”§ Setup & Configuration:$(NC)"
	@echo "  $(BLUE)setup$(NC)                 ðŸ“¦ Environment setup"
	@echo "  $(BLUE)test$(NC)                  ðŸ§ª Connection test"
	@echo "  $(BLUE)keygen$(NC)                ðŸ”‘ Key generation"
	@echo ""
	@echo "$(YELLOW)ðŸš€ Deployment & Operations:$(NC)"
	@echo "  $(BLUE)deploy$(NC)                ðŸŽ¯ Full deployment"
	@echo "  $(BLUE)status$(NC)                ðŸ“Š Status check"
	@echo "  $(BLUE)logs$(NC)                  ðŸ“œ View logs"
	@echo "  $(BLUE)dashboard$(NC)             ðŸ“ˆ Open dashboard"
	@echo ""
	@echo "$(YELLOW)ðŸ›¡ï¸  Maintenance:$(NC)"
	@echo "  $(BLUE)backup$(NC)                ðŸ’¾ Create backup"
	@echo "  $(BLUE)restore$(NC)               â™»ï¸  Restore backup"
	@echo "  $(BLUE)upgrade$(NC)               ðŸ“¡ Upgrade"
	@echo "  $(BLUE)clean$(NC)                 ðŸ§¹ Clean up"
	@echo ""
	@echo "$(YELLOW)âœ¨ Optimization:$(NC)"
	@echo "  $(BLUE)optimize$(NC)              ðŸ”§ Optimize project"
	@echo "  $(BLUE)deduplicate$(NC)           ðŸ—‘ï¸  Remove duplicates"
	@echo ""
	@echo "$(YELLOW)âš™ï¸  Options:$(NC)"
	@echo "  $(CYAN)ENV=<environment>$(NC)     ðŸŒ Target environment (default: $(GREEN)$(ENV)$(NC))"
	@echo "  $(CYAN)DRY_RUN=yes$(NC)           ðŸ‘€ Preview changes"
	@echo "  $(CYAN)SAFE_MODE=no$(NC)          âš ï¸  Disable safety checks"
	@echo ""
	@echo "$(GREEN)ðŸ’¡ Tip:$(NC) New to this? Start with $(BLUE)'make interactive-setup'$(NC)!"
	@echo "$(GREEN)ðŸ“š Help:$(NC) For more details, check $(BLUE)'cat QUICK_START.md'$(NC)"
	@echo ""

# === Quick Start Targets ===

interactive-setup: ## Interactive setup start (recommended for beginners!)
	@echo "$(GREEN)ðŸŽ¯ Starting interactive setup...$(NC)"
	@if [ ! -f scripts/interactive-setup.sh ]; then \
		echo "$(RED)âŒ Error: interactive-setup.sh file not found$(NC)"; \
		exit 1; \
	fi
	@bash ./scripts/interactive-setup.sh

start: interactive-setup ## Interactive setup start (alias)

quick-deploy: setup ## Quick deployment with minimal steps
	@echo "$(GREEN)>>> Quick Deployment Mode$(NC)"
	@echo "This will deploy Mitum with default settings."
	@echo ""
	@if [ -z "$(BASTION_IP)" ] || [ -z "$(NODE_IPS)" ]; then \
		echo "$(RED)Error: Required variables missing$(NC)"; \
		echo "Usage: make quick-deploy BASTION_IP=x.x.x.x NODE_IPS=10.0.1.10,10.0.1.11"; \
		exit 1; \
	fi
	@make inventory
	@make test
	@make deploy

# === Setup Commands ===

setup: ## Initial setup with dependency checks
	@echo "$(GREEN)>>> Running enhanced setup for $(OS_TYPE)...$(NC)"
	@if [ ! -f scripts/setup.sh ]; then \
		echo "$(RED)Error: setup.sh not found$(NC)"; \
		exit 1; \
	fi
	@bash ./scripts/setup.sh
	@make setup-vault
	@make optimize-config
	@echo "$(GREEN)âœ“ Setup complete!$(NC)"

setup-vault: ## Setup Ansible Vault for secrets
	@if [ "$(USE_VAULT)" = "yes" ] && [ ! -f "$(VAULT_PASSWORD_FILE)" ]; then \
		echo "$(YELLOW)>>> Setting up Ansible Vault...$(NC)"; \
		echo "Enter a strong password for Ansible Vault:"; \
		read -s vault_pass; \
		echo "$$vault_pass" > $(VAULT_PASSWORD_FILE); \
		chmod 600 $(VAULT_PASSWORD_FILE); \
		echo "$(GREEN)âœ“ Vault password saved to $(VAULT_PASSWORD_FILE)$(NC)"; \
		echo "$(YELLOW)Keep this file safe and add it to .gitignore!$(NC)"; \
	fi

# === Optimization Commands (New) ===

optimize: ## Full project optimization
	@echo "$(GREEN)>>> Running project optimization...$(NC)"
	@if [ -f scripts/optimize-project.sh ]; then \
		bash ./scripts/optimize-project.sh; \
	else \
		echo "$(YELLOW)Optimization script not found, running basic optimization...$(NC)"; \
		make deduplicate; \
		make optimize-config; \
		make optimize-security; \
	fi

deduplicate: ## Remove duplicate files
	@echo "$(GREEN)>>> Removing duplicate files...$(NC)"
	@if [ -f cleanup-duplicates.sh ]; then \
		bash ./cleanup-duplicates.sh; \
	else \
		echo "$(YELLOW)Cleanup script not found, manual cleanup required$(NC)"; \
	fi

optimize-config: ## Optimize Ansible configuration
	@echo "$(GREEN)>>> Optimizing Ansible configuration...$(NC)"
	@if [ -f ansible.cfg ]; then \
		$(SED_CMD) 's/forks = [0-9]*/forks = $(PARALLEL_FORKS)/' ansible.cfg; \
		$(SED_CMD) 's/fact_caching = [^[:space:]]*/fact_caching = $(FACT_CACHING)/' ansible.cfg; \
		echo "$(GREEN)âœ“ Configuration optimized$(NC)"; \
	fi

optimize-security: ## Security optimization
	@echo "$(GREEN)>>> Optimizing security settings...$(NC)"
	@find keys/ -name "*.pem" -exec chmod 600 {} \; 2>/dev/null || true
	@find keys/ -name "*.key" -exec chmod 600 {} \; 2>/dev/null || true
	@if [ -f .vault_pass ]; then \
		chmod 600 .vault_pass; \
	fi
	@echo "$(GREEN)âœ“ Security optimized$(NC)"

# === Key Management ===

keys-add: ## Add SSH key with validation
	@if [ -z "$(KEY)" ]; then \
		echo "$(RED)Error: KEY variable required$(NC)"; \
		echo "Usage: make keys-add KEY=~/key.pem NAME=bastion.pem"; \
		exit 1; \
	fi
	@# Validate key format
	@if ! ssh-keygen -l -f $(KEY) > /dev/null 2>&1; then \
		echo "$(RED)Error: Invalid SSH key format$(NC)"; \
		exit 1; \
	fi
	@./scripts/manage-keys.sh add $(ENV) $(KEY) $(NAME)

keys-encrypt: ## Encrypt sensitive keys with Ansible Vault
	@if [ "$(USE_VAULT)" = "yes" ]; then \
		echo "$(YELLOW)>>> Encrypting sensitive files...$(NC)"; \
		find inventories/$(ENV) -name "vault*.yml" -exec \
			$(ANSIBLE_VAULT) encrypt {} --vault-password-file=$(VAULT_PASSWORD_FILE) \; ; \
		echo "$(GREEN)âœ“ Files encrypted$(NC)"; \
	fi

# === Testing ===

test: activate ## Test connectivity with host key verification
	@echo "$(GREEN)>>> Testing connectivity (secure mode)...$(NC)"
	@# First, gather host keys safely
	@if [ "$(STRICT_HOST_KEY_CHECKING)" = "yes" ]; then \
		echo "$(YELLOW)Gathering SSH host keys...$(NC)"; \
		$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/gather-host-keys.yml \
			$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
			$(call performance_flags); \
	fi
	@$(ANSIBLE) -i $(INVENTORY) all -m ping \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
		$(call performance_flags)
	@echo "$(GREEN)âœ“ All hosts accessible$(NC)"

test-check: activate ## Dry run connectivity test
	@$(ANSIBLE) -i $(INVENTORY) all -m ping --check $(call performance_flags)

# === Deployment ===

deploy: activate pre-deploy-check ## Full deployment with safety checks
	@echo "$(GREEN)>>> Starting safe deployment...$(NC)"
	@# Create pre-deployment snapshot
	@make backup BACKUP_TYPE=pre-deploy
	@# Run deployment
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/site.yml \
		$(call check_dry_run) \
		$(call performance_flags) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
		-e "deployment_id=$$(date +%Y%m%d-%H%M%S)"
	@# Verify deployment
	@make post-deploy-check
	@echo "$(GREEN)âœ“ Deployment complete and verified!$(NC)"

pre-deploy-check: ## Pre-deployment validation
	@echo "$(YELLOW)>>> Running pre-deployment checks...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/pre-deploy-check.yml \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
		$(call performance_flags)

post-deploy-check: ## Post-deployment validation
	@echo "$(YELLOW)>>> Verifying deployment...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/post-deploy-check.yml \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
		$(call performance_flags)

# === Upgrade ===

upgrade: activate ## Safe rolling upgrade with automatic rollback
	@if [ -z "$(VERSION)" ]; then \
		echo "$(RED)Error: VERSION required$(NC)"; \
		echo "Usage: make upgrade VERSION=v0.0.2"; \
		exit 1; \
	fi
	@echo "$(GREEN)>>> Starting safe rolling upgrade to $(VERSION)...$(NC)"
	@# Create upgrade backup
	@make backup BACKUP_TYPE=pre-upgrade
	@# Run upgrade with rollback support
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/rolling-upgrade.yml \
		-e "mitum_version=$(VERSION)" \
		-e "enable_rollback=yes" \
		-e "rollback_on_failure=yes" \
		$(call performance_flags) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Monitoring ===

logs: activate ## View logs (cross-platform)
	@echo "$(GREEN)>>> Fetching logs...$(NC)"
	@if [ "$(OS_TYPE)" = "macos" ]; then \
		echo "$(YELLOW)Note: Using alternative log method for macOS$(NC)"; \
		$(ANSIBLE) -i $(INVENTORY) mitum_nodes \
			-m shell -a "tail -n 50 /var/log/mitum/mitum.log || echo 'No logs found'" \
			--become $(call performance_flags); \
	else \
		$(ANSIBLE) -i $(INVENTORY) mitum_nodes \
			-m shell -a "journalctl -u mitum -n 50 --no-pager || tail -n 50 /var/log/mitum/mitum.log" \
			--become $(call performance_flags); \
	fi

# === Destructive Operations ===

clean-data: activate ## Clean blockchain data (PROTECTED)
	$(call confirm_action,This will DELETE all blockchain data!)
	@echo "$(RED)>>> Starting data cleanup...$(NC)"
	@# Create emergency backup first
	@make backup BACKUP_TYPE=emergency
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/clean-data.yml \
		--extra-vars "safety_confirmed=yes" \
		$(call performance_flags) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Backup & Restore ===

backup: activate ## Create timestamped backup with metadata
	@echo "$(GREEN)>>> Creating backup...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/backup.yml \
		-e "backup_type=$${BACKUP_TYPE:-manual}" \
		-e "backup_timestamp=$$(date +%Y%m%d-%H%M%S)" \
		$(call performance_flags) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

restore: activate ## Restore from backup with validation
	@if [ -z "$(BACKUP_TIMESTAMP)" ]; then \
		echo "$(RED)Error: BACKUP_TIMESTAMP required$(NC)"; \
		echo "Available backups:"; \
		@$(ANSIBLE) -i $(INVENTORY) mitum_nodes[0] -m shell \
			-a "ls -la /var/backups/mitum/" --become; \
		exit 1; \
	fi
	$(call confirm_action,This will restore from backup $(BACKUP_TIMESTAMP))
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/restore.yml \
		-e "backup_timestamp=$(BACKUP_TIMESTAMP)" \
		-e "validate_backup=yes" \
		$(call performance_flags) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Utility Commands ===

vault-edit: ## Edit vault-encrypted files
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: FILE required$(NC)"; \
		echo "Usage: make vault-edit FILE=inventories/production/group_vars/vault.yml"; \
		exit 1; \
	fi
	@$(ANSIBLE_VAULT) edit $(FILE) --vault-password-file=$(VAULT_PASSWORD_FILE)

validate: activate ## Validate all playbooks and syntax
	@echo "$(YELLOW)>>> Validating Ansible files...$(NC)"
	@for playbook in $(PLAYBOOK_DIR)/*.yml; do \
		echo "Checking $$playbook..."; \
		$(ANSIBLE_PLAYBOOK) --syntax-check $$playbook; \
	done
	@echo "$(GREEN)âœ“ All playbooks valid$(NC)"

# === Development Helpers ===

dev-env: ## Setup development environment with safety defaults
	@echo "$(YELLOW)>>> Setting up development environment...$(NC)"
	@cp -n inventories/development/hosts.yml.example inventories/development/hosts.yml || true
	@echo "SAFE_MODE=no" >> .env.development
	@echo "DRY_RUN=yes" >> .env.development
	@echo "$(GREEN)âœ“ Development environment ready$(NC)"

# === Virtual Environment ===

venv: ## Create Python virtual environment
	@if [ ! -d "$(VENV)" ]; then \
		echo "$(GREEN)>>> Creating virtual environment...$(NC)"; \
		python3 -m venv $(VENV); \
		$(VENV)/bin/pip install --upgrade pip; \
		$(VENV)/bin/pip install -r requirements.txt; \
	fi

activate: venv ## Ensure virtual environment is active
	@if [ -z "$${VIRTUAL_ENV}" ]; then \
		echo "$(YELLOW)Activating virtual environment...$(NC)"; \
		. $(VENV)/bin/activate; \
	fi

# === Clean Commands ===

clean: ## Clean generated files and caches
	@echo "$(GREEN)>>> Cleaning temporary files...$(NC)"
	@find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete
	@rm -rf .ansible_cache .ansible_inventory_cache
	@rm -rf logs/*.log
	@echo "$(GREEN)âœ“ Clean complete$(NC)"

clean-all: clean ## Deep clean including venv (CAREFUL!)
	$(call confirm_action,This will remove virtual environment and all dependencies)
	@rm -rf $(VENV)
	@rm -rf tools/mitumjs/node_modules
	@echo "$(GREEN)âœ“ Deep clean complete$(NC)"

.PHONY: all $(MAKECMDGOALS) 

================================================================================
íŒŒì¼: PROJECT_STRUCTURE.md
================================================================================
# Mitum Ansible Project Structure

## Directory Structure

```
mitum-ansible/
â”œâ”€â”€ ansible.cfg              # Ansible configuration file
â”œâ”€â”€ Makefile                 # Build and deployment commands
â”œâ”€â”€ requirements.txt         # Python dependencies
â”œâ”€â”€ README.md               # Project documentation
â”œâ”€â”€ .gitignore              # Git exclude file
â”œâ”€â”€ .vault_pass             # Ansible Vault password
â”œâ”€â”€ playbooks/              # Ansible playbooks
â”‚   â”œâ”€â”€ site.yml           # Main deployment playbook
â”‚   â”œâ”€â”€ deploy-mitum.yml   # Mitum deployment
â”‚   â”œâ”€â”€ backup.yml         # Backup
â”‚   â””â”€â”€ ...
â”œâ”€â”€ roles/                  # Ansible roles
â”‚   â””â”€â”€ mitum/             # Mitum node role
â”œâ”€â”€ inventories/            # Inventory
â”‚   â”œâ”€â”€ development/       # Development environment
â”‚   â”œâ”€â”€ staging/          # Staging environment
â”‚   â””â”€â”€ production/       # Production environment
â”œâ”€â”€ keys/                  # SSH keys and Mitum keys
â”œâ”€â”€ logs/                  # Log files
â”œâ”€â”€ scripts/               # Utility scripts
â””â”€â”€ tools/                 # Tools and scripts
```

## Key File Descriptions

- `ansible.cfg`: Ansible configuration (security, performance optimization)
- `Makefile`: Deployment and management commands
- `playbooks/`: Ansible playbook collection
- `roles/mitum/`: Mitum node configuration role
- `inventories/`: Environment-specific host and variable definitions
- `keys/`: SSH key and Mitum key storage

================================================================================
íŒŒì¼: QUICK_START.md
================================================================================
# ðŸš€ Mitum Ansible ë¹ ë¥¸ ì‹œìž‘ ê°€ì´ë“œ

> 5ë¶„ ì•ˆì— Mitum ë¸”ë¡ì²´ì¸ì„ ë°°í¬í•´ë³´ì„¸ìš”!

## ðŸŽ¯ í•œ ì¤„ ì„¤ì¹˜

```bash
curl -sSL https://raw.githubusercontent.com/your-org/mitum-ansible/main/install.sh | bash
```

## ðŸ“‹ ë¹ ë¥¸ ì‹œìž‘ ë‹¨ê³„

### 1ï¸âƒ£ ëŒ€í™”í˜• ì„¤ì • (ê¶Œìž¥)

ê°€ìž¥ ì‰¬ìš´ ë°©ë²•ìž…ë‹ˆë‹¤:

```bash
./scripts/interactive-setup.sh
```

ì´ ìŠ¤í¬ë¦½íŠ¸ê°€ ìžë™ìœ¼ë¡œ:
- âœ… í™˜ê²½ ì„¤ì •
- âœ… SSH í‚¤ ìƒì„±
- âœ… ì¸ë²¤í† ë¦¬ íŒŒì¼ ìƒì„±
- âœ… ê¸°ë³¸ ì„¤ì • êµ¬ì„±

### 2ï¸âƒ£ ìˆ˜ë™ ì„¤ì • (ê³ ê¸‰ ì‚¬ìš©ìž)

#### Step 1: ê°€ìƒ í™˜ê²½ ì„¤ì •
```bash
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

#### Step 2: ì¸ë²¤í† ë¦¬ ë³µì‚¬
```bash
cp inventories/development/hosts.yml.example inventories/development/hosts.yml
```

#### Step 3: ë…¸ë“œ IP ìˆ˜ì •
```yaml
# inventories/development/hosts.yml
mitum_nodes:
  hosts:
    node0:
      ansible_host: 192.168.1.10  # ì—¬ê¸°ì— ì‹¤ì œ IP ìž…ë ¥
    node1:
      ansible_host: 192.168.1.11  # ì—¬ê¸°ì— ì‹¤ì œ IP ìž…ë ¥
```

## ðŸƒâ€â™‚ï¸ ë°°í¬ ì‹¤í–‰

### ê°œë°œ í™˜ê²½
```bash
# ì—°ê²° í…ŒìŠ¤íŠ¸
make test ENV=development

# ì‹œìŠ¤í…œ ì¤€ë¹„
make prepare ENV=development

# Mitum ë°°í¬
make deploy ENV=development
```

### í”„ë¡œë•ì…˜ í™˜ê²½
```bash
# ì•ˆì „í•œ ë°°í¬ (ë“œë¼ì´ëŸ° í¬í•¨)
make safe-deploy ENV=production
```

## ðŸ” ìƒíƒœ í™•ì¸

```bash
# ë…¸ë“œ ìƒíƒœ í™•ì¸
make status

# ë¡œê·¸ í™•ì¸
make logs

# ëŒ€ì‹œë³´ë“œ ì—´ê¸°
make dashboard
```

## ðŸ’¡ ìœ ìš©í•œ ëª…ë ¹ì–´

| ëª…ë ¹ì–´ | ì„¤ëª… |
|--------|------|
| `make help` | ëª¨ë“  ëª…ë ¹ì–´ ë³´ê¸° |
| `make test` | ì—°ê²° í…ŒìŠ¤íŠ¸ |
| `make deploy` | ì „ì²´ ë°°í¬ |
| `make status` | ìƒíƒœ í™•ì¸ |
| `make logs` | ë¡œê·¸ ë³´ê¸° |
| `make backup` | ë°±ì—… ìƒì„± |
| `make restore` | ë°±ì—… ë³µì› |
| `make clean` | ì •ë¦¬ |

## ðŸ†˜ ë¬¸ì œ í•´ê²°

### ì—°ê²° ì‹¤íŒ¨
```bash
# SSH í‚¤ ê¶Œí•œ í™•ì¸
chmod 600 keys/ssh/*/mitum_key

# ì—°ê²° í…ŒìŠ¤íŠ¸
ansible all -m ping -i inventories/development/hosts.yml
```

### Python ë²„ì „ ì˜¤ë¥˜
```bash
# Python 3.8+ í•„ìš”
python3 --version

# macOS
brew install python@3.9

# Ubuntu
sudo apt update && sudo apt install python3.9
```

### Ansible ì˜¤ë¥˜
```bash
# Ansible ìž¬ì„¤ì¹˜
pip install --upgrade ansible
```

## ðŸ“š ë‹¤ìŒ ë‹¨ê³„

1. [ìƒì„¸ ë¬¸ì„œ](README.md) ì½ê¸°
2. [ë¬¸ì œ í•´ê²° ê°€ì´ë“œ](TROUBLESHOOTING.md) í™•ì¸
3. [ê³ ê¸‰ ì„¤ì •](docs/ADVANCED.md) ì‚´íŽ´ë³´ê¸°

## ðŸŽ‰ ì¶•í•˜í•©ë‹ˆë‹¤!

ì´ì œ Mitum ë¸”ë¡ì²´ì¸ì´ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤! 

ì›¹ ëŒ€ì‹œë³´ë“œ: http://your-node-ip:54321

---

ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ ì–¸ì œë“  ë¬¸ì˜í•´ì£¼ì„¸ìš”! ðŸ¤ 

================================================================================
íŒŒì¼: README.md
================================================================================
# ðŸš€ Mitum Blockchain Ansible Automation System

[![Version](https://img.shields.io/badge/version-5.0.0-blue.svg)](https://github.com/your-repo/mitum-ansible)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Ansible](https://img.shields.io/badge/ansible-2.13+-red.svg)](https://www.ansible.com/)
[![Platform](https://img.shields.io/badge/platform-linux%20%7C%20macos-lightgrey.svg)](https://github.com/your-repo/mitum-ansible)

Production-ready Ansible automation framework for deploying and managing Mitum blockchain networks with enterprise-grade features including monitoring, automated backups, rolling upgrades, and multi-environment support.

## ðŸŽ¯ Get Started in 3 Minutes!

Choose your preferred method:

### ðŸŒŸ Method 1: Interactive Setup (Recommended for Beginners)
```bash
git clone https://github.com/your-org/mitum-ansible.git
cd mitum-ansible
make interactive-setup
```

### âš¡ Method 2: Quick Deploy (For Experienced Users)
```bash
git clone https://github.com/your-org/mitum-ansible.git
cd mitum-ansible
make setup
make quick-deploy
```

### ðŸš€ Method 3: Full Control (Advanced)
```bash
git clone https://github.com/your-org/mitum-ansible.git
cd mitum-ansible
./scripts/start.sh
```

ðŸ“š **Documentation:** [Quick Start Guide](QUICK_START.md) | [Troubleshooting](TROUBLESHOOTING.md) | [API Reference](#api-reference)

## ðŸ“‹ Table of Contents

- [âœ¨ Features](#-features)
- [ðŸ—ï¸ Architecture](#-architecture)
- [ðŸ“‹ Requirements](#-requirements)
- [ðŸš€ Installation](#-installation)
- [âš™ï¸ Configuration](#-configuration)
- [ðŸŽ® Usage Guide](#-usage-guide)
- [ðŸ“Š Monitoring & Alerting](#-monitoring--alerting)
- [ðŸ›¡ï¸ Security](#-security)
- [ðŸ”§ Advanced Features](#-advanced-features)
- [ðŸ“š API Reference](#-api-reference)
- [ðŸ†˜ Troubleshooting](#-troubleshooting)
- [ðŸ”„ CI/CD Integration](#-cicd-integration)
- [ðŸ¤ Contributing](#-contributing)

## âœ¨ Features

### Core Features
- **Automated Deployment**: One-command deployment of entire Mitum blockchain network
- **Multi-Node Support**: Deploy consensus nodes and API/syncer nodes
- **Key Management**: Centralized key generation using MitumJS
- **MongoDB Integration**: Automated replica set configuration
- **Rolling Upgrades**: Zero-downtime upgrades with automatic rollback
- **Backup & Restore**: Scheduled backups with encryption support

### Security Features
- **Ansible Vault**: Encrypted storage for sensitive data
- **SSH Key Management**: Automated key distribution and validation
- **Host Key Verification**: Secure SSH connections with known_hosts management
- **Firewall Configuration**: Automated security rules
- **MongoDB Authentication**: Secure database with user management

### Operational Features
- **Health Checks**: Automated service monitoring and recovery
- **Cross-Platform**: Support for Ubuntu, CentOS/RHEL, and limited macOS
- **Idempotent**: Safe to run multiple times
- **Dry Run Mode**: Preview changes before applying
- **Comprehensive Logging**: Detailed logs for troubleshooting

## ðŸ—ï¸ Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Bastion Host  â”‚â”€â”€â”€â”€â–¶â”‚  Consensus Node â”‚â”€â”€â”€â”€â–¶â”‚  MongoDB Primaryâ”‚
â”‚                 â”‚     â”‚     (node0)     â”‚     â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Consensus Node â”‚â”€â”€â”€â”€â–¶â”‚ MongoDB Secondaryâ”‚
         â”‚              â”‚     (node1)     â”‚     â”‚                 â”‚
         â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   API/Syncer    â”‚â”€â”€â”€â”€â–¶â”‚ MongoDB Secondaryâ”‚
                        â”‚     (node2)     â”‚     â”‚                 â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ðŸ“‹ Requirements

### Control Machine (Your Local Machine)
- **OS**: Linux, macOS, or WSL2 on Windows
- **Python**: 3.8 or higher
- **Ansible**: 6.0 or higher
- **Node.js**: 14.0 or higher (for MitumJS key generation)
- **Git**: 2.0 or higher

### Target Nodes
- **OS**: Ubuntu 18.04+, CentOS/RHEL 7+
- **CPU**: Minimum 2 cores, recommended 4+ cores
- **Memory**: Minimum 4GB, recommended 8GB+
- **Disk**: Minimum 20GB free space
- **Network**: All nodes must be accessible via SSH

### Network Requirements
- **Ports**:
  - SSH: 22 (configurable)
  - Mitum Node: 4320-4330
  - Mitum API: 54320
  - MongoDB: 27017
  - Prometheus: 9090, 9099
  - Grafana: 3000

## ðŸš€ Quick Start

### Option 1: Interactive Mode (Easiest for Beginners) ðŸŒŸ

```bash
# 1. Clone the repository
git clone https://github.com/your-repo/mitum-ansible.git
cd mitum-ansible

# 2. Run the easy start script
./start.sh

# That's it! The script will guide you through everything.
```

### Option 2: Using Deploy Script (Flexible)

```bash
# 1. Clone and setup
git clone https://github.com/your-repo/mitum-ansible.git
cd mitum-ansible
make setup

# 2. Add SSH keys
./scripts/add-key.sh production ~/path/to/your-key.pem bastion.pem

# 3. Run interactive deployment
./scripts/deploy-mitum.sh --interactive

# Or quick deployment with defaults
./scripts/deploy-mitum.sh
```

### Option 3: Using Makefile (Advanced)

```bash
# 1. Clone the repository
git clone https://github.com/your-repo/mitum-ansible.git
cd mitum-ansible

# 2. Run initial setup
make setup

# 3. Add SSH keys
make keys-add KEY=~/path/to/your-key.pem NAME=bastion.pem

# 4. Generate inventory
make inventory BASTION_IP=52.74.123.45 NODE_IPS=10.0.1.10,10.0.1.11,10.0.1.12

# 5. Test connectivity
make test

# 6. Deploy Mitum
make deploy
```

## ðŸ“¦ Installation

### 1. Initial Setup

Run the setup script to install all dependencies:

```bash
make setup
```

This will:
- Create Python virtual environment
- Install Ansible and required Python packages
- Install Node.js dependencies for MitumJS
- Create directory structure
- Generate configuration templates

### 2. SSH Key Configuration

Add your SSH keys for accessing the servers:

```bash
# Add bastion key
./scripts/add-key.sh production ~/Downloads/bastion-key.pem bastion.pem

# Add node key (if different from bastion)
./scripts/add-key.sh production ~/Downloads/node-key.pem nodes.pem
```

### 3. Inventory Generation

Generate an Ansible inventory for your environment:

```bash
# Basic usage
make inventory BASTION_IP=52.74.123.45 NODE_IPS=10.0.1.10,10.0.1.11,10.0.1.12

# With custom network ID and model
make inventory BASTION_IP=52.74.123.45 \
               NODE_SUBNET=10.0.1 \
               NODE_COUNT=5 \
               NETWORK_ID=mainnet \
               MODEL=mitum-currency
```

### 4. Configure Variables

Edit the generated configuration files:

```bash
# Edit global variables
vim inventories/production/group_vars/all.yml

# Create and encrypt vault for sensitive data
cp inventories/production/group_vars/vault.yml.template \
   inventories/production/group_vars/vault.yml
vim inventories/production/group_vars/vault.yml
ansible-vault encrypt inventories/production/group_vars/vault.yml
```

## âš™ï¸ Configuration

### Directory Structure

```
mitum-ansible/
â”œâ”€â”€ inventories/
â”‚   â”œâ”€â”€ production/
â”‚   â”‚   â”œâ”€â”€ hosts.yml              # Inventory file
â”‚   â”‚   â”œâ”€â”€ group_vars/
â”‚   â”‚   â”‚   â”œâ”€â”€ all.yml           # Global variables
â”‚   â”‚   â”‚   â””â”€â”€ vault.yml         # Encrypted secrets
â”‚   â”‚   â””â”€â”€ host_vars/            # Host-specific variables
â”‚   â”œâ”€â”€ staging/
â”‚   â””â”€â”€ development/
â”œâ”€â”€ playbooks/
â”‚   â”œâ”€â”€ site.yml                  # Main deployment playbook
â”‚   â”œâ”€â”€ prepare-system.yml        # System preparation
â”‚   â”œâ”€â”€ deploy-mitum.yml          # Mitum deployment
â”‚   â””â”€â”€ rolling-upgrade.yml       # Upgrade playbook
â”œâ”€â”€ roles/
â”‚   â””â”€â”€ mitum/
â”‚       â”œâ”€â”€ tasks/                # Task files
â”‚       â”œâ”€â”€ templates/            # Jinja2 templates
â”‚       â”œâ”€â”€ handlers/             # Handler definitions
â”‚       â””â”€â”€ defaults/             # Default variables
â”œâ”€â”€ keys/
â”‚   â”œâ”€â”€ ssh/                      # SSH keys (git-ignored)
â”‚   â””â”€â”€ mitum/                    # Generated blockchain keys
â””â”€â”€ scripts/
    â”œâ”€â”€ setup.sh                  # Initial setup script
    â””â”€â”€ manage-keys.sh            # Key management helper
```

### Key Configuration Files

#### inventories/production/group_vars/all.yml
```yaml
# Mitum configuration
mitum_version: "latest"
mitum_model_type: "mitum-currency"
mitum_network_id: "mainnet"

# MongoDB configuration
mongodb_version: "7.0"
mongodb_auth_enabled: true
mongodb_replica_set: "mitum-rs"

# Security settings
security_hardening:
  enabled: true
  firewall: true
  fail2ban: true
```

#### inventories/production/group_vars/vault.yml
```yaml
# Encrypt this file with: ansible-vault encrypt vault.yml
vault_mongodb_admin_password: "strong_password_here"
vault_mongodb_mitum_password: "another_strong_password"
vault_grafana_admin_password: "grafana_admin_password"
```

## ðŸ“– Usage

### Basic Operations

```bash
# Full deployment
make deploy

# Deploy specific components
make deploy-mitum     # Mitum nodes only
make mongodb          # MongoDB only
make monitoring       # Monitoring stack only

# Check status
make status

# View logs
make logs
make logs-follow      # Real-time logs

# Backup
make backup

# Restore
make restore BACKUP_TIMESTAMP=20240120-123456
```

### Advanced Operations

```bash
# Dry run (preview changes)
make deploy DRY_RUN=yes

# Skip specific steps
make deploy SKIP_KEYGEN=true SKIP_MONGODB=true

# Use specific inventory
make deploy INVENTORY=inventories/staging/hosts.yml

# Rolling upgrade
make upgrade VERSION=v0.0.2

# Emergency stop
make stop-cluster

# Clean data (DANGEROUS!)
make clean-data
```

### Maintenance Commands

```bash
# Validate configuration
make validate

# Run security checks
./scripts/security-check.sh

# Update dependencies
make update-deps

# Clean temporary files
make clean

# Deep clean (removes venv)
make clean-all
```

## ðŸ”’ Security

### Security Best Practices

1. **SSH Keys**
   - Use dedicated keys for each environment
   - Set proper permissions (600) on all key files
   - Never commit keys to version control

2. **Ansible Vault**
   - Always encrypt sensitive variables
   - Use strong vault passwords
   - Store vault password securely

3. **Network Security**
   - Use bastion hosts for access
   - Configure firewall rules
   - Enable MongoDB authentication
   - Use TLS for API endpoints

4. **Operational Security**
   - Regular security audits
   - Keep dependencies updated
   - Monitor access logs
   - Implement least privilege

### Security Checklist

Run the security check script:

```bash
./scripts/security-check.sh
```

This will verify:
- SSH key permissions
- Vault encryption status
- Firewall configuration
- MongoDB authentication
- SSL/TLS settings

## ðŸ“Š Monitoring

### Prometheus & Grafana

The deployment includes optional monitoring with:
- **Prometheus**: Metrics collection
- **Grafana**: Visualization dashboards
- **Node Exporter**: System metrics
- **Custom Mitum metrics**: Blockchain-specific monitoring

Enable monitoring:

```yaml
# inventories/production/group_vars/all.yml
mitum_monitoring:
  enabled: true
  prometheus:
    enabled: true
    retention: "30d"
```

Access dashboards:
- Prometheus: http://monitoring-server:9090
- Grafana: http://monitoring-server:3000

### Health Checks

Automated health checks run every 5 minutes:
- Node connectivity
- Consensus participation
- Block synchronization
- MongoDB replication status

## ðŸ”§ Troubleshooting

### Common Issues

#### 1. SSH Connection Issues
```bash
# Test SSH connectivity
ssh -F inventories/production/ssh_config bastion
ssh -F inventories/production/ssh_config node0

# Debug Ansible connection
ansible -i inventories/production/hosts.yml all -m ping -vvv
```

#### 2. MongoDB Connection Issues
```bash
# Check MongoDB status
make exec CMD="systemctl status mongod"

# Test MongoDB connection
make exec CMD="mongosh --eval 'db.adminCommand({ping: 1})'"
```

#### 3. Mitum Service Issues
```bash
# Check service status
make status

# View detailed logs
make logs

# Restart specific node
make restart-node NODE=node0
```

#### 4. Key Generation Issues
```bash
# Verify Node.js installation
node --version
npm --version

# Regenerate keys
make keygen FORCE=true
```

### Debug Mode

Enable verbose output:

```bash
# Ansible verbose mode
make deploy VERBOSE=true

# Debug specific task
ansible-playbook -i inventories/production/hosts.yml \
                 playbooks/site.yml \
                 --tags keygen \
                 -vvv
```

### Recovery Procedures

#### Node Recovery
```bash
# Automatic recovery
make recover NODE=node0

# Manual recovery
make stop-node NODE=node0
make clean-node-data NODE=node0
make start-node NODE=node0
```

#### Cluster Recovery
```bash
# From backup
make restore BACKUP_TIMESTAMP=20240120-123456

# Full reset
make clean-cluster
make deploy
```

## ðŸ¤ Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

### Development Setup

```bash
# Clone repository
git clone https://github.com/your-repo/mitum-ansible.git
cd mitum-ansible

# Create development environment
make dev-env

# Run tests
make test-playbooks

# Lint code
make lint
```

### Pull Request Process

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## ðŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ðŸ™ Acknowledgments

- [Mitum Blockchain](https://github.com/ProtoconNet/mitum-currency)
- [Ansible Documentation](https://docs.ansible.com/)
- [MitumJS SDK](https://github.com/ProtoconNet/mitumjs)

## ðŸ“ž Support

- **Documentation**: [Wiki](https://github.com/your-repo/mitum-ansible/wiki)
- **Issues**: [GitHub Issues](https://github.com/your-repo/mitum-ansible/issues)
- **Discussions**: [GitHub Discussions](https://github.com/your-repo/mitum-ansible/discussions)
- **Email**: support@your-domain.com

---

Made with â¤ï¸ by the Mitum Team

## ðŸŽ® Usage Guide

### Available Commands

The project provides multiple ways to deploy and manage Mitum networks:

#### ðŸš€ Deployment Commands

```bash
# Full deployment (recommended)
make deploy ENV=production

# Quick deployment with defaults
make quick-deploy ENV=development

# Deploy specific components only
make deploy ENV=staging --tags keygen,configure
make deploy ENV=staging --tags mongodb,monitoring

# Dry run (preview changes without applying)
make deploy ENV=production DRY_RUN=yes
```

#### ðŸ”§ Management Commands

```bash
# Check node status
make status ENV=production

# View live dashboard
make dashboard ENV=production

# Real-time monitoring
./scripts/visual-status.sh --monitor

# View logs
make logs ENV=production

# Test connectivity
make test ENV=production
```

#### ðŸ’¾ Backup & Recovery

```bash
# Create full backup
make backup ENV=production

# Create backup with custom name
make backup ENV=production BACKUP_NAME="pre-upgrade-backup"

# List available backups
make backup-list ENV=production

# Restore from latest backup
make restore ENV=production

# Restore from specific backup
make restore ENV=production BACKUP_TIMESTAMP=20241225-120000
```

#### ðŸ”„ Upgrades & Maintenance

```bash
# Rolling upgrade (zero downtime)
make upgrade ENV=production VERSION=v1.2.3

# System maintenance
make clean ENV=production
make optimize ENV=production

# Security audit
make security-scan
```

### Script-Based Operations

#### Interactive Setup
```bash
# Guided setup for beginners
./scripts/interactive-setup.sh

# Features:
# - Environment selection
# - Node configuration
# - SSH key generation
# - Inventory creation
# - Validation
```

#### Advanced Deployment
```bash
# Full control deployment
./scripts/deploy-mitum.sh --interactive

# Automated deployment
./scripts/deploy-mitum.sh \
  --environment production \
  --network-id mainnet \
  --node-count 5 \
  --model mitum-currency

# With monitoring and backup
./scripts/deploy-mitum.sh \
  --environment production \
  --enable-monitoring \
  --enable-backup \
  --slack-webhook https://hooks.slack.com/...
```

#### Key Management
```bash
# Generate new keys
./scripts/manage-keys.sh --generate --environment production

# Rotate keys
./scripts/manage-keys.sh --rotate --environment production

# Backup keys
./scripts/manage-keys.sh --backup --environment production

# Verify key integrity
./scripts/manage-keys.sh --verify --environment production
```

#### System Management
```bash
# Generate inventory
./scripts/generate-inventory.sh \
  --bastion-ip 52.74.123.45 \
  --node-ips 10.0.1.10,10.0.1.11,10.0.1.12 \
  --environment production \
  --network-id mainnet

# Generate variables
./scripts/generate-group-vars.sh \
  --environment production \
  --model mitum-currency \
  --enable-features api,digest,metrics

# Setup SSH connection pooling
./scripts/ssh-pool.sh --setup --environment production
```

## ðŸ“Š Monitoring & Alerting

### Built-in Monitoring Stack

The project includes a comprehensive monitoring solution:

```bash
# Deploy monitoring stack
ansible-playbook -i inventories/production/hosts.yml \
  playbooks/setup-monitoring-alerts.yml

# Access monitoring services
# Prometheus: http://monitoring-host:9090
# Grafana: http://monitoring-host:3000
# AlertManager: http://monitoring-host:9093
```

### Available Dashboards

1. **Mitum Network Overview**
   - Node status and health
   - Block height progress
   - Transaction throughput
   - Network consensus status

2. **System Resources**
   - CPU, Memory, Disk usage
   - Network I/O
   - Process monitoring

3. **Application Metrics**
   - API response times
   - Database performance
   - Error rates and logs

### Alert Configuration

```yaml
# Custom alerts (in group_vars)
monitoring_alerts:
  node_down:
    enabled: true
    threshold: "5m"
    severity: "critical"
  
  block_height_stalled:
    enabled: true
    threshold: "10m"
    severity: "warning"
  
  high_memory_usage:
    enabled: true
    threshold: "85%"
    severity: "warning"
  
  disk_space_low:
    enabled: true
    threshold: "15%"
    severity: "warning"
```

### Notification Channels

```yaml
# Slack integration
slack_webhook_url: "https://hooks.slack.com/services/..."
slack_channel: "#mitum-alerts"

# PagerDuty integration
pagerduty_service_key: "your-service-key"

# Email notifications
smtp_server: "smtp.gmail.com"
smtp_port: 587
alert_email: "ops@yourcompany.com"
```

## ðŸ“š API Reference

### Makefile Targets

| Command | Description | Environment | Options |
|---------|-------------|-------------|---------|
| `make help` | Show all available commands | Any | - |
| `make setup` | Initial environment setup | Any | - |
| `make test` | Test connectivity to nodes | Any | `ENV=<env>` |
| `make deploy` | Full Mitum deployment | Any | `ENV=<env>`, `DRY_RUN=yes` |
| `make status` | Check node status | Any | `ENV=<env>` |
| `make logs` | View logs | Any | `ENV=<env>`, `LINES=100` |
| `make backup` | Create backup | Any | `ENV=<env>`, `BACKUP_NAME=<name>` |
| `make restore` | Restore from backup | Any | `ENV=<env>`, `BACKUP_TIMESTAMP=<time>` |
| `make upgrade` | Rolling upgrade | Any | `ENV=<env>`, `VERSION=<version>` |
| `make clean` | Clean temporary files | Any | - |
| `make optimize` | Optimize project | Any | - |
| `make dashboard` | Open visual dashboard | Any | `ENV=<env>` |
| `make interactive-setup` | Interactive setup wizard | Any | - |

### Environment Variables

| Variable | Description | Default | Options |
|----------|-------------|---------|---------|
| `ENV` | Target environment | `production` | `development`, `staging`, `production` |
| `DRY_RUN` | Preview mode | `no` | `yes`, `no` |
| `SAFE_MODE` | Safety checks | `yes` | `yes`, `no` |
| `PARALLEL_FORKS` | Parallel execution | `50` | `1-100` |
| `USE_VAULT` | Ansible Vault | `yes` | `yes`, `no` |

### Script Parameters

#### deploy-mitum.sh
```bash
./scripts/deploy-mitum.sh [OPTIONS]

Options:
  -e, --environment ENV     Target environment (development|staging|production)
  -n, --network-id ID       Network identifier (default: testnet)
  -c, --node-count NUM      Number of nodes to deploy (default: 3)
  -m, --model TYPE         Mitum model type (mitum-currency|mitum-document)
  -i, --interactive        Interactive mode
  -d, --dry-run           Preview mode only
  -v, --verbose           Verbose output
  -h, --help              Show help message
```

#### interactive-setup.sh
```bash
./scripts/interactive-setup.sh [OPTIONS]

Options:
  --skip-validation       Skip requirement validation
  --auto-keys            Auto-generate SSH keys
  --default-config       Use default configurations
  --quiet                Minimal output
```

#### visual-status.sh
```bash
./scripts/visual-status.sh [OPTIONS]

Options:
  -m, --monitor          Real-time monitoring mode
  -e, --environment ENV   Target environment
  -r, --refresh SECONDS  Refresh interval (default: 5)
  -o, --output FORMAT    Output format (table|json|yaml)
```

### Configuration Variables

#### Core Variables (group_vars/all.yml)
```yaml
# Environment configuration
mitum_environment: "production"
mitum_network_id: "mainnet"
mitum_model_type: "mitum-currency"
mitum_version: "latest"

# Network settings
mitum_api_port: 54320
mitum_node_port: 4320
mitum_metrics_port: 9090

# Resource limits
mitum_memory_limit: "4G"
mitum_cpu_limit: "2"
mitum_disk_space: "100G"

# Feature flags
mitum_features:
  enable_api: true
  enable_digest: true
  enable_metrics: true
  enable_profiler: false
  enable_monitoring: true
  enable_backup: true
```

#### Security Variables (group_vars/vault.yml)
```yaml
# MongoDB credentials
mongodb_admin_password: "secure_password"
mongodb_replica_key: "replica_key"

# SSL certificates
ssl_private_key: "certificate_content"
ssl_certificate: "certificate_content"

# API keys
monitoring_api_key: "monitoring_key"
backup_encryption_key: "backup_key"
```

## ðŸ”§ Advanced Features

### 1. Multi-Environment Management

```bash
# Development environment
make deploy ENV=development
# - 1-3 nodes
# - Minimal monitoring
# - Fast deployment

# Staging environment  
make deploy ENV=staging
# - 3-5 nodes
# - Full monitoring
# - Production-like setup

# Production environment
make deploy ENV=production
# - 5+ nodes
# - Full security
# - High availability
```

### 2. Custom Deployment Phases

```bash
# Deploy only system preparation
make deploy ENV=production --tags prepare

# Deploy only key generation
make deploy ENV=production --tags keygen

# Deploy only configuration
make deploy ENV=production --tags configure

# Deploy only monitoring
make deploy ENV=production --tags monitoring
```

### 3. Rolling Upgrades

```bash
# Upgrade with automatic rollback
make upgrade ENV=production VERSION=v1.2.3

# Upgrade specific nodes only
ansible-playbook -i inventories/production/hosts.yml \
  playbooks/rolling-upgrade.yml \
  --limit node0,node1

# Manual upgrade control
ansible-playbook -i inventories/production/hosts.yml \
  playbooks/rolling-upgrade.yml \
  --step
```

### 4. Disaster Recovery

```bash
# Full system backup
make backup ENV=production BACKUP_TYPE=full

# Incremental backup
make backup ENV=production BACKUP_TYPE=incremental

# Database-only backup
make backup ENV=production BACKUP_TYPE=database

# Recovery procedures
make restore ENV=production RESTORE_TYPE=full
make restore ENV=production RESTORE_TYPE=database
```

### 5. Security Hardening

```bash
# Security audit
make security-scan

# Apply security policies
ansible-playbook -i inventories/production/hosts.yml \
  playbooks/security-hardening.yml

# Certificate management
./scripts/manage-keys.sh --rotate-certs --environment production
```

## ðŸ”„ CI/CD Integration

### GitHub Actions

The project includes GitHub Actions workflows:

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline
on: [push, pull_request]
jobs:
  - lint: Ansible and YAML linting
  - test: Molecule testing
  - security: Security scanning
  - deploy: Automated deployment
```

### GitLab CI

GitLab CI configuration available:

```yaml
# .gitlab-ci.yml
stages: [validate, test, security, deploy, notify]
- Comprehensive validation
- Multi-scenario testing
- Security scanning
- Environment-specific deployment
```

### Manual Integration

```bash
# Run CI/CD locally
make validate          # Syntax validation
make test-all          # Full test suite
make security-scan     # Security audit
make deploy-test       # Test deployment
```

================================================================================
íŒŒì¼: TROUBLESHOOTING.md
================================================================================
# ðŸ†˜ Mitum Ansible ë¬¸ì œ í•´ê²° ê°€ì´ë“œ

## ëª©ì°¨
- [ì¼ë°˜ì ì¸ ë¬¸ì œ](#ì¼ë°˜ì ì¸-ë¬¸ì œ)
- [ì—°ê²° ë¬¸ì œ](#ì—°ê²°-ë¬¸ì œ)
- [ë°°í¬ ë¬¸ì œ](#ë°°í¬-ë¬¸ì œ)
- [ë…¸ë“œ ë¬¸ì œ](#ë…¸ë“œ-ë¬¸ì œ)
- [ì„±ëŠ¥ ë¬¸ì œ](#ì„±ëŠ¥-ë¬¸ì œ)
- [ë””ë²„ê¹… ë„êµ¬](#ë””ë²„ê¹…-ë„êµ¬)

## ì¼ë°˜ì ì¸ ë¬¸ì œ

### Python ë²„ì „ ì˜¤ë¥˜
**ì¦ìƒ**: `Python 3.8 or higher is required`

**í•´ê²°ë°©ë²•**:
```bash
# í˜„ìž¬ Python ë²„ì „ í™•ì¸
python3 --version

# macOSì—ì„œ Python 3.9 ì„¤ì¹˜
brew install python@3.9

# Ubuntu/Debianì—ì„œ Python 3.9 ì„¤ì¹˜
sudo apt update
sudo apt install python3.9 python3.9-venv
```

### Ansible ì„¤ì¹˜ ì‹¤íŒ¨
**ì¦ìƒ**: `ansible: command not found`

**í•´ê²°ë°©ë²•**:
```bash
# ê°€ìƒí™˜ê²½ ìž¬ìƒì„±
rm -rf venv
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

## ì—°ê²° ë¬¸ì œ

### SSH ì—°ê²° ì‹¤íŒ¨
**ì¦ìƒ**: `Permission denied (publickey)`

**í•´ê²°ë°©ë²•**:
1. SSH í‚¤ ê¶Œí•œ í™•ì¸:
```bash
chmod 600 keys/ssh/*/mitum_key
chmod 644 keys/ssh/*/mitum_key.pub
```

2. SSH ì—ì´ì „íŠ¸ í™•ì¸:
```bash
eval $(ssh-agent)
ssh-add keys/ssh/production/mitum_key
```

3. ì—°ê²° í…ŒìŠ¤íŠ¸:
```bash
ansible all -m ping -i inventories/production/hosts.yml -vvv
```

### í˜¸ìŠ¤íŠ¸ í‚¤ ê²€ì¦ ì‹¤íŒ¨
**ì¦ìƒ**: `Host key verification failed`

**í•´ê²°ë°©ë²•**:
```bash
# ìž„ì‹œ í•´ê²° (ê°œë°œ í™˜ê²½ë§Œ)
export ANSIBLE_HOST_KEY_CHECKING=False

# ì˜êµ¬ í•´ê²°
ssh-keyscan -H <host-ip> >> ~/.ssh/known_hosts
```

## ë°°í¬ ë¬¸ì œ

### íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨
**ì¦ìƒ**: `Package not found` ë˜ëŠ” `Unable to install package`

**í•´ê²°ë°©ë²•**:
```bash
# íŒ¨í‚¤ì§€ ìºì‹œ ì—…ë°ì´íŠ¸
ansible all -m apt -a "update_cache=yes" -b

# ìˆ˜ë™ìœ¼ë¡œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
ansible all -m apt -a "name=python3-pip state=present" -b
```

### ê¶Œí•œ ì˜¤ë¥˜
**ì¦ìƒ**: `Permission denied` ë˜ëŠ” `sudo: password required`

**í•´ê²°ë°©ë²•**:
1. sudo ê¶Œí•œ ì„¤ì •:
```bash
# ë¹„ë°€ë²ˆí˜¸ ìž…ë ¥ ë°©ì‹
ansible-playbook playbooks/deploy-mitum.yml --ask-become-pass

# ë˜ëŠ” sudoers ì„¤ì • (í”„ë¡œë•ì…˜ ê¶Œìž¥)
echo "ubuntu ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/ubuntu
```

## ë…¸ë“œ ë¬¸ì œ

### Mitum ì„œë¹„ìŠ¤ ì‹œìž‘ ì‹¤íŒ¨
**ì¦ìƒ**: `mitum.service failed to start`

**í•´ê²°ë°©ë²•**:
1. ë¡œê·¸ í™•ì¸:
```bash
# ì„œë¹„ìŠ¤ ë¡œê·¸
ansible node0 -m shell -a "journalctl -u mitum -n 100"

# Mitum ë¡œê·¸
ansible node0 -m shell -a "tail -100 /opt/mitum/logs/mitum.log"
```

2. ì„¤ì • íŒŒì¼ ê²€ì¦:
```bash
# ì„¤ì • íŒŒì¼ ë¬¸ë²• ê²€ì‚¬
ansible node0 -m shell -a "mitum node info /opt/mitum/config/node.yml"
```

### ë…¸ë“œ ë™ê¸°í™” ì‹¤íŒ¨
**ì¦ìƒ**: ë¸”ë¡ ë†’ì´ê°€ ì¦ê°€í•˜ì§€ ì•ŠìŒ

**í•´ê²°ë°©ë²•**:
```bash
# ë…¸ë“œ ìƒíƒœ í™•ì¸
make status

# í”¼ì–´ ì—°ê²° ìƒíƒœ í™•ì¸
ansible mitum_nodes -m shell -a "curl -s http://localhost:54321/node | jq '.suffrage'"

# ë…¸ë“œ ìž¬ì‹œìž‘
ansible mitum_nodes -m service -a "name=mitum state=restarted" -b
```

### MongoDB ì—°ê²° ì‹¤íŒ¨
**ì¦ìƒ**: `MongoDB connection failed`

**í•´ê²°ë°©ë²•**:
```bash
# MongoDB ìƒíƒœ í™•ì¸
ansible mitum_nodes -m service -a "name=mongod state=started" -b

# MongoDB ë¡œê·¸ í™•ì¸
ansible mitum_nodes -m shell -a "tail -50 /var/log/mongodb/mongod.log"

# ë°©í™”ë²½ ê·œì¹™ í™•ì¸
ansible mitum_nodes -m shell -a "sudo ufw status"
```

## ì„±ëŠ¥ ë¬¸ì œ

### ë°°í¬ ì†ë„ê°€ ëŠë¦¼
**í•´ê²°ë°©ë²•**:
```bash
# ë³‘ë ¬ ì²˜ë¦¬ ì¦ê°€
PARALLEL_FORKS=100 make deploy

# SSH ì—°ê²° ìž¬ì‚¬ìš©
echo "ControlMaster auto" >> ~/.ssh/config
echo "ControlPath ~/.ssh/sockets/%r@%h-%p" >> ~/.ssh/config
echo "ControlPersist 600" >> ~/.ssh/config
```

### ë©”ëª¨ë¦¬ ë¶€ì¡±
**ì¦ìƒ**: `Out of memory` ì˜¤ë¥˜

**í•´ê²°ë°©ë²•**:
```bash
# ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
ansible all -m shell -a "free -h"

# ìŠ¤ì™‘ ì¶”ê°€
ansible all -m shell -a "sudo fallocate -l 4G /swapfile && sudo chmod 600 /swapfile && sudo mkswap /swapfile && sudo swapon /swapfile" -b
```

## ë””ë²„ê¹… ë„êµ¬

### ìƒì„¸ ë¡œê·¸ í™œì„±í™”
```bash
# Ansible ë””ë²„ê·¸ ëª¨ë“œ
ANSIBLE_DEBUG=1 ansible-playbook playbooks/site.yml -vvvv

# íŠ¹ì • íƒœìŠ¤í¬ë§Œ ì‹¤í–‰
ansible-playbook playbooks/site.yml --tags "keygen" -vv
```

### ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
```bash
# ì‹œê°ì  ëŒ€ì‹œë³´ë“œ
make dashboard

# ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
make monitor

# ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
ansible mitum_nodes -m shell -a "tail -f /opt/mitum/logs/mitum.log"
```

### ìœ ìš©í•œ ë””ë²„ê¹… ëª…ë ¹ì–´
```bash
# ë³€ìˆ˜ í™•ì¸
ansible all -m debug -a "var=hostvars[inventory_hostname]"

# íŒ©íŠ¸ ìˆ˜ì§‘
ansible all -m setup

# íŠ¹ì • í˜¸ìŠ¤íŠ¸ë§Œ í…ŒìŠ¤íŠ¸
ansible-playbook playbooks/site.yml --limit node0

# ì²´í¬ ëª¨ë“œ (dry-run)
ansible-playbook playbooks/site.yml --check
```

## ì¶”ê°€ ë„ì›€ë§

### ë¡œê·¸ ìœ„ì¹˜
- Ansible ë¡œê·¸: `logs/ansible.log`
- Mitum ë¡œê·¸: `/opt/mitum/logs/mitum.log`
- ì‹œìŠ¤í…œ ë¡œê·¸: `journalctl -u mitum`

### ë°±ì—… ë° ë³µêµ¬
```bash
# ê¸´ê¸‰ ë°±ì—…
make backup

# íŠ¹ì • ì‹œì ìœ¼ë¡œ ë³µì›
make restore BACKUP_TIMESTAMP=20250101-120000
```

### ì§€ì› ìš”ì²­
ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ë‹¤ìŒ ì •ë³´ì™€ í•¨ê»˜ ì´ìŠˆë¥¼ ì œì¶œí•´ì£¼ì„¸ìš”:
1. `ansible --version` ì¶œë ¥
2. `make test` ê²°ê³¼
3. ê´€ë ¨ ë¡œê·¸ íŒŒì¼
4. ì‹¤í–‰í•œ ëª…ë ¹ì–´

---

ðŸ’¡ **íŒ**: ëŒ€ë¶€ë¶„ì˜ ë¬¸ì œëŠ” `make test`ë¡œ ì‚¬ì „ì— ë°œê²¬í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤! 

================================================================================
íŒŒì¼: ansible.cfg
================================================================================
# Mitum Ansible Configuration
# Version: 4.0.0 - Security hardened with better practices
#
# Key improvements:
# 1. Security enhancements - host key checking enabled, privilege escalation improvements
# 2. Performance optimization - connection reuse, parallel processing improvements
# 3. Enhanced logging - detailed log configuration
# 4. Better error handling

[defaults]
# === Basic Settings ===
# Inventory location - can be overridden per environment
inventory = inventories/production/hosts.yml
roles_path = roles
# Collections path added
collections_paths = ./collections

# === Security Settings (Enhanced) ===
# SSH host key verification enabled - security enhancement
host_key_checking = True
# Known hosts file path
ssh_known_hosts_file = ~/.ssh/known_hosts_mitum
# Disable automatic host key addition (manual verification required)
host_key_auto_add = False

# === Execution Settings ===
# Python interpreter auto-detection (no warnings)
interpreter_python = auto_silent
# Retry files disabled
retry_files_enabled = False
# Task execution strategy
strategy = linear
# Parallel processing forks
forks = 50
# Timeout settings
timeout = 30

# === Output Settings ===
# YAML format output (better readability)
stdout_callback = yaml
# Callback plugins enabled
callbacks_enabled = timer, profile_tasks, profile_roles
# Always show diff
display_args_to_stdout = False
display_skipped_hosts = False

# === Logging Settings (New) ===
# Log file path
log_path = ./logs/ansible.log
# Log level (DEBUG, INFO, WARNING, ERROR)
# Production: WARNING, Development: INFO
log_level = INFO

# === Fact Caching Settings ===
# Fact gathering mode
gathering = smart
# Fact cache plugin
fact_caching = jsonfile
# Cache storage location
fact_caching_connection = .ansible_cache
# Cache validity time (24 hours)
fact_caching_timeout = 86400

# === Error Handling ===
# Stop immediately on any error
any_errors_fatal = False
# Failure tolerance percentage
max_fail_percentage = 30
# Ignore unreachable hosts
ignore_unreachable = False

# === Variable Settings ===
# Error on undefined variables
error_on_undefined_vars = True
# Duplicate variable handling (merge, replace)
hash_behaviour = merge

# === Vault Settings (New) ===
# Vault password file auto-usage
vault_password_file = .vault_pass
# Auto-decrypt vault files
vault_decrypt = True

[inventory]
# === Inventory Plugin Settings ===
enable_plugins = host_list, yaml, ini, auto, script, aws_ec2
# Enable inventory caching
cache = True
cache_plugin = jsonfile
cache_connection = .ansible_inventory_cache
cache_timeout = 7200

[ssh_connection]
# === SSH Connection Optimization ===
# SSH pipelining (performance improvement)
pipelining = True
# SSH control path (connection reuse)
control_path = /tmp/ansible-ssh-%%C
# SSH control master settings
ssh_args = -o ControlMaster=auto -o ControlPersist=1800s

# === Additional SSH Options ===
# Retry count
retries = 3
# Connection timeout
timeout = 10
# SSH compression (bandwidth saving)
compression = True

# === Security SSH Options (Enhanced) ===
# Enable StrictHostKeyChecking
ssh_extra_args = -o StrictHostKeyChecking=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3

[persistent_connection]
# === Persistent Connection Settings ===
# Connection timeout
connect_timeout = 30
# Command timeout  
command_timeout = 30
# Connection retry timeout
connect_retry_timeout = 15

[privilege_escalation]
# === Privilege Escalation Settings (Enhanced) ===
# Don't use privilege escalation by default (use only when needed)
become = False
# Privilege escalation method
become_method = sudo
# Target user
become_user = root
# Don't ask for password (SSH key based)
become_ask_pass = False
# sudo flags (security enhanced)
become_flags = -H -S -n

[diff]
# === Diff Display Settings ===
# Always show changes
always = True
# Context lines
context = 3

[colors]
# === Color Settings (Better Readability) ===
# Debug messages
debug = dark_gray
# Warning messages
warn = bright_yellow
# Error messages
error = bright_red
# OK status
ok = bright_green
# Changed status
changed = bright_yellow
# Skipped status
skip = bright_blue
# Unreachable
unreachable = bright_red
# Failed
failed = bright_red

[callback_profile_tasks]
# === Task Profiling Settings ===
# Show top N tasks
task_output_limit = 20
# Sort order (ascending, descending)
sort_order = descending

[callback_timer]
# === Timer Callback Settings ===
# Show task duration
show_task_duration = True
# Show play duration
show_play_duration = True

================================================================================
íŒŒì¼: awx/README.md
================================================================================
# AWX Integration for Mitum Ansible

This directory contains AWX/Tower integration files for enterprise-grade Mitum blockchain management.

## Overview

AWX provides:
- Web-based UI for Ansible playbook execution
- Role-based access control (RBAC)
- Job scheduling and automation
- Real-time job output and logging
- REST API for integration
- Webhook support for event-driven automation

## Directory Structure

```
awx/
â”œâ”€â”€ README.md                    # This file
â”œâ”€â”€ job_templates/              # Job template definitions
â”‚   â”œâ”€â”€ deploy_mitum.json       # Main deployment template
â”‚   â”œâ”€â”€ rolling_upgrade.json    # Zero-downtime upgrade
â”‚   â”œâ”€â”€ health_check.json       # Health validation
â”‚   â””â”€â”€ recovery.json           # Automated recovery
â”œâ”€â”€ workflows/                  # Workflow definitions
â”‚   â””â”€â”€ automated_recovery.json # Recovery workflow
â”œâ”€â”€ surveys/                    # Survey specifications
â”‚   â”œâ”€â”€ deployment_survey.json  # Deployment options
â”‚   â””â”€â”€ upgrade_survey.json     # Upgrade parameters
â””â”€â”€ scripts/                    # Helper scripts
    â””â”€â”€ import_templates.sh     # Import templates to AWX
```

## Prerequisites

1. **AWX Installation**
   - AWX 19.0+ or Ansible Tower 3.8+
   - PostgreSQL database
   - Redis for caching

2. **AWX CLI**
   ```bash
   pip install awxkit
   ```

3. **API Token**
   - Create in AWX UI: Settings â†’ Users â†’ Tokens
   - Export: `export AWX_TOKEN=your-token`

## Setup Instructions

### 1. Configure AWX Connection

```bash
# Set environment variables
export AWX_URL=https://awx.example.com
export AWX_TOKEN=your-token-here

# Test connection
awx config
```

### 2. Create Organization and Team

```bash
# Create organization
awx organizations create \
  --name "Mitum Operations" \
  --description "Mitum blockchain management"

# Create team
awx teams create \
  --name "Mitum Admins" \
  --organization "Mitum Operations"
```

### 3. Import Inventory

```bash
# Create inventory
awx inventories create \
  --name "Mitum Production" \
  --organization "Mitum Operations" \
  --variables @inventories/production/group_vars/all.yml

# Import hosts
awx inventory_sources create \
  --name "Mitum Nodes" \
  --inventory "Mitum Production" \
  --source "scm" \
  --source_path "inventories/production/hosts.yml"
```

### 4. Create Project

```bash
# Create project
awx projects create \
  --name "Mitum Ansible" \
  --organization "Mitum Operations" \
  --scm_type "git" \
  --scm_url "https://github.com/your-org/mitum-ansible.git" \
  --scm_branch "main" \
  --scm_update_on_launch true
```

### 5. Import Job Templates

```bash
# Import all templates
./awx/scripts/import_templates.sh

# Or import individually
awx import < awx/job_templates/deploy_mitum.json
awx import < awx/job_templates/rolling_upgrade.json
awx import < awx/job_templates/health_check.json
awx import < awx/job_templates/recovery.json
```

### 6. Create Workflows

```bash
# Import recovery workflow
awx import < awx/workflows/automated_recovery.json
```

## Job Templates

### Deploy Mitum
- **Purpose**: Full cluster deployment
- **Playbook**: `playbooks/deploy-mitum.yml`
- **Survey**: Deployment options (node count, network ID)
- **Credentials**: SSH, Vault

### Rolling Upgrade
- **Purpose**: Zero-downtime version upgrade
- **Playbook**: `playbooks/rolling-upgrade.yml`
- **Survey**: Version selection, maintenance window
- **Features**: 
  - Pre-flight checks
  - Sequential consensus node updates
  - API node maintenance mode

### Health Check
- **Purpose**: Cluster validation
- **Playbook**: `playbooks/validate.yml`
- **Schedule**: Every 5 minutes
- **Notifications**: Slack, email on failure

### Recovery
- **Purpose**: Automated node recovery
- **Playbook**: `playbooks/recovery.yml`
- **Trigger**: Webhook from monitoring
- **Actions**: Restart, resync, or full recovery

## Workflows

### Automated Recovery Workflow

```
Prometheus Alert
    â†“
Health Check Job
    â†“
[Success] â† â†’ [Failure]
              â†“
         Recovery Job
              â†“
    [Success] â† â†’ [Failure]
                     â†“
              Escalation
```

## Webhook Integration

### Configure Prometheus Alertmanager

```yaml
# alertmanager.yml
receivers:
  - name: 'awx-webhook'
    webhook_configs:
      - url: 'https://awx.example.com/api/v2/job_templates/123/launch/'
        http_config:
          bearer_token: 'your-awx-token'
```

### Webhook Payload

```json
{
  "extra_vars": {
    "alert_name": "{{ .GroupLabels.alertname }}",
    "node_name": "{{ .Labels.instance }}",
    "severity": "{{ .Labels.severity }}",
    "recovery_action": "auto"
  }
}
```

## Survey Examples

### Deployment Survey

```json
{
  "name": "Deployment Options",
  "spec": [
    {
      "question_name": "Network ID",
      "variable": "mitum_network_id",
      "type": "text",
      "default": "mitum",
      "required": true
    },
    {
      "question_name": "Node Count",
      "variable": "node_count",
      "type": "integer",
      "min": 3,
      "max": 100,
      "default": 5
    }
  ]
}
```

## Monitoring Dashboard

AWX provides built-in dashboards for:
- Job success/failure rates
- Average job duration
- Resource utilization
- User activity

### Custom Dashboard Queries

```sql
-- Failed jobs in last 24 hours
SELECT count(*) 
FROM main_job 
WHERE status = 'failed' 
  AND created > NOW() - INTERVAL '24 hours';

-- Average deployment time
SELECT AVG(EXTRACT(EPOCH FROM (finished - created))) as avg_seconds
FROM main_job
WHERE job_template_id = 123
  AND status = 'successful';
```

## Best Practices

1. **Use Surveys**: Make templates reusable with survey variables
2. **Set Timeouts**: Configure appropriate job timeouts
3. **Enable Notifications**: Set up alerts for critical jobs
4. **Version Control**: Store all AWX configurations in Git
5. **RBAC**: Implement proper role-based access
6. **Backup**: Regular AWX database backups
7. **Monitoring**: Integrate AWX metrics with Prometheus

## Troubleshooting

### Common Issues

1. **Job Stuck in Pending**
   - Check available capacity
   - Verify instance groups
   - Check resource limits

2. **Inventory Sync Failures**
   - Verify SCM credentials
   - Check network connectivity
   - Review source format

3. **Webhook Not Triggering**
   - Verify token permissions
   - Check webhook URL
   - Review AWX logs

### Debug Commands

```bash
# Check job output
awx jobs get <job_id>
awx jobs stdout <job_id>

# List failed jobs
awx jobs list --status failed

# Check capacity
awx instances list
```

## API Examples

### Launch Job via API

```bash
# Launch deployment
curl -X POST https://awx.example.com/api/v2/job_templates/123/launch/ \
  -H "Authorization: Bearer $AWX_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "extra_vars": {
      "mitum_network_id": "mainnet",
      "node_count": 5
    }
  }'
```

### Monitor Job Status

```python
import requests
import time

def monitor_job(job_id, token):
    headers = {'Authorization': f'Bearer {token}'}
    
    while True:
        r = requests.get(
            f'https://awx.example.com/api/v2/jobs/{job_id}/',
            headers=headers
        )
        job = r.json()
        
        print(f"Status: {job['status']}")
        
        if job['status'] in ['successful', 'failed', 'error', 'canceled']:
            break
            
        time.sleep(5)
    
    return job['status']
```

## Support

- AWX Documentation: https://docs.ansible.com/awx/
- AWX GitHub: https://github.com/ansible/awx
- Community: https://groups.google.com/g/awx-project

================================================================================
íŒŒì¼: awx/credentials/mitum_credentials.md
================================================================================
# AWX Credentials Setup for Mitum

## Required Credentials

### 1. Mitum SSH Credential
- **Type**: Machine
- **Name**: Mitum SSH
- **Username**: ubuntu (or your SSH user)
- **SSH Private Key**: Your node access key
- **Privilege Escalation Method**: sudo
- **Privilege Escalation Username**: root

### 2. Bastion SSH Credential
- **Type**: Machine
- **Name**: Bastion SSH
- **Username**: ubuntu
- **SSH Private Key**: Your bastion key
- **SSH Private Key Passphrase**: (if applicable)

### 3. Mitum Vault Credential
- **Type**: Vault
- **Name**: Mitum Vault
- **Vault Password**: Your ansible vault password
- **Vault Identifier**: (optional)

### 4. MongoDB Credential
- **Type**: Custom Credential Type**
- **Name**: MongoDB Admin
- **Fields**:
  - mongodb_admin_user
  - mongodb_admin_password
  - mongodb_user
  - mongodb_password

### 5. AWX API Credential
- **Type**: Custom Credential Type**
- **Name**: AWX API
- **Fields**:
  - awx_url
  - awx_token

### 6. Monitoring Credential
- **Type**: Custom Credential Type**
- **Name**: Prometheus
- **Fields**:
  - prometheus_url
  - grafana_admin_password

## Custom Credential Type Definition

### MongoDB Credential Type
```yaml
fields:
  - id: mongodb_admin_user
    type: string
    label: MongoDB Admin Username
  - id: mongodb_admin_password
    type: string
    label: MongoDB Admin Password
    secret: true
  - id: mongodb_user
    type: string
    label: MongoDB User
  - id: mongodb_password
    type: string
    label: MongoDB Password
    secret: true
required:
  - mongodb_admin_user
  - mongodb_admin_password
injectors:
  extra_vars:
    mongodb_admin_user: '{{ mongodb_admin_user }}'
    mongodb_admin_password: '{{ mongodb_admin_password }}'
    mongodb_user: '{{ mongodb_user }}'
    mongodb_password: '{{ mongodb_password }}'
```

### AWX API Credential Type
```yaml
fields:
  - id: awx_url
    type: string
    label: AWX URL
  - id: awx_token
    type: string
    label: AWX Token
    secret: true
required:
  - awx_url
  - awx_token
injectors:
  env:
    AWX_URL: '{{ awx_url }}'
    AWX_TOKEN: '{{ awx_token }}'
```

## Setup Instructions

1. Create Custom Credential Types first
2. Create individual credentials
3. Attach to Job Templates as needed
4. Test with a simple ping job

## Security Best Practices

1. Use different SSH keys for bastion and nodes
2. Rotate credentials regularly
3. Use AWX RBAC to limit access
4. Enable credential rotation
5. Audit credential usage

================================================================================
íŒŒì¼: awx/inventories/dynamic_inventory.py
================================================================================
#!/usr/bin/env python3
"""
Dynamic inventory script for AWX to discover Mitum nodes from Prometheus
"""

import json
import os
import sys
import requests
from urllib.parse import urljoin

class MitumInventory:
    def __init__(self):
        self.inventory = {}
        self.read_cli_args()
        
        # Configuration from environment
        self.prometheus_url = os.environ.get('PROMETHEUS_URL', 'http://prometheus:9090')
        self.network_id = os.environ.get('MITUM_NETWORK_ID', 'mainnet')
        
        # Generate inventory
        if self.args.list:
            self.inventory = self.get_inventory()
        elif self.args.host:
            self.inventory = self.get_host_info(self.args.host)
        else:
            self.inventory = self.empty_inventory()
        
        print(json.dumps(self.inventory))
    
    def get_inventory(self):
        inventory = {
            'mitum_nodes': {
                'hosts': [],
                'vars': {
                    'mitum_network_id': self.network_id,
                    'ansible_ssh_common_args': '-o ProxyCommand="ssh -W %h:%p bastion"'
                }
            },
            '_meta': {
                'hostvars': {}
            }
        }
        
        # Query Prometheus for active nodes
        try:
            response = requests.get(
                urljoin(self.prometheus_url, '/api/v1/query'),
                params={'query': 'up{job="mitum"}'}
            )
            data = response.json()
            
            if data['status'] == 'success':
                for result in data['data']['result']:
                    metric = result['metric']
                    value = result['value'][1]
                    
                    if value == '1':  # Node is up
                        hostname = metric.get('instance', '').split(':')[0]
                        node_type = metric.get('node_type', 'consensus')
                        
                        # Add to hosts
                        inventory['mitum_nodes']['hosts'].append(hostname)
                        
                        # Add host variables
                        inventory['_meta']['hostvars'][hostname] = {
                            'ansible_host': hostname,
                            'mitum_node_type': node_type,
                            'mitum_api_enabled': node_type == 'api',
                            'mitum_metrics_endpoint': f"http://{hostname}:9099/metrics"
                        }
        except Exception as e:
            sys.stderr.write(f"Error querying Prometheus: {e}\n")
        
        return inventory
    
    def get_host_info(self, host):
        """Get variables for a specific host"""
        return self.get_inventory()['_meta']['hostvars'].get(host, {})
    
    def empty_inventory(self):
        return {'_meta': {'hostvars': {}}}
    
    def read_cli_args(self):
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('--list', action='store_true')
        parser.add_argument('--host', action='store')
        self.args = parser.parse_args()

if __name__ == '__main__':
    MitumInventory()

================================================================================
íŒŒì¼: awx/surveys/deployment_survey.json
================================================================================
{
  "name": "Mitum Deployment Configuration",
  "description": "Configure parameters for Mitum blockchain deployment",
  "spec": [
    {
      "question_name": "Deployment Type",
      "question_description": "Choose the type of deployment",
      "required": true,
      "type": "multiplechoice",
      "variable": "deployment_type",
      "default": "new",
      "choices": [
        "new",
        "upgrade",
        "expansion",
        "migration"
      ]
    },
    {
      "question_name": "Network Configuration",
      "question_description": "Network topology and size",
      "required": true,
      "type": "textarea",
      "variable": "network_config",
      "default": "nodes: 5\nconsensus: 4\napi: 1",
      "min": 10,
      "max": 1000
    },
    {
      "question_name": "Node Specifications",
      "question_description": "Hardware requirements per node",
      "required": true,
      "type": "multiplechoice",
      "variable": "node_specs",
      "default": "standard",
      "choices": [
        {
          "key": "minimal",
          "value": "Minimal (2 CPU, 4GB RAM)"
        },
        {
          "key": "standard",
          "value": "Standard (4 CPU, 8GB RAM)"
        },
        {
          "key": "performance",
          "value": "Performance (8 CPU, 16GB RAM)"
        },
        {
          "key": "enterprise",
          "value": "Enterprise (16 CPU, 32GB RAM)"
        }
      ]
    },
    {
      "question_name": "Storage Configuration",
      "question_description": "Storage backend and size",
      "required": true,
      "type": "multiselect",
      "variable": "storage_config",
      "default": ["ssd", "backup"],
      "choices": [
        "ssd",
        "nvme",
        "backup",
        "archive",
        "redundant"
      ]
    },
    {
      "question_name": "Security Options",
      "question_description": "Security features to enable",
      "required": false,
      "type": "multiselect",
      "variable": "security_options",
      "default": ["firewall", "ssl"],
      "choices": [
        "firewall",
        "ssl",
        "api_auth",
        "key_rotation",
        "audit_logging",
        "encryption_at_rest"
      ]
    },
    {
      "question_name": "Genesis Configuration",
      "question_description": "Initial blockchain parameters (JSON)",
      "required": true,
      "type": "textarea",
      "variable": "genesis_config",
      "default": "{\n  \"currencies\": [{\n    \"currency\": \"MCC\",\n    \"total_supply\": \"1000000000\"\n  }]\n}",
      "min": 20,
      "max": 5000
    },
    {
      "question_name": "Backup Strategy",
      "question_description": "Backup configuration",
      "required": true,
      "type": "multiplechoice",
      "variable": "backup_strategy",
      "default": "daily",
      "choices": [
        {
          "key": "none",
          "value": "No backups"
        },
        {
          "key": "daily",
          "value": "Daily backups (7 day retention)"
        },
        {
          "key": "continuous",
          "value": "Continuous replication"
        },
        {
          "key": "custom",
          "value": "Custom schedule"
        }
      ]
    },
    {
      "question_name": "Monitoring Integration",
      "question_description": "Monitoring and alerting configuration",
      "required": true,
      "type": "multiselect",
      "variable": "monitoring_integration",
      "default": ["prometheus", "grafana"],
      "choices": [
        "prometheus",
        "grafana",
        "alertmanager",
        "elasticsearch",
        "datadog",
        "newrelic"
      ]
    },
    {
      "question_name": "Notification Channels",
      "question_description": "Where to send alerts and notifications",
      "required": false,
      "type": "multiselect",
      "variable": "notification_channels",
      "default": ["slack"],
      "choices": [
        "email",
        "slack",
        "pagerduty",
        "webhook",
        "sms"
      ]
    },
    {
      "question_name": "Maintenance Window",
      "question_description": "Preferred maintenance window (UTC)",
      "required": false,
      "type": "text",
      "variable": "maintenance_window",
      "default": "Sunday 02:00-06:00",
      "min": 5,
      "max": 50
    },
    {
      "question_name": "Additional Variables",
      "question_description": "Additional Ansible variables (YAML format)",
      "required": false,
      "type": "textarea",
      "variable": "additional_vars",
      "default": "# Example:\n# custom_parameter: value",
      "min": 0,
      "max": 2000
    }
  ]
}

================================================================================
íŒŒì¼: awx/surveys/upgrade_survey.json
================================================================================
{
  "name": "Mitum Rolling Upgrade Configuration",
  "description": "Configure parameters for zero-downtime Mitum upgrade",
  "spec": [
    {
      "question_name": "Target Version",
      "question_description": "Mitum version to upgrade to",
      "required": true,
      "type": "text",
      "variable": "mitum_version",
      "min": 1,
      "max": 20,
      "default": "latest"
    },
    {
      "question_name": "Upgrade Strategy",
      "question_description": "How to perform the upgrade",
      "required": true,
      "type": "multiplechoice",
      "variable": "upgrade_strategy",
      "default": "rolling",
      "choices": [
        {
          "key": "rolling",
          "value": "Rolling (Zero downtime)"
        },
        {
          "key": "canary",
          "value": "Canary (Test on one node first)"
        },
        {
          "key": "blue_green",
          "value": "Blue/Green (Parallel environment)"
        },
        {
          "key": "maintenance",
          "value": "Maintenance window (Downtime allowed)"
        }
      ]
    },
    {
      "question_name": "Batch Size",
      "question_description": "Number of nodes to upgrade simultaneously",
      "required": true,
      "type": "integer",
      "variable": "upgrade_batch_size",
      "min": 1,
      "max": 10,
      "default": 1
    },
    {
      "question_name": "Batch Delay",
      "question_description": "Seconds to wait between batches",
      "required": true,
      "type": "integer",
      "variable": "upgrade_batch_delay",
      "min": 30,
      "max": 600,
      "default": 60
    },
    {
      "question_name": "Pre-upgrade Backup",
      "question_description": "Create backup before upgrade",
      "required": true,
      "type": "multiplechoice",
      "variable": "pre_upgrade_backup",
      "default": "yes",
      "choices": [
        "yes",
        "no"
      ]
    },
    {
      "question_name": "Health Check Timeout",
      "question_description": "Seconds to wait for health check after upgrade",
      "required": true,
      "type": "integer",
      "variable": "health_check_timeout",
      "min": 60,
      "max": 600,
      "default": 300
    },
    {
      "question_name": "Rollback on Failure",
      "question_description": "Automatically rollback if upgrade fails",
      "required": true,
      "type": "multiplechoice",
      "variable": "auto_rollback",
      "default": "yes",
      "choices": [
        "yes",
        "no"
      ]
    },
    {
      "question_name": "API Maintenance Notice",
      "question_description": "Minutes to notify before API node upgrade",
      "required": true,
      "type": "integer",
      "variable": "api_notice_minutes",
      "min": 0,
      "max": 60,
      "default": 30
    },
    {
      "question_name": "Consensus Threshold Check",
      "question_description": "Minimum consensus nodes required during upgrade (%)",
      "required": true,
      "type": "integer",
      "variable": "min_consensus_threshold",
      "min": 51,
      "max": 100,
      "default": 67
    },
    {
      "question_name": "Upgrade Tags",
      "question_description": "Specific components to upgrade",
      "required": false,
      "type": "multiselect",
      "variable": "upgrade_tags",
      "default": ["mitum", "monitoring"],
      "choices": [
        "mitum",
        "mongodb",
        "monitoring",
        "configuration",
        "dependencies"
      ]
    },
    {
      "question_name": "Dry Run",
      "question_description": "Perform a dry run without actual changes",
      "required": true,
      "type": "multiplechoice",
      "variable": "dry_run",
      "default": "no",
      "choices": [
        "yes",
        "no"
      ]
    },
    {
      "question_name": "Notification Recipients",
      "question_description": "Additional email addresses for upgrade notifications",
      "required": false,
      "type": "textarea",
      "variable": "notification_emails",
      "default": "",
      "min": 0,
      "max": 500
    }
  ]
}

================================================================================
íŒŒì¼: awx/workflows/automated_recovery.json
================================================================================
{
  "name": "Mitum Automated Recovery Workflow",
  "description": "Automated recovery workflow triggered by monitoring alerts",
  "organization": "Mitum Operations",
  "inventory": "Mitum Production",
  "limit": "",
  "scm_branch": "",
  "extra_vars": "",
  "survey_enabled": false,
  "allow_simultaneous": false,
  "ask_variables_on_launch": true,
  "ask_inventory_on_launch": false,
  "ask_scm_branch_on_launch": false,
  "ask_limit_on_launch": true,
  "webhook_service": "prometheus",
  "webhook_credential": "Prometheus Webhook Token",
  "notification_templates_started": [
    "Slack Recovery Started"
  ],
  "notification_templates_success": [
    "Slack Recovery Success"
  ],
  "notification_templates_error": [
    "Slack Recovery Failed",
    "PagerDuty Alert"
  ],
  "notification_templates_approvals": [],
  "workflow_nodes": [
    {
      "id": 1,
      "unified_job_template": "Health Check",
      "identifier": "health_check_initial",
      "always_nodes": [],
      "success_nodes": [2],
      "failure_nodes": [3],
      "extra_data": {
        "limit": "{{ alert_node | default('all') }}"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 2,
      "unified_job_template": null,
      "identifier": "recovery_not_needed",
      "always_nodes": [],
      "success_nodes": [],
      "failure_nodes": [],
      "extra_data": {},
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 3,
      "unified_job_template": "Node Recovery",
      "identifier": "recovery_simple",
      "always_nodes": [],
      "success_nodes": [4],
      "failure_nodes": [5],
      "extra_data": {
        "recovery_action": "restart",
        "target_nodes": "{{ alert_node }}",
        "alert_severity": "{{ alert_severity | default('warning') }}"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 4,
      "unified_job_template": "Health Check",
      "identifier": "health_check_verify",
      "always_nodes": [],
      "success_nodes": [6],
      "failure_nodes": [5],
      "extra_data": {
        "limit": "{{ alert_node }}",
        "validation_type": "post_recovery"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 5,
      "unified_job_template": "Node Recovery",
      "identifier": "recovery_advanced",
      "always_nodes": [],
      "success_nodes": [7],
      "failure_nodes": [8],
      "extra_data": {
        "recovery_action": "full",
        "target_nodes": "{{ alert_node }}",
        "include_resync": "true",
        "backup_before_recovery": "true"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 6,
      "unified_job_template": null,
      "identifier": "recovery_successful",
      "always_nodes": [],
      "success_nodes": [],
      "failure_nodes": [],
      "extra_data": {
        "notification": "Recovery completed successfully"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 7,
      "unified_job_template": "Health Check",
      "identifier": "health_check_final",
      "always_nodes": [],
      "success_nodes": [6],
      "failure_nodes": [8],
      "extra_data": {
        "limit": "{{ alert_node }}",
        "validation_type": "final"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    },
    {
      "id": 8,
      "unified_job_template": "Manual Intervention Required",
      "identifier": "escalation",
      "always_nodes": [],
      "success_nodes": [],
      "failure_nodes": [],
      "extra_data": {
        "create_incident": "true",
        "incident_priority": "high",
        "escalation_team": "infrastructure",
        "include_diagnostics": "true"
      },
      "inventory": null,
      "scm_branch": null,
      "job_type": null,
      "job_tags": null,
      "skip_tags": null,
      "all_parents_must_converge": false
    }
  ],
  "labels": [
    "automation",
    "recovery",
    "monitoring",
    "workflow"
  ]
}

================================================================================
íŒŒì¼: awx/workflows/full_deployment.json
================================================================================
{
  "name": "Mitum - Complete Deployment Workflow",
  "description": "End-to-end deployment workflow for Mitum cluster",
  "organization": "Default",
  "survey_enabled": true,
  "allow_simultaneous": false,
  "ask_variables_on_launch": true,
  "inventory": "Mitum Production",
  "limit": "",
  "scm_branch": "",
  "extra_vars": "",
  "survey_spec": {
    "name": "Deployment Parameters",
    "description": "Configure your Mitum deployment",
    "spec": [
      {
        "question_name": "Environment",
        "question_description": "Target environment",
        "required": true,
        "type": "multiplechoice",
        "variable": "target_environment",
        "choices": ["development", "staging", "production"],
        "default": "production"
      },
      {
        "question_name": "Network ID",
        "question_description": "Blockchain network identifier",
        "required": true,
        "type": "text",
        "variable": "mitum_network_id",
        "default": "mainnet"
      }
    ]
  },
  "workflow_nodes": [
    {
      "identifier": "generate_inventory",
      "unified_job_template": "Mitum - Generate Inventory",
      "inventory": null,
      "limit": null,
      "credentials": [],
      "extra_data": {},
      "all_parents_must_converge": false,
      "success_nodes": ["generate_keys"],
      "failure_nodes": ["send_failure_notification"]
    },
    {
      "identifier": "generate_keys",
      "unified_job_template": "Mitum - Generate Keys",
      "success_nodes": ["deploy_infrastructure"],
      "failure_nodes": ["send_failure_notification"]
    },
    {
      "identifier": "deploy_infrastructure",
      "unified_job_template": "Mitum - Deploy Infrastructure",
      "success_nodes": ["configure_monitoring"],
      "failure_nodes": ["rollback"]
    },
    {
      "identifier": "configure_monitoring",
      "unified_job_template": "Mitum - Setup Monitoring",
      "success_nodes": ["health_check"],
      "failure_nodes": ["send_warning"]
    },
    {
      "identifier": "health_check",
      "unified_job_template": "Mitum - Health Check",
      "success_nodes": ["send_success_notification"],
      "failure_nodes": ["send_failure_notification"]
    },
    {
      "identifier": "rollback",
      "unified_job_template": "Mitum - Rollback",
      "success_nodes": ["send_rollback_notification"],
      "failure_nodes": ["send_critical_alert"]
    },
    {
      "identifier": "send_success_notification",
      "unified_job_template": "Send Notification - Success"
    },
    {
      "identifier": "send_failure_notification",
      "unified_job_template": "Send Notification - Failure"
    },
    {
      "identifier": "send_warning",
      "unified_job_template": "Send Notification - Warning"
    },
    {
      "identifier": "send_rollback_notification",
      "unified_job_template": "Send Notification - Rollback"
    },
    {
      "identifier": "send_critical_alert",
      "unified_job_template": "Send Critical Alert"
    }
  ]
}

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/Makefile
================================================================================
# Mitum Ansible Makefile
# Version: 4.0.0 - Enhanced with security, safety, and cross-platform support
# 
# Key improvements:
# 1. Mac/Linux compatibility - Auto OS detection and command branching
# 2. Security enhancements - Vault integration, SSH key verification
# 3. Safety features - Destructive operation protection, dry-run option
# 4. Structure improvements - Centralized variables, better error handling

.PHONY: help setup test keygen deploy status logs backup restore clean upgrade inventory

# === Configuration ===
# Environment variables - defaults and overridable
ENV ?= production
INVENTORY ?= inventories/$(ENV)/hosts.yml
PLAYBOOK_DIR = playbooks
VENV = venv
ANSIBLE = $(VENV)/bin/ansible
ANSIBLE_PLAYBOOK = $(VENV)/bin/ansible-playbook
ANSIBLE_VAULT = $(VENV)/bin/ansible-vault

# OS detection - Mac and Linux differentiation
UNAME := $(shell uname -s)
ifeq ($(UNAME),Darwin)
    OS_TYPE = macos
    PACKAGE_MANAGER = brew
    SERVICE_MANAGER = launchctl
else
    OS_TYPE = linux
    PACKAGE_MANAGER = apt-get
    SERVICE_MANAGER = systemctl
endif

# Security options - enabled by default
STRICT_HOST_KEY_CHECKING ?= yes
USE_VAULT ?= yes
VAULT_PASSWORD_FILE ?= .vault_pass

# Safe mode - additional confirmation for destructive operations
SAFE_MODE ?= yes
DRY_RUN ?= no

# Colors for better UX
GREEN = \033[0;32m
RED = \033[0;31m
YELLOW = \033[1;33m
BLUE = \033[0;34m
NC = \033[0m

# === Helper Functions ===
# Safety confirmation function - used before destructive operations
define confirm_action
	@if [ "$(SAFE_MODE)" = "yes" ]; then \
		echo "$(RED)WARNING: $(1)$(NC)"; \
		echo "$(YELLOW)This action cannot be undone!$(NC)"; \
		read -p "Type 'yes' to confirm: " confirm; \
		if [ "$confirm" != "yes" ]; then \
			echo "$(GREEN)Operation cancelled.$(NC)"; \
			exit 1; \
		fi \
	fi
endef

# Dry run check function
define check_dry_run
	$(if $(filter yes,$(DRY_RUN)),--check)
endef

# Default target
.DEFAULT_GOAL := help

# === Main Targets ===

help: ## Show this help message with categorized commands
	@echo "$(GREEN)Mitum Ansible Automation v4.0.0$(NC)"
	@echo "OS: $(OS_TYPE) | Package Manager: $(PACKAGE_MANAGER)"
	@echo ""
	@echo "$(YELLOW)Quick Start:$(NC)"
	@echo "  $(BLUE)start$(NC)                 Interactive deployment (easiest way)"
	@echo "  $(BLUE)quick-deploy$(NC)          Deploy with minimal configuration"
	@echo ""
	@echo "$(YELLOW)Setup & Configuration:$(NC)"
	@grep -E '^(setup|keys-|inventory).*:.*?## .*$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  $(BLUE)%-20s$(NC) %s\n", $1, $2}'
	@echo ""
	@echo "$(YELLOW)Deployment & Operations:$(NC)"
	@grep -E '^(test|keygen|deploy|status|logs).*:.*?## .*$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  $(BLUE)%-20s$(NC) %s\n", $1, $2}'
	@echo ""
	@echo "$(YELLOW)Maintenance:$(NC)"
	@grep -E '^(backup|restore|upgrade|clean).*:.*?## .*$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  $(BLUE)%-20s$(NC) %s\n", $1, $2}'
	@echo ""
	@echo "$(YELLOW)Options:$(NC)"
	@echo "  ENV=<env>           Target environment (default: production)"
	@echo "  DRY_RUN=yes         Run in check mode without changes"
	@echo "  SAFE_MODE=no        Disable safety confirmations"
	@echo "  USE_VAULT=no        Disable Ansible Vault"

# === Quick Start Targets (New) ===

start: ## Interactive deployment wizard (recommended for beginners)
	@echo "$(GREEN)>>> Starting interactive deployment wizard...$(NC)"
	@if [ ! -f scripts/deploy-mitum.sh ]; then \
		echo "$(RED)Error: deploy-mitum.sh not found$(NC)"; \
		exit 1; \
	fi
	@bash ./scripts/deploy-mitum.sh --interactive

quick-deploy: setup ## Quick deployment with minimal steps
	@echo "$(GREEN)>>> Quick Deployment Mode$(NC)"
	@echo "This will deploy Mitum with default settings."
	@echo ""
	@if [ -z "$(BASTION_IP)" ] || [ -z "$(NODE_IPS)" ]; then \
		echo "$(RED)Error: Required variables missing$(NC)"; \
		echo "Usage: make quick-deploy BASTION_IP=x.x.x.x NODE_IPS=10.0.1.10,10.0.1.11"; \
		exit 1; \
	fi
	@make inventory
	@make test
	@make deploy

# === Setup Commands ===

setup: ## Initial setup with dependency checks
	@echo "$(GREEN)>>> Running enhanced setup for $(OS_TYPE)...$(NC)"
	@if [ ! -f scripts/setup.sh ]; then \
		echo "$(RED)Error: setup.sh not found$(NC)"; \
		exit 1; \
	fi
	@bash ./scripts/setup.sh
	@make setup-vault
	@echo "$(GREEN)âœ“ Setup complete!$(NC)"

setup-vault: ## Setup Ansible Vault for secrets
	@if [ "$(USE_VAULT)" = "yes" ] && [ ! -f "$(VAULT_PASSWORD_FILE)" ]; then \
		echo "$(YELLOW)>>> Setting up Ansible Vault...$(NC)"; \
		echo "Enter a strong password for Ansible Vault:"; \
		read -s vault_pass; \
		echo "$$vault_pass" > $(VAULT_PASSWORD_FILE); \
		chmod 600 $(VAULT_PASSWORD_FILE); \
		echo "$(GREEN)âœ“ Vault password saved to $(VAULT_PASSWORD_FILE)$(NC)"; \
		echo "$(YELLOW)Keep this file safe and add it to .gitignore!$(NC)"; \
	fi

# === Key Management (Enhanced) ===

keys-add: ## Add SSH key with validation
	@if [ -z "$(KEY)" ]; then \
		echo "$(RED)Error: KEY variable required$(NC)"; \
		echo "Usage: make keys-add KEY=~/key.pem NAME=bastion.pem"; \
		exit 1; \
	fi
	@# Validate key format
	@if ! ssh-keygen -l -f $(KEY) > /dev/null 2>&1; then \
		echo "$(RED)Error: Invalid SSH key format$(NC)"; \
		exit 1; \
	fi
	@./scripts/manage-keys.sh add $(ENV) $(KEY) $(NAME)

keys-encrypt: ## Encrypt sensitive keys with Ansible Vault
	@if [ "$(USE_VAULT)" = "yes" ]; then \
		echo "$(YELLOW)>>> Encrypting sensitive files...$(NC)"; \
		find inventories/$(ENV) -name "vault*.yml" -exec \
			$(ANSIBLE_VAULT) encrypt {} --vault-password-file=$(VAULT_PASSWORD_FILE) \; ; \
		echo "$(GREEN)âœ“ Files encrypted$(NC)"; \
	fi

# === Testing (Enhanced) ===

test: activate ## Test connectivity with host key verification
	@echo "$(GREEN)>>> Testing connectivity (secure mode)...$(NC)"
	@# First, gather host keys safely
	@if [ "$(STRICT_HOST_KEY_CHECKING)" = "yes" ]; then \
		echo "$(YELLOW)Gathering SSH host keys...$(NC)"; \
		$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/gather-host-keys.yml \
			$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)); \
	fi
	@$(ANSIBLE) -i $(INVENTORY) all -m ping \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))
	@echo "$(GREEN)âœ“ All hosts accessible$(NC)"

test-check: activate ## Dry run connectivity test
	@$(ANSIBLE) -i $(INVENTORY) all -m ping --check

# === Deployment (Enhanced with safety) ===

deploy: activate pre-deploy-check ## Full deployment with safety checks
	@echo "$(GREEN)>>> Starting safe deployment...$(NC)"
	@# Create pre-deployment snapshot
	@make backup BACKUP_TYPE=pre-deploy
	@# Run deployment
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/site.yml \
		$(call check_dry_run) \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE)) \
		-e "deployment_id=$$(date +%Y%m%d-%H%M%S)"
	@# Verify deployment
	@make post-deploy-check
	@echo "$(GREEN)âœ“ Deployment complete and verified!$(NC)"

pre-deploy-check: ## Pre-deployment validation
	@echo "$(YELLOW)>>> Running pre-deployment checks...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/pre-deploy-check.yml \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

post-deploy-check: ## Post-deployment validation
	@echo "$(YELLOW)>>> Verifying deployment...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/post-deploy-check.yml \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Upgrade (Enhanced with rollback) ===

upgrade: activate ## Safe rolling upgrade with automatic rollback
	@if [ -z "$(VERSION)" ]; then \
		echo "$(RED)Error: VERSION required$(NC)"; \
		echo "Usage: make upgrade VERSION=v0.0.2"; \
		exit 1; \
	fi
	@echo "$(GREEN)>>> Starting safe rolling upgrade to $(VERSION)...$(NC)"
	@# Create upgrade backup
	@make backup BACKUP_TYPE=pre-upgrade
	@# Run upgrade with rollback support
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/rolling-upgrade.yml \
		-e "mitum_version=$(VERSION)" \
		-e "enable_rollback=yes" \
		-e "rollback_on_failure=yes" \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Monitoring ===

logs: activate ## View logs (cross-platform)
	@echo "$(GREEN)>>> Fetching logs...$(NC)"
	@if [ "$(OS_TYPE)" = "macos" ]; then \
		echo "$(YELLOW)Note: Using alternative log method for macOS$(NC)"; \
		$(ANSIBLE) -i $(INVENTORY) mitum_nodes \
			-m shell -a "tail -n 50 /var/log/mitum/mitum.log || echo 'No logs found'" \
			--become; \
	else \
		$(ANSIBLE) -i $(INVENTORY) mitum_nodes \
			-m shell -a "journalctl -u mitum -n 50 --no-pager || tail -n 50 /var/log/mitum/mitum.log" \
			--become; \
	fi

# === Destructive Operations (Protected) ===

clean-data: activate ## Clean blockchain data (PROTECTED)
	$(call confirm_action,This will DELETE all blockchain data!)
	@echo "$(RED)>>> Starting data cleanup...$(NC)"
	@# Create emergency backup first
	@make backup BACKUP_TYPE=emergency
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/clean-data.yml \
		--extra-vars "safety_confirmed=yes" \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Backup & Restore (Enhanced) ===

backup: activate ## Create timestamped backup with metadata
	@echo "$(GREEN)>>> Creating backup...$(NC)"
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/backup.yml \
		-e "backup_type=$${BACKUP_TYPE:-manual}" \
		-e "backup_timestamp=$$(date +%Y%m%d-%H%M%S)" \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

restore: activate ## Restore from backup with validation
	@if [ -z "$(BACKUP_TIMESTAMP)" ]; then \
		echo "$(RED)Error: BACKUP_TIMESTAMP required$(NC)"; \
		echo "Available backups:"; \
		@$(ANSIBLE) -i $(INVENTORY) mitum_nodes[0] -m shell \
			-a "ls -la /var/backups/mitum/" --become; \
		exit 1; \
	fi
	$(call confirm_action,This will restore from backup $(BACKUP_TIMESTAMP))
	@$(ANSIBLE_PLAYBOOK) -i $(INVENTORY) $(PLAYBOOK_DIR)/restore.yml \
		-e "backup_timestamp=$(BACKUP_TIMESTAMP)" \
		-e "validate_backup=yes" \
		$(if $(USE_VAULT),--vault-password-file=$(VAULT_PASSWORD_FILE))

# === Utility Commands ===

vault-edit: ## Edit vault-encrypted files
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: FILE required$(NC)"; \
		echo "Usage: make vault-edit FILE=inventories/production/group_vars/vault.yml"; \
		exit 1; \
	fi
	@$(ANSIBLE_VAULT) edit $(FILE) --vault-password-file=$(VAULT_PASSWORD_FILE)

validate: activate ## Validate all playbooks and syntax
	@echo "$(YELLOW)>>> Validating Ansible files...$(NC)"
	@for playbook in $(PLAYBOOK_DIR)/*.yml; do \
		echo "Checking $$playbook..."; \
		$(ANSIBLE_PLAYBOOK) --syntax-check $$playbook; \
	done
	@echo "$(GREEN)âœ“ All playbooks valid$(NC)"

# === Development Helpers ===

dev-env: ## Setup development environment with safety defaults
	@echo "$(YELLOW)>>> Setting up development environment...$(NC)"
	@cp -n inventories/development/hosts.yml.example inventories/development/hosts.yml || true
	@echo "SAFE_MODE=no" >> .env.development
	@echo "DRY_RUN=yes" >> .env.development
	@echo "$(GREEN)âœ“ Development environment ready$(NC)"

# === Virtual Environment ===

venv: ## Create Python virtual environment
	@if [ ! -d "$(VENV)" ]; then \
		echo "$(GREEN)>>> Creating virtual environment...$(NC)"; \
		python3 -m venv $(VENV); \
		$(VENV)/bin/pip install --upgrade pip; \
		$(VENV)/bin/pip install -r requirements.txt; \
	fi

activate: venv ## Ensure virtual environment is active
	@if [ -z "$${VIRTUAL_ENV}" ]; then \
		echo "$(YELLOW)Activating virtual environment...$(NC)"; \
		. $(VENV)/bin/activate; \
	fi

# === Clean Commands ===

clean: ## Clean generated files and caches
	@echo "$(GREEN)>>> Cleaning temporary files...$(NC)"
	@find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete
	@rm -rf .ansible_cache .ansible_inventory_cache
	@rm -rf logs/*.log
	@echo "$(GREEN)âœ“ Clean complete$(NC)"

clean-all: clean ## Deep clean including venv (CAREFUL!)
	$(call confirm_action,This will remove virtual environment and all dependencies)
	@rm -rf $(VENV)
	@rm -rf tools/mitumjs/node_modules
	@echo "$(GREEN)âœ“ Deep clean complete$(NC)"

.PHONY: all $(MAKECMDGOALS)

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/ansible.cfg
================================================================================
# Mitum Ansible Configuration
# Version: 4.0.0 - Security hardened with better practices
#
# Key improvements:
# 1. Security enhancements - host key checking enabled, privilege escalation improvements
# 2. Performance optimization - connection reuse, parallel processing improvements
# 3. Enhanced logging - detailed log configuration
# 4. Better error handling

[defaults]
# === Basic Settings ===
# Inventory location - can be overridden per environment
inventory = inventories/production/hosts.yml
roles_path = roles
# Collections path added
collections_paths = ./collections

# === Security Settings (Enhanced) ===
# SSH host key verification enabled - security enhancement
host_key_checking = True
# Known hosts file path
ssh_known_hosts_file = ~/.ssh/known_hosts_mitum
# Disable automatic host key addition (manual verification required)
host_key_auto_add = False

# === Execution Settings ===
# Python interpreter auto-detection (no warnings)
interpreter_python = auto_silent
# Retry files disabled
retry_files_enabled = False
# Task execution strategy
strategy = linear
# Parallel processing forks
forks = 50
# Timeout settings
timeout = 30

# === Output Settings ===
# YAML format output (better readability)
stdout_callback = yaml
# Callback plugins enabled
callbacks_enabled = timer, profile_tasks, profile_roles
# Always show diff
display_args_to_stdout = False
display_skipped_hosts = False

# === Logging Settings (New) ===
# Log file path
log_path = ./logs/ansible.log
# Log level (DEBUG, INFO, WARNING, ERROR)
# Production: WARNING, Development: INFO
log_level = INFO

# === Fact Caching Settings ===
# Fact gathering mode
gathering = smart
# Fact cache plugin
fact_caching = jsonfile
# Cache storage location
fact_caching_connection = .ansible_cache
# Cache validity time (24 hours)
fact_caching_timeout = 86400

# === Error Handling ===
# Stop immediately on any error
any_errors_fatal = False
# Failure tolerance percentage
max_fail_percentage = 30
# Ignore unreachable hosts
ignore_unreachable = False

# === Variable Settings ===
# Error on undefined variables
error_on_undefined_vars = True
# Duplicate variable handling (merge, replace)
hash_behaviour = merge

# === Vault Settings (New) ===
# Vault password file auto-usage
vault_password_file = .vault_pass
# Auto-decrypt vault files
vault_decrypt = True

[inventory]
# === Inventory Plugin Settings ===
enable_plugins = host_list, yaml, ini, auto, script, aws_ec2
# Enable inventory caching
cache = True
cache_plugin = jsonfile
cache_connection = .ansible_inventory_cache
cache_timeout = 7200

[ssh_connection]
# === SSH Connection Optimization ===
# SSH pipelining (performance improvement)
pipelining = True
# SSH control path (connection reuse)
control_path = /tmp/ansible-ssh-%%C
# SSH control master settings
ssh_args = -o ControlMaster=auto -o ControlPersist=1800s

# === Additional SSH Options ===
# Retry count
retries = 3
# Connection timeout
timeout = 10
# SSH compression (bandwidth saving)
compression = True

# === Security SSH Options (Enhanced) ===
# Enable StrictHostKeyChecking
ssh_extra_args = -o StrictHostKeyChecking=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3

[persistent_connection]
# === Persistent Connection Settings ===
# Connection timeout
connect_timeout = 30
# Command timeout  
command_timeout = 30
# Connection retry timeout
connect_retry_timeout = 15

[privilege_escalation]
# === Privilege Escalation Settings (Enhanced) ===
# Don't use privilege escalation by default (use only when needed)
become = False
# Privilege escalation method
become_method = sudo
# Target user
become_user = root
# Don't ask for password (SSH key based)
become_ask_pass = False
# sudo flags (security enhanced)
become_flags = -H -S -n

[diff]
# === Diff Display Settings ===
# Always show changes
always = True
# Context lines
context = 3

[colors]
# === Color Settings (Better Readability) ===
# Debug messages
debug = dark_gray
# Warning messages
warn = bright_yellow
# Error messages
error = bright_red
# OK status
ok = bright_green
# Changed status
changed = bright_yellow
# Skipped status
skip = bright_blue
# Unreachable
unreachable = bright_red
# Failed
failed = bright_red

[callback_profile_tasks]
# === Task Profiling Settings ===
# Show top N tasks
task_output_limit = 20
# Sort order (ascending, descending)
sort_order = descending

[callback_timer]
# === Timer Callback Settings ===
# Show task duration
show_task_duration = True
# Show play duration
show_play_duration = True

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/backup.yml
================================================================================
---
# Backup playbook for Mitum nodes

- name: Backup Mitum nodes
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: yes
  become: yes
  vars:
    backup_timestamp: "{{ ansible_date_time.epoch }}"
    backup_dir: "{{ mitum_backup_dir }}/{{ backup_timestamp }}"
    
  tasks:
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0750'
        
    - name: Check service status
      systemd:
        name: "{{ mitum_service_name }}"
      register: service_status
      
    - name: Create backup manifest
      copy:
        content: |
          backup_timestamp: {{ backup_timestamp }}
          backup_date: {{ ansible_date_time.iso8601 }}
          hostname: {{ inventory_hostname }}
          node_id: {{ mitum_node_id }}
          service_status: {{ service_status.status.ActiveState }}
          mitum_version: {{ mitum_version | default('unknown') }}
          network_id: {{ mitum_network_id }}
        dest: "{{ backup_dir }}/manifest.yml"
        
    - name: Stop service for consistent backup
      systemd:
        name: "{{ mitum_service_name }}"
        state: stopped
      when: 
        - stop_service_for_backup | default(false)
        - service_status.status.ActiveState == "active"
      register: service_stopped
      
    - name: Backup configuration files
      archive:
        path:
          - "{{ mitum_config_dir }}"
          - "{{ mitum_keys_dir }}"
        dest: "{{ backup_dir }}/config-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Backup data directory
      when: backup_data | default(true)
      block:
        - name: Calculate data directory size
          command: du -sh {{ mitum_data_dir }}
          register: data_size
          changed_when: false
          
        - name: Display data size
          debug:
            msg: "Data directory size: {{ data_size.stdout }}"
            
        - name: Create data backup
          archive:
            path: "{{ mitum_data_dir }}"
            dest: "{{ backup_dir }}/data-backup.tar.gz"
            format: gz
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0600'
          async: 3600
          poll: 30
          
    - name: Backup MongoDB
      when: 
        - mitum_mongodb_enabled | default(true)
        - backup_mongodb | default(true)
      block:
        - name: Create MongoDB backup directory
          file:
            path: "{{ backup_dir }}/mongodb-backup"
            state: directory
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0750'
            
        - name: Dump MongoDB database
          shell: |
            {% if mitum_mongodb_auth_enabled %}
            mongodump -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
              --authenticationDatabase {{ mitum_mongodb_database }} \
              --db {{ mitum_mongodb_database }} \
              --out {{ backup_dir }}/mongodb-backup
            {% else %}
            mongodump --db {{ mitum_mongodb_database }} \
              --out {{ backup_dir }}/mongodb-backup
            {% endif %}
          become_user: "{{ mitum_service_user }}"
          
        - name: Compress MongoDB backup
          archive:
            path: "{{ backup_dir }}/mongodb-backup"
            dest: "{{ backup_dir }}/mongodb-backup.tar.gz"
            format: gz
            remove: yes
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0600'
            
    - name: Backup logs
      when: backup_logs | default(false)
      archive:
        path: "{{ mitum_log_dir }}"
        dest: "{{ backup_dir }}/logs-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Start service if it was stopped
      systemd:
        name: "{{ mitum_service_name }}"
        state: started
      when: service_stopped is changed
      
    - name: Create backup summary
      shell: |
        echo "=== Backup Summary ===" > {{ backup_dir }}/summary.txt
        echo "Timestamp: {{ ansible_date_time.iso8601 }}" >> {{ backup_dir }}/summary.txt
        echo "Node: {{ inventory_hostname }}" >> {{ backup_dir }}/summary.txt
        echo "" >> {{ backup_dir }}/summary.txt
        echo "Files backed up:" >> {{ backup_dir }}/summary.txt
        ls -lh {{ backup_dir }}/*.tar.gz >> {{ backup_dir }}/summary.txt
        echo "" >> {{ backup_dir }}/summary.txt
        echo "Total size:" >> {{ backup_dir }}/summary.txt
        du -sh {{ backup_dir }} >> {{ backup_dir }}/summary.txt
      changed_when: false
      
    - name: Set backup permissions
      file:
        path: "{{ backup_dir }}"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0750'
        recurse: yes
        
- name: Centralize backups
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: no
  become: yes
  serial: 1
  when: centralize_backups | default(false)
  tasks:
    - name: Create central backup directory on bastion
      file:
        path: "/var/backups/mitum-central/{{ backup_timestamp }}"
        state: directory
        mode: '0750'
      delegate_to: "{{ groups['bastion'][0] }}"
      run_once: yes
      
    - name: Sync backup to bastion
      synchronize:
        src: "{{ backup_dir }}/"
        dest: "/var/backups/mitum-central/{{ backup_timestamp }}/{{ inventory_hostname }}/"
        mode: push
        compress: yes
      delegate_to: "{{ groups['bastion'][0] }}"
      
- name: Cleanup old backups
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: no
  become: yes
  when: cleanup_old_backups | default(true)
  tasks:
    - name: Find old backups
      find:
        paths: "{{ mitum_backup_dir }}"
        age: "{{ mitum_backup_retention_days | default(7) }}d"
        recurse: no
        file_type: directory
      register: old_backups
      
    - name: Remove old backups
      file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ old_backups.files }}"
      when: old_backups.files | length > 0
      
    - name: Display cleanup summary
      debug:
        msg: "Removed {{ old_backups.files | length }} old backup(s)"
        
- name: Generate backup report
  hosts: localhost
  gather_facts: no
  run_once: yes
  tasks:
    - name: Create backup report
      template:
        src: backup-report.j2
        dest: "{{ playbook_dir }}/../reports/backup-{{ backup_timestamp }}.txt"
      vars:
        nodes_backed_up: "{{ groups[target_nodes | default('mitum_nodes')] }}"
        
    - name: Display backup summary
      debug:
        msg: |
          Backup completed successfully!
          
          Timestamp: {{ backup_timestamp }}
          Nodes backed up: {{ groups[target_nodes | default('mitum_nodes')] | length }}
          Backup location: {{ mitum_backup_dir }}/{{ backup_timestamp }}
          
          To restore from this backup:
          make restore BACKUP_TIMESTAMP={{ backup_timestamp }}

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/deploy-mitum.yml
================================================================================
---
# Main deployment playbook for Mitum blockchain

- name: Pre-deployment validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Verify inventory exists
      stat:
        path: "{{ inventory_file }}"
      register: inv_check
      failed_when: not inv_check.stat.exists
      
    - name: Check for required variables
      assert:
        that:
          - mitum_network_id is defined
          - mitum_model_type is defined
          - groups['mitum_nodes'] | length > 0
        fail_msg: "Required variables or groups are missing"
        
    - name: Display deployment information
      debug:
        msg: |
          Mitum Deployment Configuration:
          - Network ID: {{ mitum_network_id }}
          - Model Type: {{ mitum_model_type }}
          - Total Nodes: {{ groups['mitum_nodes'] | length }}
          - Consensus Nodes: {{ groups['mitum_nodes'] | map('extract', hostvars) | selectattr('mitum_api_enabled', 'defined') | rejectattr('mitum_api_enabled') | list | length }}
          - API Nodes: {{ groups['mitum_nodes'] | map('extract', hostvars) | selectattr('mitum_api_enabled', 'defined') | selectattr('mitum_api_enabled') | list | length }}
          
- name: Prepare bastion host
  hosts: bastion
  gather_facts: yes
  become: yes
  tasks:
    - name: Ensure bastion is ready
      ping:
      
    - name: Install required packages on bastion
      package:
        name:
          - python3
          - python3-pip
          - jq
          - curl
          - git
        state: present
        
    - name: Configure SSH multiplexing
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        state: present
      loop:
        - { regexp: '^MaxSessions', line: 'MaxSessions 50' }
        - { regexp: '^MaxStartups', line: 'MaxStartups 50:30:100' }
      notify: restart sshd
      
  handlers:
    - name: restart sshd
      service:
        name: sshd
        state: restarted

- name: Deploy MongoDB on nodes
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - mongodb
  tasks:
    - name: Install MongoDB
      include_role:
        name: mongodb
      vars:
        mongodb_version: "{{ mitum_mongodb_version }}"
        mongodb_port: "{{ mitum_mongodb_port }}"
        mongodb_replica_set: "{{ mitum_mongodb_replica_set }}"
        
    - name: Configure MongoDB replica set
      run_once: yes
      delegate_to: "{{ groups['mitum_nodes'][0] }}"
      mongodb_replicaset:
        replica_set: "{{ mitum_mongodb_replica_set }}"
        members: "{{ groups['mitum_nodes'] | map('extract', hostvars, 'ansible_default_ipv4') | map(attribute='address') | list }}"
      when: groups['mitum_nodes'] | length > 1

- name: Generate keys centrally
  hosts: localhost
  gather_facts: no
  tags:
    - keygen
  tasks:
    - name: Check if keys already exist
      stat:
        path: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
      register: keys_check
      
    - name: Generate keys using MitumJS
      when: not keys_check.stat.exists or mitum_force_keygen | default(false)
      block:
        - name: Create keys directory
          file:
            path: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
            state: directory
            mode: '0700'
            
        - name: Install MitumJS dependencies
          npm:
            path: "{{ playbook_dir }}/../tools/mitumjs"
            state: present
            
        - name: Generate node keys
          command: |
            node {{ playbook_dir }}/../tools/mitumjs/mitum-keygen.js \
              --network-id {{ mitum_network_id }} \
              --node-count {{ groups['mitum_nodes'] | length }} \
              --threshold {{ mitum_keys_threshold }} \
              --output {{ playbook_dir }}/../keys/{{ mitum_network_id }}
          register: keygen_result
          
        - name: Parse generated keys
          set_fact:
            generated_keys: "{{ keygen_result.stdout | from_json }}"
          
        - name: Save keys summary
          copy:
            content: "{{ generated_keys | to_nice_yaml }}"
            dest: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}/keys-summary.yml"

- name: Deploy Mitum nodes
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - install
    - mitum
  tasks:
    - name: Create Mitum user
      user:
        name: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        system: yes
        shell: /bin/bash
        home: "{{ mitum_base_dir }}"
        create_home: yes
        
    - name: Create directory structure
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
      loop:
        - "{{ mitum_install_dir }}"
        - "{{ mitum_data_dir }}"
        - "{{ mitum_config_dir }}"
        - "{{ mitum_keys_dir }}"
        - "{{ mitum_log_dir }}"
        - "{{ mitum_backup_dir }}"
        
    - name: Deploy Mitum binary
      include_role:
        name: mitum
        tasks_from: install
      vars:
        mitum_deployment_phase: install

- name: Configure Mitum nodes
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - configure
    - mitum
  tasks:
    - name: Copy node keys
      copy:
        src: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}/node{{ mitum_node_id }}/"
        dest: "{{ mitum_keys_dir }}/"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Configure Mitum node
      include_role:
        name: mitum
        tasks_from: configure-nodes
      vars:
        mitum_deployment_phase: configure

- name: Initialize genesis block
  hosts: mitum_nodes[0]
  gather_facts: no
  become: yes
  run_once: yes
  tags:
    - init
    - genesis
  tasks:
    - name: Check if already initialized
      stat:
        path: "{{ mitum_data_dir }}/.initialized"
      register: init_check
      
    - name: Initialize genesis
      when: not init_check.stat.exists
      block:
        - name: Generate genesis configuration
          template:
            src: "{{ playbook_dir }}/../roles/mitum/templates/genesis.yml.j2"
            dest: "{{ mitum_config_dir }}/genesis.yml"
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            
        - name: Initialize blockchain
          become_user: "{{ mitum_service_user }}"
          command: |
            {{ mitum_install_dir }}/{{ mitum_model_type }} init \
              --config {{ mitum_config_dir }}/config.yml \
              {{ mitum_config_dir }}/genesis.yml
          register: init_result
          
        - name: Mark as initialized
          file:
            path: "{{ mitum_data_dir }}/.initialized"
            state: touch
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"

- name: Start Mitum services
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  serial: 1
  tags:
    - start
    - service
  tasks:
    - name: Start Mitum service
      include_role:
        name: mitum
        tasks_from: service
      vars:
        mitum_deployment_phase: start
        
    - name: Wait for node to be ready
      wait_for:
        port: "{{ mitum_node_port }}"
        host: "{{ ansible_host }}"
        timeout: 60
        
    - name: Verify node health
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/node"
        status_code: 200
      retries: 30
      delay: 2
      register: health_check
      until: health_check.status == 200

- name: Setup monitoring
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  tags:
    - monitoring
  tasks:
    - name: Configure monitoring
      include_role:
        name: mitum
        tasks_from: monitoring-prometheus
      when: mitum_monitoring.enabled | default(true)

- name: Post-deployment validation
  hosts: mitum_nodes
  gather_facts: no
  tags:
    - validate
  tasks:
    - name: Check node status
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/node"
      register: node_status
      
    - name: Check consensus state
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/consensus/state"
      register: consensus_status
      when: not (mitum_api_enabled | default(false))
      
    - name: Check API endpoints
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_api_port }}/{{ item }}"
      loop:
        - v2/node
        - healthz
      when: mitum_api_enabled | default(false)
      
    - name: Display deployment summary
      debug:
        msg: |
          Node: {{ inventory_hostname }}
          Status: {{ node_status.json.status | default('unknown') }}
          Type: {{ 'API/Syncer' if mitum_api_enabled | default(false) else 'Consensus' }}
          {% if not (mitum_api_enabled | default(false)) %}
          Consensus: {{ consensus_status.json.consensus.state | default('unknown') }}
          {% endif %}
      run_once: yes
      delegate_to: localhost
      
- name: Generate deployment report
  hosts: localhost
  gather_facts: no
  tags:
    - report
  tasks:
    - name: Create deployment report
      template:
        src: deployment-report.j2
        dest: "{{ playbook_dir }}/../reports/deployment-{{ ansible_date_time.epoch }}.txt"
      vars:
        deployment_timestamp: "{{ ansible_date_time.iso8601 }}"
        deployed_nodes: "{{ groups['mitum_nodes'] }}"

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/prepare-system.yml
================================================================================
---
# System Preparation Playbook
# Version: 4.0.0 - Cross-platform support with security hardening
#
# Performs OS-specific package installation and system configuration.
# Supported OS: Ubuntu/Debian, CentOS/RHEL, macOS (limited)

- name: Prepare systems for Mitum deployment
  hosts: all
  become: yes
  gather_facts: yes
  
  # Error handling strategy
  max_fail_percentage: 30
  serial: "{{ prepare_batch_size | default('100%') }}"
  
  pre_tasks:
    - name: Detect package manager
      set_fact:
        pkg_mgr: >-
          {%- if ansible_os_family == "Debian" -%}apt
          {%- elif ansible_os_family == "RedHat" -%}yum
          {%- elif ansible_os_family == "Darwin" -%}brew
          {%- else -%}unknown{%- endif -%}

    - name: Verify supported package manager
      assert:
        that:
          - pkg_mgr != "unknown"
        fail_msg: "Unsupported OS family: {{ ansible_os_family }}"

  tasks:
    # === Package Cache Update ===
    - name: Update package cache
      block:
        - name: Update apt cache (Debian/Ubuntu)
          apt:
            update_cache: yes
            cache_valid_time: 3600
          when: pkg_mgr == "apt"
          
        - name: Update yum cache (RHEL/CentOS)
          yum:
            update_cache: yes
          when: pkg_mgr == "yum"
          
      tags: [prepare, packages]

    # === Required Package Installation (OS Independent) ===
    - name: Install required packages
      package:
        name: "{{ item }}"
        state: present
      loop: "{{ base_packages[pkg_mgr] }}"
      vars:
        base_packages:
          apt:
            - python3
            - python3-pip
            - python3-venv
            - python3-dev
            - build-essential
            - curl
            - wget
            - git
            - jq
            - htop
            - iotop
            - net-tools
            - dnsutils
            - tar
            - gzip
            - unzip
            - ca-certificates
            - gnupg
            - lsb-release
            - software-properties-common
            - ufw
            - fail2ban
            - chrony  # Time synchronization
          yum:
            - python3
            - python3-pip
            - python3-devel
            - gcc
            - gcc-c++
            - make
            - curl
            - wget
            - git
            - jq
            - htop
            - iotop
            - net-tools
            - bind-utils
            - tar
            - gzip
            - unzip
            - ca-certificates
            - gnupg2
            - firewalld
            - fail2ban
            - chrony
          brew:
            - python3
            - curl
            - wget
            - git
            - jq
            - htop
      tags: [prepare, packages]

    # === Python Package Installation ===
    - name: Install Python packages
      pip:
        name:
          - pymongo
          - requests
          - cryptography
        state: present
        executable: pip3
      tags: [prepare, python]

    # === System User Creation ===
    - name: Create mitum system user
      user:
        name: "{{ mitum_service_user }}"
        system: yes
        shell: /bin/bash
        home: "/home/{{ mitum_service_user }}"
        createhome: yes
        comment: "Mitum blockchain service user"
      tags: [prepare, users]

    - name: Create mitum group
      group:
        name: "{{ mitum_service_group }}"
        system: yes
      tags: [prepare, users]

    # === Directory Structure Creation ===
    - name: Create required directories
      file:
        path: "{{ item.path }}"
        state: directory
        owner: "{{ item.owner | default(mitum_service_user) }}"
        group: "{{ item.group | default(mitum_service_group) }}"
        mode: "{{ item.mode | default('0755') }}"
      loop:
        - path: "{{ mitum_base_dir }}"
        - path: "{{ mitum_install_dir }}"
        - path: "{{ mitum_data_dir }}"
        - path: "{{ mitum_config_dir }}"
        - path: "{{ mitum_keys_dir }}"
          mode: "0700"  # Keys directory more restrictive
        - path: "{{ mitum_log_dir }}"
        - path: "{{ mitum_backup_dir }}"
        - path: "{{ mitum_temp_dir }}"
          owner: "root"
          mode: "1777"  # Temp with sticky bit
      tags: [prepare, directories]

    # === System Limits Configuration ===
    - name: Configure system limits
      pam_limits:
        domain: "{{ mitum_service_user }}"
        limit_type: "{{ item.type }}"
        limit_item: "{{ item.item }}"
        value: "{{ item.value }}"
      loop:
        - { type: 'soft', item: 'nofile', value: '{{ mitum_service_limits.nofile }}' }
        - { type: 'hard', item: 'nofile', value: '{{ mitum_service_limits.nofile }}' }
        - { type: 'soft', item: 'nproc', value: '{{ mitum_service_limits.nproc }}' }
        - { type: 'hard', item: 'nproc', value: '{{ mitum_service_limits.nproc }}' }
        - { type: 'soft', item: 'memlock', value: 'unlimited' }
        - { type: 'hard', item: 'memlock', value: 'unlimited' }
      tags: [prepare, limits]

    # === Kernel Parameter Optimization ===
    - name: Configure sysctl parameters
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
        sysctl_file: /etc/sysctl.d/99-mitum.conf
      loop:
        # Network optimization
        - { name: 'net.core.somaxconn', value: '32768' }
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '8192' }
        - { name: 'net.core.netdev_max_backlog', value: '5000' }
        - { name: 'net.ipv4.ip_local_port_range', value: '1024 65535' }
        - { name: 'net.ipv4.tcp_tw_reuse', value: '1' }
        - { name: 'net.ipv4.tcp_fin_timeout', value: '30' }
        
        # Memory optimization
        - { name: 'vm.swappiness', value: '10' }
        - { name: 'vm.dirty_ratio', value: '15' }
        - { name: 'vm.dirty_background_ratio', value: '5' }
        
        # File system
        - { name: 'fs.file-max', value: '2097152' }
      when: ansible_os_family != "Darwin"
      tags: [prepare, kernel]

    # === Time Synchronization Configuration ===
    - name: Configure time synchronization
      block:
        - name: Ensure chrony is running
          systemd:
            name: chrony
            state: started
            enabled: yes
          when: ansible_service_mgr == "systemd"

        - name: Configure chrony
          template:
            src: chrony.conf.j2
            dest: /etc/chrony/chrony.conf
            backup: yes
          notify: restart chrony
          when: ansible_os_family != "Darwin"
      tags: [prepare, time]

    # === Firewall Configuration ===
    - name: Configure firewall
      include_tasks: tasks/configure-firewall.yml
      when: security_hardening.firewall | default(true)
      tags: [prepare, firewall, security]

    # === Security Hardening ===
    - name: Basic security hardening
      block:
        - name: Disable root SSH login
          lineinfile:
            path: /etc/ssh/sshd_config
            regexp: '^PermitRootLogin'
            line: 'PermitRootLogin no'
            backup: yes
          notify: restart sshd
          when: security_hardening.disable_root_login | default(true)

        - name: Configure fail2ban
          template:
            src: fail2ban-jail.local.j2
            dest: /etc/fail2ban/jail.local
            backup: yes
          notify: restart fail2ban
          when: security_hardening.fail2ban | default(true)
      tags: [prepare, security]

    # === Log Rotation Configuration ===
    - name: Configure log rotation
      template:
        src: logrotate-mitum.j2
        dest: /etc/logrotate.d/mitum
      tags: [prepare, logging]

  handlers:
    - name: restart chrony
      systemd:
        name: chrony
        state: restarted
      when: ansible_service_mgr == "systemd"

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
      when: ansible_service_mgr == "systemd"

    - name: restart fail2ban
      systemd:
        name: fail2ban
        state: restarted
      when: ansible_service_mgr == "systemd"

  post_tasks:
    - name: Verify system preparation
      command: "{{ item }}"
      loop:
        - "id {{ mitum_service_user }}"
        - "ls -la {{ mitum_base_dir }}"
        - "sysctl net.core.somaxconn"
      register: verify_results
      changed_when: false

    - name: Display preparation summary
      debug:
        msg: |
          System preparation complete:
          - Package manager: {{ pkg_mgr }}
          - Service user: {{ mitum_service_user }}
          - Base directory: {{ mitum_base_dir }}
          - Security hardening: {{ security_hardening.enabled | default(true) }}

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/requirements.txt
================================================================================
# Python Requirements for Mitum Ansible
# Version: 4.0.0
#
# This file manages versions of Ansible and related Python packages.
# Installation: pip install -r requirements.txt

# === Core Ansible ===
ansible>=6.0.0,<7.0.0              # Ansible core package
ansible-core>=2.13.0,<2.14.0       # Ansible core engine

# === Ansible Tools ===
ansible-lint>=6.0.0                # Playbook quality checker
ansible-vault>=2.1.0               # Vault encryption management
ansible-runner>=2.3.0              # Ansible execution environment
molecule>=4.0.0                    # Ansible testing framework (optional)

# === Required Libraries ===
jmespath>=1.0.0                    # JSON query language (used in ec2_instance etc.)
netaddr>=0.8.0                     # IP address and network manipulation
pymongo>=4.0.0                     # MongoDB Python driver
dnspython>=2.3.0                   # DNS lookups (for MongoDB SRV records)
cryptography>=40.0.0               # Cryptographic operations (Vault, SSL)
paramiko>=3.0.0                    # SSH client library

# === Templating and Parsing ===
pyyaml>=6.0                        # YAML file processing
jinja2>=3.1.0                      # Template engine
MarkupSafe>=2.1.0                  # Jinja2 dependency
ruamel.yaml>=0.17.0                # YAML file preservation

# === Utilities ===
python-dateutil>=2.8.0             # Date/time handling
requests>=2.28.0                   # HTTP request handling
urllib3>=1.26.0,<2.0.0             # HTTP client
packaging>=23.0                    # Version comparison and handling
rich>=13.0.0                       # Rich terminal output

# === Cloud Providers (Optional) ===
# For AWS usage
boto3>=1.26.0                      # AWS SDK
botocore>=1.29.0                   # AWS core library

# For GCP usage
# google-auth>=2.16.0
# google-cloud-compute>=1.0.0

# For Azure usage
# azure-mgmt-compute>=29.0.0
# azure-mgmt-network>=22.0.0

# === Container Support (Optional) ===
# For Docker usage
docker>=6.0.0                      # Docker API client

# For Kubernetes usage
# kubernetes>=25.0.0
# openshift>=0.13.0

# === Development Tools (Optional) ===
pytest>=7.2.0                      # Testing framework
pytest-ansible>=3.0.0              # Ansible test plugin
black>=23.0.0                      # Python code formatter
flake8>=6.0.0                      # Python linter
pre-commit>=3.0.0                  # Git hook management
ipython>=8.0.0                     # Enhanced Python shell

# === Security Scanning (Optional) ===
bandit>=1.7.0                      # Python security vulnerability scanner
safety>=2.3.0                      # Dependency vulnerability checker

# === Documentation (Optional) ===
sphinx>=6.0.0                      # Documentation generator
sphinx-rtd-theme>=1.2.0            # Read the Docs theme

# === Performance Monitoring (Optional) ===
psutil>=5.9.0                      # System and process utilities
py-spy>=0.3.0                      # Python profiler

# === Version Pinning Notes ===
# - Major versions are fixed to prevent compatibility issues
# - Minor versions are flexible to allow security patches
# - For production, use: pip freeze > requirements-lock.txt

# === Installation Notes ===
# 1. Create and activate virtual environment:
#    python3 -m venv venv
#    source venv/bin/activate  # Linux/Mac
#    venv\Scripts\activate     # Windows
#
# 2. Install requirements:
#    pip install -r requirements.txt
#
# 3. Verify installation:
#    ansible --version
#    python -m pip list

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/restore.yml
================================================================================
---
# Restore Mitum nodes from backup

- name: Restore Mitum from backup
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  become: yes
  serial: 1
  vars:
    backup_dir: "{{ mitum_backup_dir | default('/var/backups/mitum') }}"
    backup_timestamp: "{{ backup_timestamp | mandatory('backup_timestamp is required') }}"
    
  pre_tasks:
    - name: Verify backup exists
      stat:
        path: "{{ backup_dir }}/{{ backup_timestamp }}"
      register: backup_check
      failed_when: not backup_check.stat.exists
      
    - name: Confirm restore operation
      pause:
        prompt: |
          WARNING: This will restore node {{ inventory_hostname }} from backup {{ backup_timestamp }}
          Current data will be overwritten!
          Press Enter to continue or Ctrl+C to abort
      when: confirm_restore | default(true)
      
  tasks:
    - name: Stop services
      systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - mitum
        - mongod
        
    - name: Create restore workspace
      file:
        path: /tmp/mitum-restore
        state: directory
        mode: '0700'
        
    - name: Restore configuration
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/config-backup.tar.gz"
        dest: /tmp/mitum-restore
        remote_src: yes
        
    - name: Restore keys
      copy:
        src: /tmp/mitum-restore/keys/
        dest: "{{ mitum_keys_dir }}/"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Restore configuration files
      copy:
        src: /tmp/mitum-restore/config/
        dest: "{{ mitum_config_dir }}/"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        
    - name: Restore data (if available)
      when: restore_data | default(false)
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/data-backup.tar.gz"
        dest: "{{ mitum_data_dir | dirname }}"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        
    - name: Restore MongoDB (if backed up)
      when: restore_mongodb | default(false)
      shell: |
        mongorestore --drop \
          {% if mitum_mongodb_auth_enabled %}
          -u "{{ mitum_mongodb_user }}" \
          -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          {% endif %}
          --db mitum \
          {{ backup_dir }}/{{ backup_timestamp }}/mongodb-backup/mitum
          
    - name: Start services
      systemd:
        name: "{{ item }}"
        state: started
      loop:
        - mongod
        - mitum
        
    - name: Wait for services
      wait_for:
        port: "{{ item }}"
        timeout: 60
      loop:
        - "{{ mitum_mongodb_port }}"
        - "{{ mitum_node_port }}"
        
    - name: Verify restoration
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        status_code: 200
      retries: 30
      delay: 5
      
    - name: Clean up
      file:
        path: /tmp/mitum-restore
        state: absent
        
  post_tasks:
    - name: Display restore summary
      debug:
        msg: |
          Restore completed for {{ inventory_hostname }}
          Backup: {{ backup_timestamp }}
          Configuration: Restored
          Keys: Restored
          Data: {{ 'Restored' if restore_data else 'Not restored' }}
          MongoDB: {{ 'Restored' if restore_mongodb else 'Not restored' }}

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/backup-node.yml
================================================================================
---
# Backup tasks for individual Mitum node

- name: Set backup timestamp
  set_fact:
    backup_timestamp: "{{ ansible_date_time.epoch }}"
    backup_dir: "{{ mitum_backup_dir }}/{{ ansible_date_time.epoch }}"

- name: Create backup directory
  file:
    path: "{{ backup_dir }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0750'

- name: Create backup manifest
  copy:
    content: |
      ---
      backup_info:
        timestamp: {{ backup_timestamp }}
        date: {{ ansible_date_time.iso8601 }}
        hostname: {{ inventory_hostname }}
        node_id: {{ mitum_node_id }}
        network_id: {{ mitum_network_id }}
        mitum_version: {{ mitum_version | default('unknown') }}
        backup_type: node
    dest: "{{ backup_dir }}/manifest.yml"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"

- name: Backup configuration
  archive:
    path:
      - "{{ mitum_config_dir }}"
      - "{{ mitum_keys_dir }}"
    dest: "{{ backup_dir }}/config-backup.tar.gz"
    format: gz
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0600'

- name: Backup data directory
  when: mitum_backup_include_data | default(false)
  block:
    - name: Check data directory size
      command: du -sh {{ mitum_data_dir }}
      register: data_size
      changed_when: false

    - name: Create data backup
      archive:
        path: "{{ mitum_data_dir }}"
        dest: "{{ backup_dir }}/data-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
      async: 1800
      poll: 30

- name: Backup MongoDB data
  when: 
    - mitum_mongodb_enabled | default(true)
    - mitum_backup_include_mongodb | default(true)
  block:
    - name: Create MongoDB backup
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongodump -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase {{ mitum_mongodb_database }} \
          --db {{ mitum_mongodb_database }} \
          --gzip \
          --archive={{ backup_dir }}/mongodb-backup.gz
        {% else %}
        mongodump --db {{ mitum_mongodb_database }} \
          --gzip \
          --archive={{ backup_dir }}/mongodb-backup.gz
        {% endif %}
      become_user: "{{ mitum_service_user }}"

- name: Create backup summary
  shell: |
    echo "Backup Summary" > {{ backup_dir }}/summary.txt
    echo "=============" >> {{ backup_dir }}/summary.txt
    echo "Timestamp: {{ ansible_date_time.iso8601 }}" >> {{ backup_dir }}/summary.txt
    echo "Node: {{ inventory_hostname }}" >> {{ backup_dir }}/summary.txt
    echo "" >> {{ backup_dir }}/summary.txt
    echo "Files:" >> {{ backup_dir }}/summary.txt
    ls -lh {{ backup_dir }}/*.gz >> {{ backup_dir }}/summary.txt
    echo "" >> {{ backup_dir }}/summary.txt
    echo "Total size:" >> {{ backup_dir }}/summary.txt
    du -sh {{ backup_dir }} >> {{ backup_dir }}/summary.txt
  changed_when: false

- name: Set backup complete flag
  file:
    path: "{{ backup_dir }}/.complete"
    state: touch
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"

- name: Return backup information
  set_stats:
    data:
      backup_results:
        - node: "{{ inventory_hostname }}"
          timestamp: "{{ backup_timestamp }}"
          location: "{{ backup_dir }}"
          success: true
    aggregate: yes

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/configure-nodes.yml
================================================================================
---
# Configure Mitum nodes

- name: Ensure configuration directory exists
  file:
    path: "{{ mitum_config_dir }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'

- name: Read node keys
  slurp:
    src: "{{ mitum_keys_dir }}/node.json"
  register: node_keys_raw
  when: mitum_node_privatekey is not defined

- name: Parse node keys
  set_fact:
    node_keys: "{{ node_keys_raw.content | b64decode | from_json }}"
  when: node_keys_raw is defined and node_keys_raw.content is defined

- name: Set node key facts
  set_fact:
    mitum_node_address: "{{ node_keys.address | default(mitum_node_address) }}"
    mitum_node_publickey: "{{ node_keys.public_key | default(mitum_node_publickey) }}"
    mitum_node_privatekey: "{{ node_keys.private_key | default(mitum_node_privatekey) }}"
  when: node_keys is defined

- name: Validate node keys
  assert:
    that:
      - mitum_node_address | length > 0
      - mitum_node_publickey | length > 0
      - mitum_node_privatekey | length > 0
    fail_msg: "Node keys are not properly configured"

- name: Generate Mitum configuration
  template:
    src: config.yml.j2
    dest: "{{ mitum_config_dir }}/config.yml"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0640'
    backup: yes
  notify: restart mitum service

- name: Validate configuration file
  command: |
    {{ mitum_install_dir }}/{{ mitum_model_type }} validate-config \
      {{ mitum_config_dir }}/config.yml
  register: config_validation
  changed_when: false
  failed_when: 
    - config_validation.rc != 0
    - "'not implemented' not in config_validation.stderr"

- name: Configure logging
  when: mitum_log_rotate_enabled
  block:
    - name: Install logrotate
      package:
        name: logrotate
        state: present

    - name: Configure log rotation
      template:
        src: logrotate.j2
        dest: /etc/logrotate.d/mitum
        owner: root
        group: root
        mode: '0644'

- name: Setup TLS certificates
  when: mitum_security_ssl_enabled
  block:
    - name: Ensure certificate directory exists
      file:
        path: "{{ mitum_config_dir }}/certs"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0700'

    - name: Copy TLS certificate
      copy:
        src: "{{ mitum_security_ssl_cert }}"
        dest: "{{ mitum_config_dir }}/certs/cert.pem"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'

    - name: Copy TLS key
      copy:
        src: "{{ mitum_security_ssl_key }}"
        dest: "{{ mitum_config_dir }}/certs/key.pem"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'

- name: Configure firewall rules
  when: mitum_security_firewall_enabled and ansible_os_family in ["Debian", "RedHat"]
  block:
    - name: Install firewall package
      package:
        name: "{{ 'ufw' if ansible_os_family == 'Debian' else 'firewalld' }}"
        state: present

    - name: Configure UFW rules (Debian/Ubuntu)
      when: ansible_os_family == "Debian"
      ufw:
        rule: allow
        port: "{{ item.port }}"
        proto: "{{ item.proto | default('tcp') }}"
        src: "{{ item.src | default('any') }}"
        comment: "{{ item.comment | default('Mitum') }}"
      loop: "{{ mitum_firewall_rules }}"

    - name: Configure firewalld rules (RedHat/CentOS)
      when: ansible_os_family == "RedHat"
      firewalld:
        port: "{{ item.port }}/{{ item.proto | default('tcp') }}"
        permanent: yes
        state: enabled
        immediate: yes
      loop: "{{ mitum_firewall_rules }}"

- name: Create systemd service file
  template:
    src: mitum.service.j2
    dest: /etc/systemd/system/{{ mitum_service_name }}.service
    owner: root
    group: root
    mode: '0644'
  notify:
    - reload systemd
    - restart mitum service

- name: Set service environment file
  template:
    src: mitum.env.j2
    dest: "{{ mitum_config_dir }}/mitum.env"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0640'
  when: mitum_service_environment | length > 0

- name: Create helper scripts
  template:
    src: "{{ item }}.j2"
    dest: "{{ mitum_install_dir }}/{{ item }}"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'
  loop:
    - mitum-health-check.sh
    - mitum-backup.sh
    - mitum-logs.sh

- name: Setup configuration backup
  cron:
    name: "Mitum configuration backup"
    minute: "0"
    hour: "*/6"
    job: |
      tar -czf {{ mitum_backup_dir }}/config-backup-$(date +\%Y\%m\%d-\%H\%M\%S).tar.gz \
        -C {{ mitum_base_dir }} config keys
    user: "{{ mitum_service_user }}"
    state: present
  when: mitum_backup_enabled

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/generate-configs.yml
================================================================================
---
# Generate Mitum configuration files based on generated keys

- name: Generate Mitum configurations
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  vars:
    keys_base_dir: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
    
  tasks:
    - name: Load generated keys summary
      include_vars:
        file: "{{ keys_base_dir }}/keys-summary.yml"
        name: keys_summary
      run_once: true
      delegate_to: localhost
      
    - name: Load node-specific keys
      include_vars:
        file: "{{ keys_base_dir }}/node{{ mitum_node_id }}/node.json"
        name: node_keys
      delegate_to: localhost
      
    - name: Create configuration directory
      file:
        path: "{{ mitum_config_dir }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        
    - name: Generate node configuration
      template:
        src: node-config.yml.j2
        dest: "{{ mitum_config_dir }}/config.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        backup: yes
      vars:
        node_id: "{{ mitum_node_id }}"
        all_node_keys: "{{ keys_summary.nodes }}"
        
    - name: Generate genesis configuration (on first node only)
      template:
        src: genesis.yml.j2
        dest: "{{ mitum_config_dir }}/genesis.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
      vars:
        genesis_node_key: "{{ keys_summary.nodes[0] }}"
        all_node_keys: "{{ keys_summary.nodes }}"
      when: mitum_node_id | int == 0
      
    - name: Create storage directory
      file:
        path: "{{ mitum_data_dir }}/node-{{ mitum_node_id }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        
    - name: Save node information
      copy:
        content: |
          # Node Information
          NODE_ID={{ mitum_node_id }}
          NODE_ADDRESS={{ mitum_network_id }}{{ mitum_node_id }}sas
          NODE_PORT={{ mitum_node_port }}
          API_ENABLED={{ mitum_api_enabled | default(false) }}
          {% if mitum_api_enabled | default(false) %}
          API_PORT={{ mitum_api_port | default(54320) }}
          {% endif %}
        dest: "{{ mitum_config_dir }}/node.info"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        
- name: Validate generated configurations
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  tasks:
    - name: Check configuration files exist
      stat:
        path: "{{ item }}"
      register: config_files
      loop:
        - "{{ mitum_config_dir }}/config.yml"
        - "{{ mitum_config_dir }}/node.info"
        
    - name: Check genesis file on node0
      stat:
        path: "{{ mitum_config_dir }}/genesis.yml"
      register: genesis_file
      when: mitum_node_id | int == 0
      
    - name: Display configuration summary
      debug:
        msg: |
          Configuration Summary for {{ inventory_hostname }}:
          - Node ID: {{ mitum_node_id }}
          - Config directory: {{ mitum_config_dir }}
          - Data directory: {{ mitum_data_dir }}
          - Network ID: {{ mitum_network_id }}
          - Node Port: {{ mitum_node_port }}
          - API Enabled: {{ mitum_api_enabled | default(false) }}
          {% if mitum_node_id | int == 0 %}
          - Genesis: Available
          {% endif %}

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/keygen-centralized.yml
================================================================================
---
# Centralized key generation using MitumJS

- name: Install Node.js and dependencies on controller
  block:
    - name: Check if Node.js is installed
      command: node --version
      register: node_check
      failed_when: false
      changed_when: false

    - name: Install Node.js if needed
      package:
        name: nodejs
        state: present
      when: node_check.rc != 0
      become: yes

    - name: Check if npm is installed
      command: npm --version
      register: npm_check
      failed_when: false
      changed_when: false

    - name: Install npm if needed
      package:
        name: npm
        state: present
      when: npm_check.rc != 0
      become: yes

- name: Prepare key generation environment
  block:
    - name: Create temporary directory for key generation
      tempfile:
        state: directory
        prefix: mitum_keygen_
      register: keygen_temp_dir

    - name: Copy key generation files
      copy:
        src: "{{ item }}"
        dest: "{{ keygen_temp_dir.path }}/"
        mode: '0755'
      loop:
        - mitum-keygen.js
        - package.json

    - name: Install MitumJS dependencies
      npm:
        path: "{{ keygen_temp_dir.path }}"
        production: yes
      environment:
        NODE_ENV: production

- name: Generate keys for all nodes
  block:
    - name: Get total node count
      set_fact:
        total_nodes: "{{ groups['mitum_nodes'] | length }}"

    - name: Run MitumJS key generation script
      command: |
        node mitum-keygen.js {{ total_nodes }} ./keys
      args:
        chdir: "{{ keygen_temp_dir.path }}"
      environment:
        NODE_ENV: production
      register: keygen_result

    - name: Display key generation output
      debug:
        var: keygen_result.stdout_lines
      when: mitum_debug | default(false)

    - name: Load generated keys
      set_fact:
        all_node_keys: "{{ lookup('file', keygen_temp_dir.path + '/keys/node-keys.json') | from_json }}"

    - name: Verify key count
      assert:
        that:
          - all_node_keys | length == total_nodes | int
        fail_msg: "Generated keys ({{ all_node_keys | length }}) don't match node count ({{ total_nodes }})"

    - name: Create key mapping for each node
      set_fact:
        node_key_mapping: >-
          {{
            node_key_mapping | default({}) | combine({
              item.0: {
                'node_id': idx,
                'address': 'node' + idx|string + '-' + mitum_network_id,
                'privatekey': item.1.privatekey,
                'publickey': item.1.publickey,
                'network_address': mitum_network_id + idx|string + 'sas',
                'mitum_address': item.1.address
              }
            })
          }}
      loop: "{{ groups['mitum_nodes'] | zip(all_node_keys) | list }}"
      loop_control:
        index_var: idx

    - name: Save key mapping for distribution
      copy:
        content: "{{ node_key_mapping | to_nice_json }}"
        dest: "{{ keygen_temp_dir.path }}/key-mapping.json"

- name: Generate configurations
  block:
    - name: Create configurations directory
      file:
        path: "{{ keygen_temp_dir.path }}/configs"
        state: directory

    - name: Generate node configurations
      template:
        src: "node-config.yml.j2"
        dest: "{{ keygen_temp_dir.path }}/configs/n{{ item }}.yml"
      loop: "{{ range(0, total_nodes | int) | list }}"
      vars:
        node_id: "{{ item }}"
        node_keys: "{{ all_node_keys[item] }}"

    - name: Generate genesis configuration
      template:
        src: "genesis.yml.j2"
        dest: "{{ keygen_temp_dir.path }}/configs/genesis.yml"
      vars:
        genesis_node_key: "{{ all_node_keys[0] }}"

    - name: Create configuration archive
      archive:
        path:
          - "{{ keygen_temp_dir.path }}/keys"
          - "{{ keygen_temp_dir.path }}/configs"
          - "{{ keygen_temp_dir.path }}/key-mapping.json"
        dest: "{{ keygen_temp_dir.path }}/mitum-configs.tar.gz"
        format: gz

    - name: Fetch configuration archive
      fetch:
        src: "{{ keygen_temp_dir.path }}/mitum-configs.tar.gz"
        dest: "{{ playbook_dir }}/generated/"
        flat: yes

- name: Store keys in memory for distribution
  set_fact:
    mitum_generated_keys: "{{ node_key_mapping }}"
    mitum_keygen_temp_dir: "{{ keygen_temp_dir.path }}"
  delegate_facts: true

- name: Generate AWX artifact data
  set_stats:
    data:
      generated_keys_summary:
        total_nodes: "{{ total_nodes }}"
        network_id: "{{ mitum_network_id }}"
        timestamp: "{{ ansible_date_time.iso8601 }}"
        nodes: "{{ node_key_mapping.keys() | list }}"
    aggregate: no
  when: awx_job_id is defined

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/keygen.yml
================================================================================
---
# Key generation main tasks - supports multiple modes

- name: Determine key generation strategy
  set_fact:
    keygen_strategy: "{{ mitum_keygen_strategy | default('centralized') }}"
    # Options: centralized, distributed, external
  tags:
    - keygen

- name: Display key generation strategy
  debug:
    msg: "Using {{ keygen_strategy }} key generation strategy"
  tags:
    - keygen

# Centralized key generation (recommended for AWX)
- name: Centralized key generation
  when: keygen_strategy == 'centralized'
  block:
    - name: Generate all keys on controller
      include_tasks: keygen-centralized.yml
      run_once: true
      delegate_to: localhost
      tags:
        - keygen
        - keygen-centralized

    - name: Distribute keys to nodes
      include_tasks: keygen-distribute.yml
      tags:
        - keygen
        - keygen-distribute

# Distributed key generation (each node generates its own)
- name: Distributed key generation
  when: keygen_strategy == 'distributed'
  include_tasks: keygen-distributed.yml
  tags:
    - keygen
    - keygen-distributed

# External key generation (keys provided via variables)
- name: External key provisioning
  when: keygen_strategy == 'external'
  include_tasks: keygen-external.yml
  tags:
    - keygen
    - keygen-external

# Verify keys are available
- name: Verify key availability
  block:
    - name: Check key file exists
      stat:
        path: "{{ mitum_keys_dir }}/node-{{ mitum_node_id }}.json"
      register: key_file
      
    - name: Load node keys
      set_fact:
        node_keys: "{{ lookup('file', mitum_keys_dir + '/node-' + mitum_node_id|string + '.json') | from_json }}"
      when: key_file.stat.exists
      
    - name: Set key facts
      set_fact:
        mitum_node_address: "{{ node_keys.address }}"
        mitum_node_privatekey: "{{ node_keys.privatekey }}"
        mitum_node_publickey: "{{ node_keys.publickey }}"
        mitum_node_network_address: "{{ node_keys.network_address }}"
        mitum_node_mitum_address: "{{ node_keys.mitum_address | default('') }}"
      when: node_keys is defined
      
    - name: Validate keys
      assert:
        that:
          - mitum_node_address is defined
          - mitum_node_privatekey is defined
          - mitum_node_publickey is defined
          - mitum_node_network_address is defined
        fail_msg: "Node keys are not properly configured"
        success_msg: "Node keys validated successfully"
  tags:
    - keygen
    - keygen-verify

# Store keys in AWX for future use
- name: Update AWX with node information
  set_stats:
    data:
      mitum_nodes:
        "{{ inventory_hostname }}":
          node_id: "{{ mitum_node_id }}"
          address: "{{ mitum_node_address }}"
          publickey: "{{ mitum_node_publickey }}"
          network_address: "{{ mitum_node_network_address }}"
          mitum_address: "{{ mitum_node_mitum_address | default('') }}"
          port: "{{ mitum_node_port }}"
          api_enabled: "{{ mitum_api_enabled | default(false) }}"
    aggregate: yes
  when: awx_job_id is defined
  tags:
    - keygen
    - awx-update

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/mongodb.yml
================================================================================
---
# MongoDB installation and configuration for Mitum

- name: MongoDB Setup
  block:
    - name: Check if MongoDB is already installed
      stat:
        path: /usr/bin/mongod
      register: mongodb_installed
      tags:
        - mongodb
        - mongodb-check

    - name: Add MongoDB GPG key
      apt_key:
        url: https://www.mongodb.org/static/pgp/server-7.0.asc
        state: present
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Add MongoDB repository
      apt_repository:
        repo: "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu {{ ansible_distribution_release }}/mongodb-org/7.0 multiverse"
        state: present
        update_cache: yes
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Install MongoDB packages
      apt:
        name:
          - mongodb-org
          - mongodb-org-server
          - mongodb-org-shell
          - mongodb-org-mongos
          - mongodb-org-tools
        state: present
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Create MongoDB directories
      file:
        path: "{{ item }}"
        state: directory
        owner: mongodb
        group: mongodb
        mode: '0755'
      loop:
        - /data/db
        - /data/configdb
        - /var/log/mongodb
        - /var/run/mongodb
      tags:
        - mongodb
        - mongodb-dirs

    - name: Generate MongoDB keyfile for replica set
      shell: |
        openssl rand -base64 756 > {{ mitum_mongodb_keyfile }}
        chmod 400 {{ mitum_mongodb_keyfile }}
        chown mongodb:mongodb {{ mitum_mongodb_keyfile }}
      args:
        creates: "{{ mitum_mongodb_keyfile }}"
      when: mitum_mongodb_auth_enabled
      tags:
        - mongodb
        - mongodb-keyfile

    - name: Create MongoDB configuration file
      template:
        src: mongod.conf.j2
        dest: /etc/mongod.conf
        owner: root
        group: root
        mode: '0644'
        backup: yes
      notify: restart mongodb
      tags:
        - mongodb
        - mongodb-config

    - name: Start and enable MongoDB service
      systemd:
        name: mongod
        state: started
        enabled: yes
        daemon_reload: yes
      register: mongodb_started
      tags:
        - mongodb
        - mongodb-service

    - name: Wait for MongoDB to be ready
      wait_for:
        port: "{{ mitum_mongodb_port }}"
        host: "{{ mitum_mongodb_bind_ip }}"
        delay: 5
        timeout: 60
      tags:
        - mongodb
        - mongodb-wait

    - name: Check if replica set is already initialized
      shell: |
        mongosh --quiet --eval "rs.status().ok" || echo "0"
      register: rs_status
      changed_when: false
      tags:
        - mongodb
        - mongodb-replica

    - name: Initialize MongoDB replica set
      shell: |
        mongosh --eval '
        rs.initiate({
          _id: "{{ mitum_mongodb_replica_set }}",
          members: [
            { _id: 0, host: "{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}" }
          ]
        })'
      when: rs_status.stdout == "0"
      register: rs_init_result
      tags:
        - mongodb
        - mongodb-replica

    - name: Wait for PRIMARY state
      shell: |
        mongosh --quiet --eval "rs.status().myState"
      register: rs_state
      until: rs_state.stdout == "1"
      retries: 30
      delay: 2
      when: rs_init_result is changed
      tags:
        - mongodb
        - mongodb-replica

    - name: Create MongoDB admin user
      shell: |
        mongosh admin --eval '
        db.createUser({
          user: "{{ mitum_mongodb_admin_user }}",
          pwd: "{{ mitum_mongodb_admin_password }}",
          roles: [
            { role: "userAdminAnyDatabase", db: "admin" },
            { role: "dbAdminAnyDatabase", db: "admin" },
            { role: "readWriteAnyDatabase", db: "admin" },
            { role: "clusterAdmin", db: "admin" }
          ]
        })'
      when: 
        - mitum_mongodb_auth_enabled
        - rs_state.stdout == "1"
      no_log: true
      ignore_errors: yes  # User might already exist
      tags:
        - mongodb
        - mongodb-auth

    - name: Create Mitum database and user
      shell: |
        mongosh -u "{{ mitum_mongodb_admin_user }}" -p "{{ mitum_mongodb_admin_password }}" --authenticationDatabase admin --eval '
        use mitum;
        db.createUser({
          user: "{{ mitum_mongodb_user }}",
          pwd: "{{ mitum_mongodb_password }}",
          roles: [
            { role: "readWrite", db: "mitum" },
            { role: "dbAdmin", db: "mitum" }
          ]
        })'
      when: 
        - mitum_mongodb_auth_enabled
        - rs_state.stdout == "1"
      no_log: true
      ignore_errors: yes  # User might already exist
      tags:
        - mongodb
        - mongodb-auth

  rescue:
    - name: MongoDB setup failed
      debug:
        msg: |
          MongoDB setup encountered an error: {{ ansible_failed_result.msg }}
          Please check the logs at /var/log/mongodb/mongod.log
      tags:
        - mongodb
        - mongodb-error

- name: MongoDB Docker Setup (Alternative)
  block:
    - name: Pull MongoDB Docker image
      docker_image:
        name: "mongo:{{ mitum_mongodb_version }}"
        source: pull
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Create Docker volumes for MongoDB
      docker_volume:
        name: "{{ item }}"
        state: present
      loop:
        - mitum_mongodb_data
        - mitum_mongodb_config
        - mitum_mongodb_logs
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Copy MongoDB configuration for Docker
      copy:
        content: |
          storage:
            dbPath: /data/db
          systemLog:
            destination: file
            path: /var/log/mongodb/mongod.log
            logAppend: true
          net:
            port: {{ mitum_mongodb_port }}
            bindIp: 0.0.0.0
          security:
            authorization: {{ 'enabled' if mitum_mongodb_auth_enabled else 'disabled' }}
          replication:
            replSetName: "{{ mitum_mongodb_replica_set }}"
        dest: /tmp/mongod-docker.conf
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Run MongoDB container
      docker_container:
        name: mitum-mongodb
        image: "mongo:{{ mitum_mongodb_version }}"
        state: started
        restart_policy: unless-stopped
        ports:
          - "{{ mitum_mongodb_port }}:{{ mitum_mongodb_port }}"
        volumes:
          - mitum_mongodb_data:/data/db
          - mitum_mongodb_config:/data/configdb
          - mitum_mongodb_logs:/var/log/mongodb
          - /tmp/mongod-docker.conf:/etc/mongod.conf:ro
        command: ["mongod", "--config", "/etc/mongod.conf"]
        env:
          MONGO_INITDB_ROOT_USERNAME: "{{ mitum_mongodb_admin_user if mitum_mongodb_auth_enabled else '' }}"
          MONGO_INITDB_ROOT_PASSWORD: "{{ mitum_mongodb_admin_password if mitum_mongodb_auth_enabled else '' }}"
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Wait for MongoDB container to be ready
      wait_for:
        port: "{{ mitum_mongodb_port }}"
        host: localhost
        delay: 10
        timeout: 60
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Initialize replica set in Docker
      docker_container_exec:
        container: mitum-mongodb
        command: |
          mongosh --eval '
          rs.initiate({
            _id: "{{ mitum_mongodb_replica_set }}",
            members: [
              { _id: 0, host: "127.0.0.1:{{ mitum_mongodb_port }}" }
            ]
          })'
      when: mitum_mongodb_install_method == 'docker'
      register: docker_rs_init
      ignore_errors: yes
      tags:
        - mongodb
        - mongodb-docker

- name: Verify MongoDB connectivity for Mitum
  block:
    - name: Test MongoDB connection
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongosh -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% else %}
        mongosh --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% endif %}
      register: mongodb_ping
      changed_when: false
      tags:
        - mongodb
        - mongodb-verify

    - name: Display MongoDB connection status
      debug:
        msg: "MongoDB is {{ 'connected and ready' if mongodb_ping.rc == 0 else 'not accessible' }}"
      tags:
        - mongodb
        - mongodb-verify

    - name: Set MongoDB connection fact for Mitum
      set_fact:
        mitum_mongodb_uri: >-
          {% if mitum_mongodb_auth_enabled %}
          mongodb://{{ mitum_mongodb_user }}:{{ mitum_mongodb_password }}@{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}/mitum?replicaSet={{ mitum_mongodb_replica_set }}
          {% else %}
          mongodb://{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}/mitum?replicaSet={{ mitum_mongodb_replica_set }}
          {% endif %}
      tags:
        - mongodb
        - mongodb-verify

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/service.yml
================================================================================
---
# Service management tasks for Mitum

- name: Ensure systemd service file exists
  stat:
    path: "/etc/systemd/system/{{ mitum_service_name }}.service"
  register: service_file

- name: Create systemd service if not exists
  when: not service_file.stat.exists
  template:
    src: mitum.service.j2
    dest: "/etc/systemd/system/{{ mitum_service_name }}.service"
    owner: root
    group: root
    mode: '0644'
  notify:
    - reload systemd

- name: Reload systemd daemon
  systemd:
    daemon_reload: yes
  when: not service_file.stat.exists

- name: Enable Mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    enabled: yes

- name: Check if initial start
  stat:
    path: "{{ mitum_data_dir }}/.initialized"
  register: initialized

- name: Start Mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    state: started
  register: service_start
  when: mitum_deployment_phase | default('all') in ['all', 'start']

- name: Wait for service to be ready
  wait_for:
    port: "{{ mitum_node_port }}"
    host: "{{ ansible_default_ipv4.address }}"
    state: started
    delay: 5
    timeout: 60
  when: service_start is changed

- name: Verify service health
  uri:
    url: "http://localhost:{{ mitum_node_port }}/v2/node"
    status_code: 200
    timeout: 10
  retries: 10
  delay: 3
  register: health_check
  until: health_check.status == 200
  when: 
    - service_start is changed
    - mitum_validate_startup | default(true)

- name: Check API service (API nodes only)
  uri:
    url: "http://localhost:{{ mitum_api_port }}/v2/node"
    status_code: 200
    timeout: 10
  retries: 10
  delay: 3
  when: 
    - mitum_api_enabled | default(false)
    - service_start is changed

- name: Mark as initialized
  file:
    path: "{{ mitum_data_dir }}/.initialized"
    state: touch
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
  when: 
    - not initialized.stat.exists
    - health_check is succeeded

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/roles/mitum/tasks/system-prepare.yml
================================================================================
---
# System preparation tasks

- name: Install required system packages
  package:
    name:
      - git
      - build-essential
      - jq
      - curl
      - wget
      - ca-certificates
      - gnupg
      - lsb-release
    state: present
    update_cache: yes

- name: Create mitum group
  group:
    name: "{{ mitum_service_group }}"
    state: present
    system: yes

- name: Create mitum user
  user:
    name: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    home: "{{ mitum_install_dir }}"
    shell: /bin/bash
    system: yes
    create_home: yes

- name: Create required directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'
  loop:
    - "{{ mitum_install_dir }}"
    - "{{ mitum_config_dir }}"
    - "{{ mitum_keys_dir }}"
    - "{{ mitum_data_dir }}"
    - "{{ mitum_log_dir }}"
    - "{{ mitum_backup_dir }}"

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/rolling-upgrade.yml
================================================================================
---
# Safe Rolling Upgrade Playbook
# Version: 4.0.0 - With health checks and automatic rollback
#
# This playbook safely upgrades Mitum nodes one by one.
# 
# Features:
# - Upgrades one node at a time
# - Health checks at each step
# - Automatic rollback on failure
# - Maintains consensus
# - Zero downtime

- name: Rolling upgrade preparation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Validate upgrade parameters
      assert:
        that:
          - mitum_version is defined
          - mitum_version != "latest"  # Specific version required
        fail_msg: "Specific version required for upgrade (not 'latest')"

    - name: Set upgrade metadata
      set_fact:
        upgrade_id: "upgrade-{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
        upgrade_start_time: "{{ ansible_date_time.epoch }}"
        rollback_enabled: "{{ enable_rollback | default(true) }}"
        
    - name: Display upgrade plan
      debug:
        msg: |
          ========================================
          Rolling Upgrade Plan
          ========================================
          Upgrade ID: {{ upgrade_id }}
          Current Version: (will be detected)
          Target Version: {{ mitum_version }}
          Rollback Enabled: {{ rollback_enabled }}
          
          Nodes to upgrade: {{ groups['mitum_nodes'] | length }}
          Batch Size: {{ mitum_upgrade.batch_size | default(1) }}
          Batch Delay: {{ mitum_upgrade.batch_delay | default(60) }}s
          ========================================

# === Gather Current State ===
- name: Gather current state
  hosts: mitum_nodes
  gather_facts: yes
  tasks:
    - name: Get current Mitum version
      command: "{{ mitum_install_dir }}/mitum version"
      register: current_version_raw
      changed_when: false
      failed_when: false

    - name: Parse version
      set_fact:
        current_mitum_version: "{{ current_version_raw.stdout | regex_search('v[0-9.]+') | default('unknown') }}"

    - name: Check node health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: node_health
      failed_when: false

    - name: Get consensus state
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/consensus/state"
        timeout: 5
      register: consensus_state
      failed_when: false
      when: not (mitum_api_enabled | default(false))

    - name: Save current state
      set_fact:
        node_state:
          hostname: "{{ inventory_hostname }}"
          current_version: "{{ current_mitum_version }}"
          is_healthy: "{{ node_health.status | default(0) == 200 }}"
          consensus_state: "{{ consensus_state.json.consensus.state | default('N/A') if consensus_state.json is defined else 'N/A' }}"
          role: "{{ 'api' if mitum_api_enabled | default(false) else 'consensus' }}"

# === Pre-upgrade Validation ===
- name: Pre-upgrade validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Aggregate node states
      set_fact:
        all_nodes_state: "{{ groups['mitum_nodes'] | map('extract', hostvars, 'node_state') | list }}"

    - name: Check if upgrade needed
      set_fact:
        nodes_need_upgrade: "{{ all_nodes_state | selectattr('current_version', 'ne', mitum_version) | list }}"

    - name: Display current state
      debug:
        msg: |
          Current cluster state:
          {% for node in all_nodes_state %}
          - {{ node.hostname }}: {{ node.current_version }} ({{ node.role }}) - {{ 'Healthy' if node.is_healthy else 'Unhealthy' }}
          {% endfor %}
          
          Nodes requiring upgrade: {{ nodes_need_upgrade | length }}

    - name: Verify cluster health
      assert:
        that:
          - all_nodes_state | selectattr('is_healthy', 'equalto', true) | list | length >= (groups['mitum_nodes'] | length * 0.8)
        fail_msg: "Cluster not healthy enough for upgrade. Please fix issues first."

    - name: Skip if no upgrade needed
      meta: end_play
      when: nodes_need_upgrade | length == 0

# === Create Pre-upgrade Backup ===
- name: Create pre-upgrade backup
  import_playbook: backup.yml
  vars:
    backup_type: "pre-upgrade"
    backup_tag: "{{ upgrade_id }}"
  when: mitum_upgrade.backup_before_upgrade | default(true)

# === Upgrade Consensus Nodes ===
- name: Upgrade consensus nodes
  hosts: mitum_nodes
  serial: "{{ mitum_upgrade.batch_size | default(1) }}"
  max_fail_percentage: 0
  become: yes
  
  # Skip API nodes in this phase
  gather_facts: no
  tasks:
    - name: Skip API nodes in consensus phase
      meta: end_host
      when: mitum_api_enabled | default(false)

    - name: Include upgrade tasks
      include_tasks: tasks/upgrade-node.yml
      vars:
        node_type: "consensus"

# === Upgrade API/Syncer Nodes ===
- name: Upgrade API/syncer nodes
  hosts: mitum_nodes
  serial: "{{ mitum_upgrade.batch_size | default(1) }}"
  become: yes
  gather_facts: no
  
  tasks:
    - name: Skip consensus nodes
      meta: end_host
      when: not (mitum_api_enabled | default(false))

    - name: Include upgrade tasks
      include_tasks: tasks/upgrade-node.yml
      vars:
        node_type: "api"

# === Post-upgrade Validation ===
- name: Post-upgrade validation
  hosts: mitum_nodes
  gather_facts: no
  tasks:
    - name: Verify upgraded version
      command: "{{ mitum_install_dir }}/mitum version"
      register: new_version_raw
      changed_when: false

    - name: Parse new version
      set_fact:
        new_mitum_version: "{{ new_version_raw.stdout | regex_search('v[0-9.]+') | default('unknown') }}"

    - name: Verify version matches target
      assert:
        that:
          - new_mitum_version == mitum_version
        fail_msg: "Version mismatch: expected {{ mitum_version }}, got {{ new_mitum_version }}"

    - name: Check node health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: final_health
      retries: 10
      delay: 6

    - name: Verify consensus participation
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/consensus/state"
        timeout: 5
      register: final_consensus
      when: not (mitum_api_enabled | default(false))
      retries: 10
      delay: 6

# === Final Cluster Validation ===
- name: Final cluster validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Aggregate final states
      set_fact:
        final_nodes_state: "{{ groups['mitum_nodes'] | map('extract', hostvars, ['new_mitum_version']) | list }}"

    - name: Check all nodes upgraded
      assert:
        that:
          - final_nodes_state | select('equalto', mitum_version) | list | length == groups['mitum_nodes'] | length
        fail_msg: "Not all nodes successfully upgraded"

    - name: Calculate upgrade duration
      set_fact:
        upgrade_duration: "{{ (ansible_date_time.epoch | int) - (upgrade_start_time | int) }}"

    - name: Display upgrade summary
      debug:
        msg: |
          ========================================
          Rolling Upgrade Complete!
          ========================================
          Upgrade ID: {{ upgrade_id }}
          Duration: {{ upgrade_duration }} seconds
          
          All nodes successfully upgraded to {{ mitum_version }}
          
          Next steps:
          1. Monitor cluster: make status
          2. Check logs: make logs
          3. Verify API: curl http://<api-node>:{{ mitum_api_port }}/v2/node
          ========================================

# === Failure Handler ===
- name: Upgrade failure handler
  hosts: all
  gather_facts: no
  tasks:
    - name: Trigger rollback if enabled
      include_tasks: tasks/rollback-node.yml
      when: 
        - rollback_enabled | default(true)
        - ansible_failed_task is defined
        - ansible_failed_result is defined

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/setup-monitoring.yml
================================================================================
---
# Setup Prometheus monitoring for Mitum nodes

- name: Deploy Prometheus monitoring stack
  hosts: monitoring
  become: yes
  vars:
    prometheus_version: "2.45.0"
    alertmanager_version: "0.26.0"
    grafana_version: "10.2.0"
  
  tasks:
    - name: Create monitoring user
      user:
        name: prometheus
        system: yes
        shell: /usr/sbin/nologin
        home: /var/lib/prometheus
        create_home: no

    - name: Create prometheus directories
      file:
        path: "{{ item }}"
        state: directory
        owner: prometheus
        group: prometheus
        mode: '0755'
      loop:
        - /etc/prometheus
        - /etc/prometheus/rules
        - /var/lib/prometheus

    - name: Download Prometheus
      unarchive:
        src: "https://github.com/prometheus/prometheus/releases/download/v{{ prometheus_version }}/prometheus-{{ prometheus_version }}.linux-amd64.tar.gz"
        dest: /tmp
        remote_src: yes
        creates: /tmp/prometheus-{{ prometheus_version }}.linux-amd64

    - name: Install Prometheus binaries
      copy:
        src: "/tmp/prometheus-{{ prometheus_version }}.linux-amd64/{{ item }}"
        dest: "/usr/local/bin/{{ item }}"
        owner: root
        group: root
        mode: '0755'
        remote_src: yes
      loop:
        - prometheus
        - promtool

    - name: Configure Prometheus
      template:
        src: prometheus.yml.j2
        dest: /etc/prometheus/prometheus.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus

    - name: Create Prometheus service
      template:
        src: prometheus.service.j2
        dest: /etc/systemd/system/prometheus.service
      notify:
        - reload systemd
        - restart prometheus

    - name: Configure Alertmanager
      when: mitum_alerting_enabled | default(true)
      block:
        - name: Download Alertmanager
          unarchive:
            src: "https://github.com/prometheus/alertmanager/releases/download/v{{ alertmanager_version }}/alertmanager-{{ alertmanager_version }}.linux-amd64.tar.gz"
            dest: /tmp
            remote_src: yes

        - name: Install Alertmanager
          copy:
            src: "/tmp/alertmanager-{{ alertmanager_version }}.linux-amd64/alertmanager"
            dest: /usr/local/bin/alertmanager
            mode: '0755'
            remote_src: yes

        - name: Configure Alertmanager
          template:
            src: alertmanager.yml.j2
            dest: /etc/prometheus/alertmanager.yml

        - name: Create Alertmanager service
          template:
            src: alertmanager.service.j2
            dest: /etc/systemd/system/alertmanager.service

    - name: Start monitoring services
      systemd:
        name: "{{ item }}"
        state: started
        enabled: yes
        daemon_reload: yes
      loop:
        - prometheus
        - alertmanager

- name: Configure nodes for monitoring
  hosts: mitum_nodes
  become: yes
  tasks:
    - name: Setup node monitoring
      include_role:
        name: mitum
        tasks_from: monitoring-prometheus

    - name: Configure firewall for monitoring
      ufw:
        rule: allow
        port: "{{ item }}"
        src: "{{ hostvars[groups['monitoring'][0]]['ansible_default_ipv4']['address'] }}"
      loop:
        - "9100"  # Node exporter
        - "9099"  # Mitum metrics
        - "9216"  # MongoDB exporter
      when: ansible_os_family == "Debian"

- name: Setup AWX integration
  hosts: localhost
  tasks:
    - name: Configure AWX monitoring
      include_tasks: awx-integration.yml
      when: awx_integration_enabled | default(false)

================================================================================
íŒŒì¼: backup_20250725_145148/core-files/site.yml
================================================================================
---
# Main Site Playbook for Mitum Deployment
# Version: 4.0.0 - Enhanced with pre/post checks and modular structure
#
# This playbook orchestrates the entire Mitum blockchain deployment.
# 
# Execution order:
# 1. Pre-flight checks
# 2. System preparation
# 3. MongoDB installation and configuration
# 4. Mitum key generation
# 5. Mitum node deployment
# 6. Monitoring setup (optional)
# 7. Post-deployment validation
#
# Usage:
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml
#
# Execute specific stages only:
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml --tags prepare
#
# Dry run (preview changes):
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml --check

# === Set Deployment Metadata ===
- name: Set deployment metadata
  hosts: all
  gather_facts: no
  tags: [always]
  tasks:
    - name: Set deployment ID and timestamp
      set_fact:
        deployment_id: "{{ deployment_id | default(lookup('pipe', 'date +%Y%m%d-%H%M%S')) }}"
        deployment_timestamp: "{{ ansible_date_time.iso8601 }}"
        deployment_user: "{{ lookup('env', 'USER') }}"
      run_once: true
      delegate_to: localhost

    - name: Display deployment information
      debug:
        msg: |
          ========================================
          Mitum Deployment Started
          ========================================
          Deployment ID: {{ deployment_id }}
          Environment: {{ mitum_environment }}
          Network ID: {{ mitum_network_id }}
          Model Type: {{ mitum_model_type }}
          User: {{ deployment_user }}
          Timestamp: {{ deployment_timestamp }}
          ========================================
      run_once: true

# === 1. Pre-deployment Validation ===
- name: Pre-deployment validation
  import_playbook: pre-deploy-check.yml
  tags: [precheck, validation]

# === 2. System Preparation ===
- name: Prepare systems
  import_playbook: prepare-system.yml
  tags: [prepare, system]
  when: not skip_prepare | default(false)

# === 3. SSH Host Key Collection (Security) ===
- name: Gather SSH host keys
  import_playbook: gather-host-keys.yml
  tags: [security, ssh]
  when: strict_host_key_checking | default(true)

# === 4. MongoDB Installation ===
- name: Setup MongoDB
  import_playbook: setup-mongodb.yml
  tags: [mongodb, database]
  when: not skip_mongodb | default(false)

# === 5. Key Generation ===
- name: Generate Mitum keys
  import_playbook: keygen.yml
  tags: [keygen, keys]
  when: not skip_keygen | default(false)

# === 6. Mitum Deployment ===
- name: Deploy Mitum nodes
  import_playbook: deploy-mitum.yml
  tags: [deploy, mitum]

# === 7. Monitoring Setup (Optional) ===
- name: Setup monitoring
  import_playbook: setup-monitoring.yml
  tags: [monitoring]
  when: 
    - mitum_monitoring.enabled | default(false)
    - groups['monitoring'] is defined
    - groups['monitoring'] | length > 0

# === 8. Backup Configuration ===
- name: Configure backup
  import_playbook: setup-backup.yml
  tags: [backup]
  when: mitum_backup.enabled | default(false)

# === 9. Post-deployment Validation ===
- name: Post-deployment validation
  import_playbook: post-deploy-check.yml
  tags: [postcheck, validation]

# === 10. Deployment Summary ===
- name: Deployment summary
  hosts: localhost
  gather_facts: no
  tags: [always]
  tasks:
    - name: Generate deployment report
      template:
        src: deployment-report.j2
        dest: "{{ playbook_dir }}/../reports/deployment-{{ deployment_id }}.txt"
      delegate_to: localhost
      run_once: true

    - name: Display deployment summary
      debug:
        msg: |
          ========================================
          Mitum Deployment Complete!
          ========================================
          Deployment ID: {{ deployment_id }}
          Duration: {{ (ansible_date_time.epoch | int) - (deployment_start_time | default(ansible_date_time.epoch) | int) }} seconds
          
          Nodes Deployed: {{ groups['mitum_nodes'] | length }}
          - Consensus: {{ groups['mitum_nodes'] | select('match', '.*consensus.*') | list | length }}
          - API/Syncer: {{ groups['mitum_nodes'] | select('match', '.*api.*') | list | length }}
          
          Services Status:
          - MongoDB: {{ mongodb_status | default('Unknown') }}
          - Mitum: {{ mitum_status | default('Unknown') }}
          - Monitoring: {{ monitoring_status | default('N/A') }}
          
          Next Steps:
          1. Check status: make status
          2. View logs: make logs
          3. Access API: curl http://<api-node>:{{ mitum_api_port }}/v2/node
          
          Report saved to: reports/deployment-{{ deployment_id }}.txt
          ========================================
      run_once: true

# === Error Handling ===
- name: Deployment failure handler
  hosts: all
  gather_facts: no
  tags: [always]
  tasks:
    - name: Deployment failed notification
      debug:
        msg: |
          ========================================
          DEPLOYMENT FAILED!
          ========================================
          Error in: {{ ansible_failed_task.name | default('Unknown task') }}
          Host: {{ ansible_hostname | default('Unknown host') }}
          
          Please check:
          1. Ansible logs: logs/ansible.log
          2. Host connectivity: make test
          3. Requirements: make validate
          
          Rollback instructions:
          1. Restore from backup: make restore BACKUP_TIMESTAMP=<timestamp>
          2. Or clean install: make clean-data && make deploy
          ========================================
      when: ansible_failed_task is defined
      run_once: true

================================================================================
íŒŒì¼: inventories/development/group_vars/all.yml
================================================================================
---
# Mitum configuration
mitum_version: "latest"
mitum_model_type: "mitum-currency"
mitum_install_method: "source"

# Key generation
mitum_keygen_strategy: "centralized"
mitum_nodejs_version: "18"
mitum_mitumjs_version: "^2.1.15"

# Paths
mitum_install_dir: "/opt/mitum"
mitum_data_dir: "/opt/mitum/data"
mitum_config_dir: "/opt/mitum/config"
mitum_keys_dir: "/opt/mitum/keys"
mitum_log_dir: "/var/log/mitum"

# MongoDB
mitum_mongodb_version: "7.0"
mitum_mongodb_install_method: "native"
mitum_mongodb_replica_set: "mitum"

# Service
mitum_service_name: "mitum"
mitum_service_user: "mitum"
mitum_service_group: "mitum"

# Monitoring
mitum_monitoring:
  enabled: false
  prometheus_enabled: false

================================================================================
íŒŒì¼: inventories/development/hosts.yml
================================================================================
---
all:
  children:
    mitum_nodes:
      hosts:
        node0:
          ansible_host: 127.0.0.1
          ansible_port: 2222
          mitum_node_id: 0
          mitum_node_port: 4320
          mitum_api_enabled: true
          mitum_api_port: 54320
        node1:
          ansible_host: 127.0.0.1
          ansible_port: 2223
          mitum_node_id: 1
          mitum_node_port: 4321
          mitum_api_enabled: false
      vars:
        ansible_user: vagrant
        ansible_ssh_private_key_file: ~/.vagrant.d/insecure_private_key
        mitum_network_id: "mitum-dev"
        mitum_keygen_strategy: "centralized"
        mitum_mongodb_install_method: "docker"

================================================================================
íŒŒì¼: inventories/production/group_vars/all.yml
================================================================================
---
# Environment-specific variables for production
# Generated: Wed Jul 23 15:28:54 KST 2025

# Environment settings
mitum_environment: "production"
mitum_network_id: "testnet"
mitum_model_type: "mitum-currency"

# Version configuration
mitum_version: "latest"
mitum_install_method: "source"

# Network configuration
mitum_nodes_subnet: "192.168.50"
mitum_bastion_host: "3.34.138.191"
mitum_bastion_user: "ubuntu"

# SSH configuration
mitum_ssh_via_bastion: true
mitum_bastion_key: "keys/ssh/production/bastion.pem"

# Feature flags based on model
mitum_features:
  enable_api: true
  enable_digest: true
  enable_metrics: true
  enable_profiler: false

================================================================================
íŒŒì¼: inventories/production/hosts.yml
================================================================================
---
all:
  children:
    bastion:
      hosts:
        bastion:
          ansible_host: 3.34.138.191
          ansible_user: ubuntu
          ansible_ssh_private_key_file: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/bastion.pem
          ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
    
    mitum_nodes:
      hosts:
        node0:
          ansible_host: 192.168.50.88
          ansible_user: ubuntu
          ansible_ssh_private_key_file: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/imfact-dev-01
          ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyCommand="ssh -W %h:%p -o StrictHostKeyChecking=no -i /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/bastion.pem ubuntu@3.34.138.191"'
          mitum_node_id: 0
          mitum_node_port: 4320

        node1:
          ansible_host: 192.168.50.89
          ansible_user: ubuntu
          ansible_ssh_private_key_file: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/imfact-dev-01
          ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyCommand="ssh -W %h:%p -o StrictHostKeyChecking=no -i /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/bastion.pem ubuntu@3.34.138.191"'
          mitum_node_id: 1
          mitum_node_port: 4321

        node2:
          ansible_host: 192.168.50.90
          ansible_user: ubuntu
          ansible_ssh_private_key_file: /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/imfact-dev-01
          ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyCommand="ssh -W %h:%p -o StrictHostKeyChecking=no -i /Users/user/Desktop/mitum-ansible-deploy/mitum-ansible/keys/ssh/production/bastion.pem ubuntu@3.34.138.191"'
          mitum_node_id: 2
          mitum_node_port: 4322
          mitum_api_enabled: true
          mitum_api_port: 54320

      vars:
        mitum_network_id: "testnet"
        mitum_model_type: "mitum-currency"

================================================================================
íŒŒì¼: keys/README.md
================================================================================
# Keys Directory

This directory stores SSH keys and Mitum blockchain keys.

## Directory Structure

```
keys/
â”œâ”€â”€ ssh/                    # SSH keys for server access
â”‚   â”œâ”€â”€ production/        # Production environment keys
â”‚   â”‚   â”œâ”€â”€ bastion.pem   # Bastion host SSH key
â”‚   â”‚   â””â”€â”€ nodes.pem     # Node SSH keys
â”‚   â”œâ”€â”€ staging/          # Staging environment keys
â”‚   â””â”€â”€ development/      # Development environment keys
â””â”€â”€ mitum/                 # Mitum blockchain keys (auto-generated)
    â”œâ”€â”€ production/       # Production blockchain keys
    â”œâ”€â”€ staging/         # Staging blockchain keys
    â””â”€â”€ development/     # Development blockchain keys
```

## Adding SSH Keys

1. Copy your PEM files to the appropriate environment folder:
   ```bash
   cp ~/Downloads/my-aws-key.pem keys/ssh/production/bastion.pem
   chmod 600 keys/ssh/production/bastion.pem
   ```

2. The inventory generator will automatically look for keys in:
   - `keys/ssh/{environment}/bastion.pem`
   - `keys/ssh/{environment}/nodes.pem`

## Security Notes

- All key files are ignored by git (see .gitignore)
- Keep permissions at 600 for all key files
- Never commit keys to version control
- Use different keys for each environment

================================================================================
íŒŒì¼: keys/testnet/config-key.txt
================================================================================
# Generated keys (legacy format)
# Generated at: 2025-07-24T04:22:04.222Z
# Generated using mitum-keygen.js for Ansible

// Node 0
{
  privatekey: '043ff84c5aeddac343734dfd53315df485aeeb38161ab79f386a200d38e06c6cfpr',
  publickey: '02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu',
  address: '0x5fcd452b2af79b55957018b5b1cd2d574d20F638fca'
}

// Node 1
{
  privatekey: '6687b05ee7a5019178dfcb201723e7401aca4f300adc1855ef6ca91f27d88036fpr',
  publickey: '02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu',
  address: '0xe4714f30cdF316acea340f6B8641Ea19CF563d85fca'
}

// Node 2
{
  privatekey: 'e7a59ffcbb080f656a2f616e2eba6c11f61e656e3ebfb90bdd09efdc3eff2fdefpr',
  publickey: '026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu',
  address: '0x4dC32133877c191b0cc74BE530839Eb2053Ee5Ddfca'
}

================================================================================
íŒŒì¼: keys/testnet/genesis-account.json
================================================================================
{
  "address": "0x5fcd452b2af79b55957018b5b1cd2d574d20F638fca",
  "keys": [
    {
      "key": "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu",
      "weight": 33
    },
    {
      "key": "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu",
      "weight": 33
    },
    {
      "key": "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu",
      "weight": 34
    }
  ],
  "threshold": 100
}

================================================================================
íŒŒì¼: keys/testnet/keys-summary.json
================================================================================
{
  "network_id": "testnet",
  "generated_at": "2025-07-24T04:22:04.042Z",
  "node_count": 3,
  "threshold": 100,
  "key_type": "btc",
  "nodes": [
    {
      "node_id": 0,
      "address": "testnet0sas",
      "public_key": "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu",
      "type": "btc"
    },
    {
      "node_id": 1,
      "address": "testnet1sas",
      "public_key": "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu",
      "type": "btc"
    },
    {
      "node_id": 2,
      "address": "testnet2sas",
      "public_key": "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu",
      "type": "btc"
    }
  ],
  "genesis_account": {
    "address": "0x5fcd452b2af79b55957018b5b1cd2d574d20F638fca",
    "keys": [
      {
        "key": "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu",
        "weight": 33
      },
      {
        "key": "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu",
        "weight": 33
      },
      {
        "key": "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu",
        "weight": 34
      }
    ],
    "threshold": 100
  }
}

================================================================================
íŒŒì¼: keys/testnet/keys-summary.yml
================================================================================
---
# Generated by mitum-keygen.js
# Network: testnet
# Generated at: 2025-07-24T04:22:04.042Z

network_id: "testnet"
node_count: 3
threshold: 100
key_type: "btc"

nodes:
  - node_id: 0
    address: "testnet0sas"
    public_key: "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu"
    type: "btc"
  - node_id: 1
    address: "testnet1sas"
    public_key: "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu"
    type: "btc"
  - node_id: 2
    address: "testnet2sas"
    public_key: "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu"
    type: "btc"

genesis_account:
  address: "0x5fcd452b2af79b55957018b5b1cd2d574d20F638fca"
  threshold: 100
  keys:
    - key: "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu"
      weight: 33
    - key: "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu"
      weight: 33
    - key: "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu"
      weight: 34

================================================================================
íŒŒì¼: keys/testnet/node-keys.json
================================================================================
[
  {
    "privatekey": "043ff84c5aeddac343734dfd53315df485aeeb38161ab79f386a200d38e06c6cfpr",
    "publickey": "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu",
    "address": "0x5fcd452b2af79b55957018b5b1cd2d574d20F638fca"
  },
  {
    "privatekey": "6687b05ee7a5019178dfcb201723e7401aca4f300adc1855ef6ca91f27d88036fpr",
    "publickey": "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu",
    "address": "0xe4714f30cdF316acea340f6B8641Ea19CF563d85fca"
  },
  {
    "privatekey": "e7a59ffcbb080f656a2f616e2eba6c11f61e656e3ebfb90bdd09efdc3eff2fdefpr",
    "publickey": "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu",
    "address": "0x4dC32133877c191b0cc74BE530839Eb2053Ee5Ddfca"
  }
]

================================================================================
íŒŒì¼: keys/testnet/node0/node.json
================================================================================
{
  "node_id": 0,
  "address": "testnet0sas",
  "public_key": "02cd340a4d3f4541d3531208adc4d9b73e78320f4a9925d77a4481622b84b94fb8fpu",
  "private_key": "043ff84c5aeddac343734dfd53315df485aeeb38161ab79f386a200d38e06c6cfpr",
  "type": "btc",
  "hint": "mpr"
}

================================================================================
íŒŒì¼: keys/testnet/node1/node.json
================================================================================
{
  "node_id": 1,
  "address": "testnet1sas",
  "public_key": "02c5ec3050581c3c63f9f90e8ba3bf0fe87b537f69f3112e1c1580ac721246e6b2fpu",
  "private_key": "6687b05ee7a5019178dfcb201723e7401aca4f300adc1855ef6ca91f27d88036fpr",
  "type": "btc",
  "hint": "mpr"
}

================================================================================
íŒŒì¼: keys/testnet/node2/node.json
================================================================================
{
  "node_id": 2,
  "address": "testnet2sas",
  "public_key": "026f20337e088cec0224048e950a52b53ec3e938245db87fa3f45504d3d73a99d2fpu",
  "private_key": "e7a59ffcbb080f656a2f616e2eba6c11f61e656e3ebfb90bdd09efdc3eff2fdefpr",
  "type": "btc",
  "hint": "mpr"
}

================================================================================
íŒŒì¼: merge_code.py
================================================================================
#!/usr/bin/env python3
"""
í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ì½”ë“œ íŒŒì¼ì„ í•˜ë‚˜ì˜ í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ í†µí•©í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸
ëŒ€ìš©ëŸ‰ í”„ë¡œì íŠ¸ëŠ” ìžë™ìœ¼ë¡œ ì—¬ëŸ¬ íŒŒì¼ë¡œ ë¶„í• 
"""

import os
import sys
from pathlib import Path
from datetime import datetime
import argparse

# ê¸°ë³¸ ì œì™¸ íŒ¨í„´
DEFAULT_EXCLUDE_DIRS = {
    '.git', '__pycache__', 'node_modules', '.venv', 'venv', 
    'env', '.env', 'dist', 'build', '.idea', '.vscode',
    'coverage', '.pytest_cache', '.mypy_cache', 'htmlcov',
    '.next', '.nuxt', 'out', '.cache', 'tmp', 'temp'
}

DEFAULT_EXCLUDE_FILES = {
    '.DS_Store', 'Thumbs.db', '.gitignore', '.env',
    '*.pyc', '*.pyo', '*.pyd', '*.so', '*.dll', '*.dylib',
    '*.class', '*.jar', '*.war', '*.ear',
    '*.log', '*.pot', '*.mo', '*.po',
    '*.db', '*.sqlite', '*.sqlite3',
    '*.jpg', '*.jpeg', '*.png', '*.gif', '*.ico', '*.svg',
    '*.mp3', '*.mp4', '*.avi', '*.mov', '*.wmv',
    '*.pdf', '*.doc', '*.docx', '*.xls', '*.xlsx',
    '*.zip', '*.tar', '*.gz', '*.rar', '*.7z',
    '*.exe', '*.msi', '*.app', '*.deb', '*.rpm'
}

# ì½”ë“œ íŒŒì¼ í™•ìž¥ìž
CODE_EXTENSIONS = {
    # í”„ë¡œê·¸ëž˜ë° ì–¸ì–´
    '.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.c', '.cpp', 
    '.cc', '.cxx', '.h', '.hpp', '.cs', '.php', '.rb', '.go',
    '.rs', '.swift', '.kt', '.scala', '.r', '.m', '.mm',
    '.pl', '.pm', '.lua', '.dart', '.elm', '.clj', '.cljs',
    '.ex', '.exs', '.erl', '.hrl', '.hs', '.lhs', '.ml', '.mli',
    '.fs', '.fsi', '.fsx', '.v', '.vhd', '.vhdl',
    
    # ì›¹ ê´€ë ¨
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    '.vue', '.svelte', '.astro',
    
    # ì„¤ì •/ë°ì´í„°
    '.json', '.xml', '.yaml', '.yml', '.toml', '.ini', '.cfg',
    '.conf', '.config', '.env.example', '.properties',
    
    # ìŠ¤í¬ë¦½íŠ¸/ì…¸
    '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd',
    
    # ê¸°íƒ€
    '.sql', '.graphql', '.gql', '.proto', '.thrift',
    '.md', '.rst', '.txt', '.dockerfile', 'Dockerfile',
    'Makefile', 'makefile', 'CMakeLists.txt', '.gitignore',
    '.dockerignore', '.editorconfig', '.prettierrc',
    '.eslintrc', 'package.json', 'requirements.txt',
    'Gemfile', 'Cargo.toml', 'go.mod', 'pom.xml',
    'build.gradle', '.gitlab-ci.yml', '.travis.yml',
    'docker-compose.yml', 'docker-compose.yaml'
}

# Claude ëŒ€í™” ìš©ëŸ‰ ì œí•œ ì„¤ì • (ë°”ì´íŠ¸)
# ì•ˆì „í•œ ê¸°ë³¸ê°’: 1MB (ClaudeëŠ” ë³´í†µ 100K í† í° ì œí•œ, 1í† í° â‰ˆ 4ë°”ì´íŠ¸)
DEFAULT_MAX_SIZE = 1 * 1024 * 1024  # 1MB
SAFE_MAX_SIZE = 500 * 1024  # 500KB (ë§¤ìš° ì•ˆì „)
LARGE_MAX_SIZE = 2 * 1024 * 1024  # 2MB (í° ëŒ€í™”ì°½)

def should_include_file(file_path, include_extensions=None):
    """íŒŒì¼ì„ í¬í•¨í• ì§€ ê²°ì •"""
    file_name = file_path.name
    
    # íŠ¹ì • íŒŒì¼ëª…ì€ í™•ìž¥ìžì™€ ê´€ê³„ì—†ì´ í¬í•¨
    special_files = {
        'Dockerfile', 'Makefile', 'makefile', 'CMakeLists.txt',
        'package.json', 'requirements.txt', 'Gemfile', 'Cargo.toml',
        'go.mod', 'pom.xml', 'build.gradle'
    }
    
    if file_name in special_files:
        return True
    
    # í™•ìž¥ìž í™•ì¸
    if include_extensions:
        return file_path.suffix.lower() in include_extensions
    else:
        return file_path.suffix.lower() in CODE_EXTENSIONS

def should_exclude_path(path, exclude_patterns):
    """ê²½ë¡œë¥¼ ì œì™¸í• ì§€ ê²°ì •"""
    path_str = str(path)
    
    for pattern in exclude_patterns:
        if '*' in pattern:
            # ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì²˜ë¦¬
            import fnmatch
            if fnmatch.fnmatch(path.name, pattern):
                return True
        else:
            # ì¼ë°˜ ë¬¸ìžì—´ ë§¤ì¹­
            if pattern in path_str:
                return True
    
    return False

def get_file_content(file_path):
    """íŒŒì¼ ë‚´ìš©ì„ ì•ˆì „í•˜ê²Œ ì½ê¸°"""
    encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp949', 'euc-kr']
    
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except UnicodeDecodeError:
            continue
        except Exception as e:
            return f"# íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: {str(e)}"
    
    return "# íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (ì¸ì½”ë”© ë¬¸ì œ)"

def format_file_header(file_path, project_root):
    """íŒŒì¼ í—¤ë” í¬ë§·íŒ…"""
    relative_path = file_path.relative_to(project_root)
    separator = "=" * 80
    
    return f"""
{separator}
íŒŒì¼: {relative_path}
{separator}
"""

def estimate_size(content):
    """ì½˜í…ì¸ ì˜ ì˜ˆìƒ í¬ê¸° ê³„ì‚° (ë°”ì´íŠ¸)"""
    return len(content.encode('utf-8'))

def create_file_tree(all_files, project_root):
    """íŒŒì¼ íŠ¸ë¦¬ êµ¬ì¡° ìƒì„±"""
    tree_content = "## ðŸ“ ë””ë ‰í† ë¦¬ êµ¬ì¡°\n\n```\n"
    printed_dirs = set()
    
    for file_path in all_files:
        relative_path = file_path.relative_to(project_root)
        
        # ìƒìœ„ ë””ë ‰í† ë¦¬ë“¤ ì¶œë ¥
        for i, parent in enumerate(relative_path.parents[:-1]):
            if parent not in printed_dirs:
                indent = "  " * (len(relative_path.parents) - i - 2)
                tree_content += f"{indent}{parent.name}/\n"
                printed_dirs.add(parent)
        
        # íŒŒì¼ ì¶œë ¥
        indent = "  " * (len(relative_path.parents) - 1)
        tree_content += f"{indent}{file_path.name}\n"
    
    tree_content += "```\n\n"
    return tree_content

def write_header(out_file, project_root, part_num=None, total_parts=None):
    """íŒŒì¼ í—¤ë” ìž‘ì„±"""
    header = f"""# í”„ë¡œì íŠ¸ ì½”ë“œ í†µí•© íŒŒì¼"""
    
    if part_num and total_parts:
        header += f" (íŒŒíŠ¸ {part_num}/{total_parts})"
    
    header += f"""
# ìƒì„±ì¼ì‹œ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# í”„ë¡œì íŠ¸ ê²½ë¡œ: {project_root}

"""
    out_file.write(header)

def write_statistics(out_file, file_count, total_lines, file_types, file_size):
    """í†µê³„ ì •ë³´ ìž‘ì„±"""
    out_file.write(f"\n\n{'=' * 80}\n")
    out_file.write("## ðŸ“Š í†µê³„ ì •ë³´\n\n")
    out_file.write(f"- ì´ íŒŒì¼ ìˆ˜: {file_count:,}ê°œ\n")
    out_file.write(f"- ì´ ë¼ì¸ ìˆ˜: {total_lines:,}ì¤„\n")
    out_file.write(f"- ì¶œë ¥ íŒŒì¼ í¬ê¸°: {file_size:,} bytes\n\n")
    
    if file_types:
        out_file.write("### íŒŒì¼ íƒ€ìž…ë³„ ë¶„í¬:\n")
        for ext, count in sorted(file_types.items(), key=lambda x: x[1], reverse=True):
            out_file.write(f"  - {ext}: {count}ê°œ\n")

def merge_project_files(project_path, output_file, exclude_dirs=None, 
                       exclude_files=None, include_extensions=None,
                       max_size=DEFAULT_MAX_SIZE, force_single=False):
    """í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ì½”ë“œ íŒŒì¼ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸° (ìžë™ ë¶„í•  ì§€ì›)"""
    
    project_root = Path(project_path).resolve()
    if not project_root.exists():
        print(f"ì˜¤ë¥˜: ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ - {project_root}")
        return False
    
    # ì œì™¸ íŒ¨í„´ ì„¤ì •
    exclude_dirs = exclude_dirs or DEFAULT_EXCLUDE_DIRS
    exclude_files = exclude_files or DEFAULT_EXCLUDE_FILES
    
    # íŒŒì¼ ìˆ˜ì§‘
    all_files = []
    for root, dirs, files in os.walk(project_root):
        root_path = Path(root)
        
        # ì œì™¸í•  ë””ë ‰í† ë¦¬ í•„í„°ë§
        dirs[:] = [d for d in dirs if not should_exclude_path(root_path / d, exclude_dirs)]
        
        for file in files:
            file_path = root_path / file
            
            # ì œì™¸ íŒŒì¼ ì²´í¬
            if should_exclude_path(file_path, exclude_files):
                continue
            
            # í¬í•¨í•  íŒŒì¼ì¸ì§€ ì²´í¬
            if should_include_file(file_path, include_extensions):
                all_files.append(file_path)
    
    # ê²½ë¡œ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    all_files.sort()
    
    if not all_files:
        print("ê²½ê³ : ì²˜ë¦¬í•  íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return False
    
    # íŒŒì¼ íŠ¸ë¦¬ ìƒì„±
    file_tree = create_file_tree(all_files, project_root)
    tree_size = estimate_size(file_tree)
    
    # íŒŒì¼ í¬ê¸° ë¯¸ë¦¬ ê³„ì‚°
    file_sizes = []
    total_estimated_size = tree_size
    
    for file_path in all_files:
        content = get_file_content(file_path)
        header = format_file_header(file_path, project_root)
        file_size = estimate_size(header + content + "\n")
        file_sizes.append((file_path, content, header, file_size))
        total_estimated_size += file_size
    
    # ë¶„í• ì´ í•„ìš”í•œì§€ í™•ì¸
    if not force_single and total_estimated_size > max_size:
        print(f"\nâš ï¸  ì „ì²´ í¬ê¸°ê°€ {max_size:,} bytesë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.")
        print(f"   ì˜ˆìƒ í¬ê¸°: {total_estimated_size:,} bytes")
        print(f"   íŒŒì¼ì„ ì—¬ëŸ¬ ë¶€ë¶„ìœ¼ë¡œ ë¶„í• í•©ë‹ˆë‹¤.\n")
        
        return split_and_merge_files(
            project_root, output_file, file_tree, file_sizes, max_size
        )
    
    # ë‹¨ì¼ íŒŒì¼ë¡œ ì¶œë ¥
    output_path = Path(output_file).resolve()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    file_count = 0
    total_lines = 0
    file_types = {}
    
    with open(output_path, 'w', encoding='utf-8') as out_file:
        write_header(out_file, project_root)
        out_file.write(file_tree)
        out_file.write("## ðŸ“„ íŒŒì¼ ë‚´ìš©\n")
        
        for file_path, content, header, _ in file_sizes:
            out_file.write(header)
            out_file.write(content)
            if not content.endswith('\n'):
                out_file.write('\n')
            
            # í†µê³„ ì—…ë°ì´íŠ¸
            file_count += 1
            total_lines += len(content.splitlines())
            
            # íŒŒì¼ íƒ€ìž…ë³„ í†µê³„
            ext = file_path.suffix.lower() or 'no_ext'
            file_types[ext] = file_types.get(ext, 0) + 1
            
            print(f"ì²˜ë¦¬ë¨: {file_path.relative_to(project_root)}")
        
        # í†µê³„ ì •ë³´ ì¶”ê°€
        write_statistics(out_file, file_count, total_lines, file_types, 
                        output_path.stat().st_size)
    
    print(f"\nâœ… ì™„ë£Œ!")
    print(f"ðŸ“ ì²˜ë¦¬ëœ íŒŒì¼: {file_count}ê°œ")
    print(f"ðŸ“ ì´ ë¼ì¸ ìˆ˜: {total_lines:,}ì¤„")
    print(f"ðŸ’¾ ì¶œë ¥ íŒŒì¼: {output_path}")
    print(f"ðŸ“ íŒŒì¼ í¬ê¸°: {output_path.stat().st_size:,} bytes")
    
    return True

def split_and_merge_files(project_root, output_file, file_tree, file_sizes, max_size):
    """íŒŒì¼ì„ ì—¬ëŸ¬ ë¶€ë¶„ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì €ìž¥"""
    
    output_path = Path(output_file)
    base_name = output_path.stem
    extension = output_path.suffix or '.txt'
    
    part_num = 1
    current_size = 0
    current_files = []
    all_parts = []
    
    # ê° íŒŒíŠ¸ì˜ ê¸°ë³¸ ì˜¤ë²„í—¤ë“œ ê³„ì‚°
    base_overhead = estimate_size(
        f"# í”„ë¡œì íŠ¸ ì½”ë“œ í†µí•© íŒŒì¼ (íŒŒíŠ¸ X/Y)\n" +
        f"# ìƒì„±ì¼ì‹œ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n" +
        f"# í”„ë¡œì íŠ¸ ê²½ë¡œ: {project_root}\n\n" +
        "## ðŸ“„ íŒŒì¼ ë‚´ìš©\n"
    )
    
    tree_size = estimate_size(file_tree)
    
    # íŒŒì¼ ë¶„í• 
    for file_info in file_sizes:
        file_path, content, header, file_size = file_info
        
        # í˜„ìž¬ íŒŒíŠ¸ì— ì¶”ê°€í•  ìˆ˜ ìžˆëŠ”ì§€ í™•ì¸
        estimated_part_size = current_size + file_size + base_overhead
        if part_num == 1:  # ì²« íŒŒíŠ¸ëŠ” íŠ¸ë¦¬ í¬í•¨
            estimated_part_size += tree_size
        
        if current_files and estimated_part_size > max_size:
            # í˜„ìž¬ íŒŒíŠ¸ ì €ìž¥
            all_parts.append((part_num, current_files[:]))
            part_num += 1
            current_size = 0
            current_files = []
        
        current_files.append(file_info)
        current_size += file_size
    
    # ë§ˆì§€ë§‰ íŒŒíŠ¸ ì €ìž¥
    if current_files:
        all_parts.append((part_num, current_files))
    
    total_parts = len(all_parts)
    
    # ê° íŒŒíŠ¸ íŒŒì¼ ìƒì„±
    total_file_count = 0
    total_line_count = 0
    all_file_types = {}
    created_files = []
    
    for part_idx, (part_num, part_files) in enumerate(all_parts):
        part_filename = output_path.parent / f"{base_name}_part{part_num}{extension}"
        
        with open(part_filename, 'w', encoding='utf-8') as out_file:
            write_header(out_file, project_root, part_num, total_parts)
            
            # ì²« íŒŒíŠ¸ì—ë§Œ ë””ë ‰í† ë¦¬ êµ¬ì¡° í¬í•¨
            if part_num == 1:
                out_file.write(file_tree)
            
            out_file.write("## ðŸ“„ íŒŒì¼ ë‚´ìš©\n")
            
            part_file_count = 0
            part_lines = 0
            part_file_types = {}
            
            for file_path, content, header, _ in part_files:
                out_file.write(header)
                out_file.write(content)
                if not content.endswith('\n'):
                    out_file.write('\n')
                
                # í†µê³„ ì—…ë°ì´íŠ¸
                part_file_count += 1
                part_lines += len(content.splitlines())
                total_file_count += 1
                total_line_count += len(content.splitlines())
                
                # íŒŒì¼ íƒ€ìž…ë³„ í†µê³„
                ext = file_path.suffix.lower() or 'no_ext'
                part_file_types[ext] = part_file_types.get(ext, 0) + 1
                all_file_types[ext] = all_file_types.get(ext, 0) + 1
                
                print(f"ì²˜ë¦¬ë¨: {file_path.relative_to(project_root)} (íŒŒíŠ¸ {part_num})")
            
            # íŒŒíŠ¸ë³„ í†µê³„
            out_file.write(f"\n\n{'=' * 80}\n")
            out_file.write(f"## ðŸ“Š íŒŒíŠ¸ {part_num} í†µê³„\n\n")
            out_file.write(f"- ì´ íŒŒíŠ¸ì˜ íŒŒì¼ ìˆ˜: {part_file_count}ê°œ\n")
            out_file.write(f"- ì´ íŒŒíŠ¸ì˜ ë¼ì¸ ìˆ˜: {part_lines:,}ì¤„\n")
            out_file.write(f"- ì´ íŒŒíŠ¸ì˜ í¬ê¸°: {part_filename.stat().st_size:,} bytes\n")
            
            # ë§ˆì§€ë§‰ íŒŒíŠ¸ì— ì „ì²´ í†µê³„ ì¶”ê°€
            if part_num == total_parts:
                write_statistics(out_file, total_file_count, total_line_count, 
                               all_file_types, sum(f.stat().st_size for f in created_files))
        
        created_files.append(part_filename)
        print(f"ðŸ’¾ íŒŒíŠ¸ {part_num} ì €ìž¥ë¨: {part_filename} ({part_filename.stat().st_size:,} bytes)")
    
    # ì¸ë±ìŠ¤ íŒŒì¼ ìƒì„±
    index_filename = output_path.parent / f"{base_name}_index{extension}"
    with open(index_filename, 'w', encoding='utf-8') as idx_file:
        idx_file.write(f"# í”„ë¡œì íŠ¸ ì½”ë“œ í†µí•© íŒŒì¼ ì¸ë±ìŠ¤\n")
        idx_file.write(f"# ìƒì„±ì¼ì‹œ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        idx_file.write(f"# ì´ {total_parts}ê°œ íŒŒíŠ¸ë¡œ ë¶„í• ë¨\n\n")
        
        idx_file.write("## ðŸ“‘ íŒŒíŠ¸ ëª©ë¡\n\n")
        for i, part_file in enumerate(created_files, 1):
            size_mb = part_file.stat().st_size / (1024 * 1024)
            idx_file.write(f"{i}. {part_file.name} ({size_mb:.2f} MB)\n")
        
        idx_file.write(f"\n## ðŸ’¡ ì‚¬ìš© ë°©ë²•\n\n")
        idx_file.write(f"1. ê° íŒŒíŠ¸ë¥¼ ìˆœì„œëŒ€ë¡œ Claudeì— ì „ë‹¬í•˜ì„¸ìš”.\n")
        idx_file.write(f"2. í•œ ë²ˆì— í•˜ë‚˜ì˜ íŒŒíŠ¸ë§Œ ë³µì‚¬-ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.\n")
        idx_file.write(f"3. Claudeê°€ ì´ì „ íŒŒíŠ¸ë¥¼ ê¸°ì–µí•˜ë„ë¡ 'ì´ì „ íŒŒíŠ¸ì—ì„œ ê³„ì†' ê°™ì€ ë¬¸êµ¬ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.\n")
        
        idx_file.write(f"\n## ðŸ“Š ì „ì²´ í†µê³„\n\n")
        idx_file.write(f"- ì´ íŒŒì¼ ìˆ˜: {total_file_count:,}ê°œ\n")
        idx_file.write(f"- ì´ ë¼ì¸ ìˆ˜: {total_line_count:,}ì¤„\n")
        idx_file.write(f"- ì´ í¬ê¸°: {sum(f.stat().st_size for f in created_files):,} bytes\n")
    
    created_files.append(index_filename)
    
    print(f"\nâœ… ë¶„í•  ì™„ë£Œ!")
    print(f"ðŸ“ ì²˜ë¦¬ëœ íŒŒì¼: {total_file_count}ê°œ")
    print(f"ðŸ“ ì´ ë¼ì¸ ìˆ˜: {total_line_count:,}ì¤„")
    print(f"ðŸ“‘ ìƒì„±ëœ íŒŒíŠ¸: {total_parts}ê°œ")
    print(f"ðŸ“‹ ì¸ë±ìŠ¤ íŒŒì¼: {index_filename}")
    print(f"\nðŸ’¡ íŒ: ê° íŒŒíŠ¸ë¥¼ ìˆœì„œëŒ€ë¡œ Claudeì— ì „ë‹¬í•˜ì„¸ìš”!")
    
    return True

def main():
    parser = argparse.ArgumentParser(
        description='í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ì½”ë“œë¥¼ í•˜ë‚˜ì˜ í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ í†µí•©í•©ë‹ˆë‹¤. (ìžë™ ë¶„í•  ì§€ì›)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ì‚¬ìš© ì˜ˆì‹œ:
  %(prog)s .                           # í˜„ìž¬ ë””ë ‰í† ë¦¬ í†µí•©
  %(prog)s /path/to/project            # íŠ¹ì • í”„ë¡œì íŠ¸ í†µí•©
  %(prog)s . -o merged_code.txt        # ì¶œë ¥ íŒŒì¼ëª… ì§€ì •
  %(prog)s . --include .py .js         # íŠ¹ì • í™•ìž¥ìžë§Œ í¬í•¨
  %(prog)s . --exclude-dir tests      # íŠ¹ì • ë””ë ‰í† ë¦¬ ì œì™¸
  %(prog)s . --max-size 500            # ìµœëŒ€ í¬ê¸° 500KBë¡œ ì œí•œ
  %(prog)s . --safe                    # ì•ˆì „í•œ í¬ê¸°(500KB)ë¡œ ìžë™ ë¶„í• 
  %(prog)s . --large                   # í° í¬ê¸°(2MB)ë¡œ ì„¤ì •
  %(prog)s . --force-single            # í¬ê¸° ì œí•œ ë¬´ì‹œí•˜ê³  ë‹¨ì¼ íŒŒì¼ë¡œ
"""
    )
    
    parser.add_argument('project_path', 
                       help='í†µí•©í•  í”„ë¡œì íŠ¸ ê²½ë¡œ')
    
    parser.add_argument('-o', '--output', 
                       default='merged_project_code.txt',
                       help='ì¶œë ¥ íŒŒì¼ ê²½ë¡œ (ê¸°ë³¸ê°’: merged_project_code.txt)')
    
    parser.add_argument('--include', 
                       nargs='+',
                       help='í¬í•¨í•  íŒŒì¼ í™•ìž¥ìž ëª©ë¡ (ì˜ˆ: .py .js .java)')
    
    parser.add_argument('--exclude-dir', 
                       nargs='+',
                       help='ì œì™¸í•  ë””ë ‰í† ë¦¬ ì´ë¦„ (ê¸°ë³¸ ì œì™¸ ëª©ë¡ì— ì¶”ê°€)')
    
    parser.add_argument('--exclude-file', 
                       nargs='+',
                       help='ì œì™¸í•  íŒŒì¼ íŒ¨í„´ (ì˜ˆ: "*.test.js" "temp_*")')
    
    parser.add_argument('--max-size', 
                       type=int,
                       help='íŒŒì¼ ìµœëŒ€ í¬ê¸° (KB ë‹¨ìœ„, ê¸°ë³¸ê°’: 1024KB = 1MB)')
    
    parser.add_argument('--safe', 
                       action='store_true',
                       help='ì•ˆì „í•œ í¬ê¸°(500KB)ë¡œ ì„¤ì •')
    
    parser.add_argument('--large', 
                       action='store_true',
                       help='í° í¬ê¸°(2MB)ë¡œ ì„¤ì •')
    
    parser.add_argument('--force-single', 
                       action='store_true',
                       help='í¬ê¸° ì œí•œ ë¬´ì‹œí•˜ê³  ë‹¨ì¼ íŒŒì¼ë¡œ ìƒì„±')
    
    args = parser.parse_args()
    
    # ì œì™¸ íŒ¨í„´ ì„¤ì •
    exclude_dirs = DEFAULT_EXCLUDE_DIRS.copy()
    if args.exclude_dir:
        exclude_dirs.update(args.exclude_dir)
    
    exclude_files = DEFAULT_EXCLUDE_FILES.copy()
    if args.exclude_file:
        exclude_files.update(args.exclude_file)
    
    # í¬í•¨í•  í™•ìž¥ìž ì„¤ì •
    include_extensions = None
    if args.include:
        include_extensions = {ext if ext.startswith('.') else f'.{ext}' 
                            for ext in args.include}
    
    # ìµœëŒ€ í¬ê¸° ì„¤ì •
    if args.safe:
        max_size = SAFE_MAX_SIZE
    elif args.large:
        max_size = LARGE_MAX_SIZE
    elif args.max_size:
        max_size = args.max_size * 1024  # KBë¥¼ ë°”ì´íŠ¸ë¡œ ë³€í™˜
    else:
        max_size = DEFAULT_MAX_SIZE
    
    # ì‹¤í–‰
    merge_project_files(
        args.project_path,
        args.output,
        exclude_dirs=exclude_dirs,
        exclude_files=exclude_files,
        include_extensions=include_extensions,
        max_size=max_size,
        force_single=args.force_single
    )

if __name__ == "__main__":
    main()

================================================================================
íŒŒì¼: playbooks/awx-integration.yml
================================================================================
---
# AWX Integration for Mitum monitoring and automation

- name: Configure AWX monitoring integration
  hosts: localhost
  gather_facts: no
  vars:
    awx_base_url: "{{ lookup('env', 'AWX_URL') | default('http://awx.example.com') }}"
    awx_token: "{{ lookup('env', 'AWX_TOKEN') }}"
    prometheus_url: "{{ lookup('env', 'PROMETHEUS_URL') | default('http://prometheus:9090') }}"
  
  tasks:
    - name: Create AWX notification webhook
      uri:
        url: "{{ awx_base_url }}/api/v2/notification_templates/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Network Alerts"
          organization: 1
          notification_type: "webhook"
          notification_configuration:
            url: "{{ awx_base_url }}/api/v2/job_templates/{{ mitum_recovery_template_id }}/launch/"
            headers:
              Authorization: "Bearer {{ awx_token }}"
              Content-Type: "application/json"
            http_method: "POST"
      register: webhook_created

    - name: Create AWX inventory source for Prometheus
      uri:
        url: "{{ awx_base_url }}/api/v2/inventory_sources/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Prometheus Metrics"
          inventory: "{{ awx_inventory_id }}"
          source: "custom"
          source_vars: |
            prometheus_url: {{ prometheus_url }}
            prometheus_query: 'up{job="mitum"}'
          update_on_launch: true
          update_cache_timeout: 300

    - name: Configure AWX dashboard for Mitum
      uri:
        url: "{{ awx_base_url }}/api/v2/dashboards/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Network Status"
          organization: 1
          dashboard_config:
            - widget_type: "graph"
              name: "Node Status"
              config:
                metric: "up{job='mitum'}"
                refresh_interval: 30
            - widget_type: "stat"
              name: "Active Nodes"
              config:
                metric: "count(up{job='mitum'} == 1)"
            - widget_type: "gauge"
              name: "Consensus Health"
              config:
                metric: "(count(mitum_consensus_state == 1) / count(mitum_consensus_state)) * 100"
                thresholds:
                  - value: 67
                    color: "yellow"
                  - value: 80
                    color: "green"

- name: Setup Prometheus federation for AWX
  hosts: monitoring
  become: yes
  tasks:
    - name: Configure Prometheus for AWX federation
      blockinfile:
        path: /etc/prometheus/prometheus.yml
        marker: "# {mark} AWX FEDERATION CONFIG"
        block: |
          # AWX Federation endpoint
          - job_name: 'awx_federation'
            honor_labels: true
            metrics_path: '/federate'
            params:
              'match[]':
                - '{job="mitum"}'
                - '{job="node_exporter"}'
                - '{job="mongodb"}'
            static_configs:
              - targets:
                  - '{{ awx_prometheus_endpoint | default("awx.example.com:9090") }}'

    - name: Create AWX-specific recording rules
      copy:
        content: |
          groups:
            - name: awx_mitum_summary
              interval: 30s
              rules:
                - record: awx:mitum_nodes_total
                  expr: count(up{job="mitum"})
                
                - record: awx:mitum_nodes_healthy
                  expr: count(up{job="mitum"} == 1)
                
                - record: awx:mitum_consensus_percentage
                  expr: (count(mitum_consensus_state == 1) / count(mitum_consensus_state)) * 100
                
                - record: awx:mitum_avg_block_height
                  expr: avg(mitum_block_height)
                
                - record: awx:mitum_api_availability
                  expr: up{job="mitum",node_type="api"}
        dest: /etc/prometheus/rules/awx_mitum.yml
      notify: reload prometheus

    - name: Setup Alertmanager webhook for AWX
      template:
        src: alertmanager-awx.yml.j2
        dest: /etc/alertmanager/alertmanager.yml
      notify: restart alertmanager

- name: Create AWX job templates for Mitum operations
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Create recovery job template
      uri:
        url: "{{ awx_base_url }}/api/v2/job_templates/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Node Recovery"
          job_type: "run"
          inventory: "{{ awx_inventory_id }}"
          project: "{{ awx_project_id }}"
          playbook: "playbooks/recovery.yml"
          extra_vars:
            recovery_action: "auto"
          allow_simultaneous: false
          
    - name: Create monitoring check job template
      uri:
        url: "{{ awx_base_url }}/api/v2/job_templates/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Health Check"
          job_type: "run"
          inventory: "{{ awx_inventory_id }}"
          project: "{{ awx_project_id }}"
          playbook: "playbooks/validate.yml"
          verbosity: 1
          
    - name: Create workflow for automated recovery
      uri:
        url: "{{ awx_base_url }}/api/v2/workflow_job_templates/"
        method: POST
        headers:
          Authorization: "Bearer {{ awx_token }}"
        body_format: json
        body:
          name: "Mitum Automated Recovery Workflow"
          organization: 1
          schema:
            - job_template: "Mitum Health Check"
              success_nodes:
                - job_template: "Mitum Node Recovery"
              failure_nodes:
                - job_template: "Send Alert Notification"

================================================================================
íŒŒì¼: playbooks/backup.yml
================================================================================
---
# Backup playbook for Mitum nodes

- name: Backup Mitum nodes
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: yes
  become: yes
  vars:
    backup_timestamp: "{{ ansible_date_time.epoch }}"
    backup_dir: "{{ mitum_backup_dir }}/{{ backup_timestamp }}"
    
  tasks:
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0750'
        
    - name: Check service status
      systemd:
        name: "{{ mitum_service_name }}"
      register: service_status
      
    - name: Create backup manifest
      copy:
        content: |
          backup_timestamp: {{ backup_timestamp }}
          backup_date: {{ ansible_date_time.iso8601 }}
          hostname: {{ inventory_hostname }}
          node_id: {{ mitum_node_id }}
          service_status: {{ service_status.status.ActiveState }}
          mitum_version: {{ mitum_version | default('unknown') }}
          network_id: {{ mitum_network_id }}
        dest: "{{ backup_dir }}/manifest.yml"
        
    - name: Stop service for consistent backup
      systemd:
        name: "{{ mitum_service_name }}"
        state: stopped
      when: 
        - stop_service_for_backup | default(false)
        - service_status.status.ActiveState == "active"
      register: service_stopped
      
    - name: Backup configuration files
      archive:
        path:
          - "{{ mitum_config_dir }}"
          - "{{ mitum_keys_dir }}"
        dest: "{{ backup_dir }}/config-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Backup data directory
      when: backup_data | default(true)
      block:
        - name: Calculate data directory size
          command: du -sh {{ mitum_data_dir }}
          register: data_size
          changed_when: false
          
        - name: Display data size
          debug:
            msg: "Data directory size: {{ data_size.stdout }}"
            
        - name: Create data backup
          archive:
            path: "{{ mitum_data_dir }}"
            dest: "{{ backup_dir }}/data-backup.tar.gz"
            format: gz
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0600'
          async: 3600
          poll: 30
          
    - name: Backup MongoDB
      when: 
        - mitum_mongodb_enabled | default(true)
        - backup_mongodb | default(true)
      block:
        - name: Create MongoDB backup directory
          file:
            path: "{{ backup_dir }}/mongodb-backup"
            state: directory
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0750'
            
        - name: Dump MongoDB database
          shell: |
            {% if mitum_mongodb_auth_enabled %}
            mongodump -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
              --authenticationDatabase {{ mitum_mongodb_database }} \
              --db {{ mitum_mongodb_database }} \
              --out {{ backup_dir }}/mongodb-backup
            {% else %}
            mongodump --db {{ mitum_mongodb_database }} \
              --out {{ backup_dir }}/mongodb-backup
            {% endif %}
          become_user: "{{ mitum_service_user }}"
          
        - name: Compress MongoDB backup
          archive:
            path: "{{ backup_dir }}/mongodb-backup"
            dest: "{{ backup_dir }}/mongodb-backup.tar.gz"
            format: gz
            remove: yes
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            mode: '0600'
            
    - name: Backup logs
      when: backup_logs | default(false)
      archive:
        path: "{{ mitum_log_dir }}"
        dest: "{{ backup_dir }}/logs-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Start service if it was stopped
      systemd:
        name: "{{ mitum_service_name }}"
        state: started
      when: service_stopped is changed
      
    - name: Create backup summary
      shell: |
        echo "=== Backup Summary ===" > {{ backup_dir }}/summary.txt
        echo "Timestamp: {{ ansible_date_time.iso8601 }}" >> {{ backup_dir }}/summary.txt
        echo "Node: {{ inventory_hostname }}" >> {{ backup_dir }}/summary.txt
        echo "" >> {{ backup_dir }}/summary.txt
        echo "Files backed up:" >> {{ backup_dir }}/summary.txt
        ls -lh {{ backup_dir }}/*.tar.gz >> {{ backup_dir }}/summary.txt
        echo "" >> {{ backup_dir }}/summary.txt
        echo "Total size:" >> {{ backup_dir }}/summary.txt
        du -sh {{ backup_dir }} >> {{ backup_dir }}/summary.txt
      changed_when: false
      
    - name: Set backup permissions
      file:
        path: "{{ backup_dir }}"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0750'
        recurse: yes
        
- name: Centralize backups
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: no
  become: yes
  serial: 1
  when: centralize_backups | default(false)
  tasks:
    - name: Create central backup directory on bastion
      file:
        path: "/var/backups/mitum-central/{{ backup_timestamp }}"
        state: directory
        mode: '0750'
      delegate_to: "{{ groups['bastion'][0] }}"
      run_once: yes
      
    - name: Sync backup to bastion
      synchronize:
        src: "{{ backup_dir }}/"
        dest: "/var/backups/mitum-central/{{ backup_timestamp }}/{{ inventory_hostname }}/"
        mode: push
        compress: yes
      delegate_to: "{{ groups['bastion'][0] }}"
      
- name: Cleanup old backups
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  gather_facts: no
  become: yes
  when: cleanup_old_backups | default(true)
  tasks:
    - name: Find old backups
      find:
        paths: "{{ mitum_backup_dir }}"
        age: "{{ mitum_backup_retention_days | default(7) }}d"
        recurse: no
        file_type: directory
      register: old_backups
      
    - name: Remove old backups
      file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ old_backups.files }}"
      when: old_backups.files | length > 0
      
    - name: Display cleanup summary
      debug:
        msg: "Removed {{ old_backups.files | length }} old backup(s)"
        
- name: Generate backup report
  hosts: localhost
  gather_facts: no
  run_once: yes
  tasks:
    - name: Create backup report
      template:
        src: backup-report.j2
        dest: "{{ playbook_dir }}/../reports/backup-{{ backup_timestamp }}.txt"
      vars:
        nodes_backed_up: "{{ groups[target_nodes | default('mitum_nodes')] }}"
        
    - name: Display backup summary
      debug:
        msg: |
          Backup completed successfully!
          
          Timestamp: {{ backup_timestamp }}
          Nodes backed up: {{ groups[target_nodes | default('mitum_nodes')] | length }}
          Backup location: {{ mitum_backup_dir }}/{{ backup_timestamp }}
          
          To restore from this backup:
          make restore BACKUP_TIMESTAMP={{ backup_timestamp }}

================================================================================
íŒŒì¼: playbooks/cleanup.yml
================================================================================
---
# Mitum cleanup tasks - for resetting/reinitializing Mitum

- name: Mitum cleanup operations
  block:
    - name: Check if cleanup is requested
      debug:
        msg: "Cleanup requested. This will remove Mitum data and MongoDB database."
      when: mitum_cleanup.enabled
      tags:
        - mitum-cleanup

    - name: Stop Mitum service
      systemd:
        name: "{{ mitum_service_name }}"
        state: stopped
      when: mitum_cleanup.enabled
      ignore_errors: yes
      tags:
        - mitum-cleanup

    - name: Create backup before cleanup
      block:
        - name: Create backup directory
          file:
            path: "{{ mitum_cleanup.backup_dir }}/{{ ansible_date_time.epoch }}"
            state: directory
            mode: '0755'

        - name: Backup Mitum data directory
          archive:
            path: "{{ mitum_data_dir }}"
            dest: "{{ mitum_cleanup.backup_dir }}/{{ ansible_date_time.epoch }}/mitum-data-backup.tar.gz"
            format: gz
          when: mitum_cleanup.remove_data

        - name: Backup MongoDB data
          shell: |
            {% if mitum_mongodb_auth_enabled %}
            mongodump -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
              --authenticationDatabase mitum \
              --db mitum \
              --out {{ mitum_cleanup.backup_dir }}/{{ ansible_date_time.epoch }}/mongodb-backup
            {% else %}
            mongodump --db mitum \
              --out {{ mitum_cleanup.backup_dir }}/{{ ansible_date_time.epoch }}/mongodb-backup
            {% endif %}
          when: mitum_cleanup.remove_mongodb_data
      when: 
        - mitum_cleanup.enabled
        - mitum_cleanup.backup_before_cleanup
      tags:
        - mitum-cleanup
        - mitum-backup

    - name: Remove Mitum data directory
      file:
        path: "{{ mitum_data_dir }}"
        state: absent
      when: 
        - mitum_cleanup.enabled
        - mitum_cleanup.remove_data
      tags:
        - mitum-cleanup

    - name: Drop MongoDB mitum database
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongosh -u "{{ mitum_mongodb_admin_user }}" -p "{{ mitum_mongodb_admin_password }}" \
          --authenticationDatabase admin \
          --eval "use mitum; db.dropDatabase()"
        {% else %}
        mongosh --eval "use mitum; db.dropDatabase()"
        {% endif %}
      when: 
        - mitum_cleanup.enabled
        - mitum_cleanup.remove_mongodb_data
      register: mongodb_drop_result
      tags:
        - mitum-cleanup

    - name: Recreate Mitum data directory
      file:
        path: "{{ mitum_data_dir }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
      when: 
        - mitum_cleanup.enabled
        - mitum_cleanup.remove_data
      tags:
        - mitum-cleanup

    - name: Remove initialization marker
      file:
        path: "{{ mitum_data_dir }}/.initialized"
        state: absent
      when: mitum_cleanup.enabled
      tags:
        - mitum-cleanup

    - name: Display cleanup results
      debug:
        msg: |
          Cleanup completed:
          - Mitum data removed: {{ mitum_cleanup.remove_data }}
          - MongoDB data removed: {{ mitum_cleanup.remove_mongodb_data }}
          - Backup created: {{ mitum_cleanup.backup_before_cleanup }}
          {% if mitum_cleanup.backup_before_cleanup %}
          - Backup location: {{ mitum_cleanup.backup_dir }}/{{ ansible_date_time.epoch }}
          {% endif %}
          
          To reinitialize Mitum, run the playbook with the 'mitum-init' tag.
      when: mitum_cleanup.enabled
      tags:
        - mitum-cleanup

  rescue:
    - name: Cleanup failed
      debug:
        msg: |
          Cleanup operation failed: {{ ansible_failed_result.msg }}
          Please check the system manually.
      tags:
        - mitum-cleanup

================================================================================
íŒŒì¼: playbooks/configure-only.yml
================================================================================
---
# Configure Mitum nodes without installation

- name: Configure Mitum nodes
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  serial: "{{ configure_batch_size | default(5) }}"
  
  pre_tasks:
    - name: Verify Mitum is installed
      stat:
        path: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
      register: mitum_installed
      failed_when: not mitum_installed.stat.exists
      
    - name: Backup current configuration
      archive:
        path: "{{ mitum_config_dir }}"
        dest: "{{ mitum_backup_dir }}/config-backup-{{ ansible_date_time.epoch }}.tar.gz"
        format: gz
      when: backup_before_configure | default(true)
      
  tasks:
    - name: Stop Mitum service
      systemd:
        name: "{{ mitum_service_name }}"
        state: stopped
      when: stop_during_configure | default(true)
      
    - name: Apply configuration
      include_role:
        name: mitum
        tasks_from: configure-nodes
      vars:
        mitum_deployment_phase: configure
        
    - name: Validate new configuration
      command: |
        {{ mitum_install_dir }}/{{ mitum_model_type }} validate-config \
          {{ mitum_config_dir }}/config.yml
      register: config_validation
      changed_when: false
      failed_when: 
        - config_validation.rc != 0
        - "'not implemented' not in config_validation.stderr"
        
    - name: Start Mitum service
      systemd:
        name: "{{ mitum_service_name }}"
        state: started
      when: stop_during_configure | default(true)
      
    - name: Wait for service to be ready
      wait_for:
        port: "{{ mitum_node_port }}"
        host: "{{ ansible_default_ipv4.address }}"
        state: started
        timeout: 60
        
    - name: Verify service health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        status_code: 200
      retries: 10
      delay: 3
      
  post_tasks:
    - name: Display configuration status
      debug:
        msg: |
          Configuration applied successfully!
          Node: {{ inventory_hostname }}
          Service: {{ mitum_service_name }}
          Config validation: {{ 'Passed' if config_validation.rc == 0 else 'Skipped' }}

================================================================================
íŒŒì¼: playbooks/deploy-mitum.yml
================================================================================
---
# Main deployment playbook for Mitum blockchain

- name: Pre-deployment validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Verify inventory exists
      stat:
        path: "{{ inventory_file }}"
      register: inv_check
      failed_when: not inv_check.stat.exists
      
    - name: Check for required variables
      assert:
        that:
          - mitum_network_id is defined
          - mitum_model_type is defined
          - groups['mitum_nodes'] | length > 0
        fail_msg: "Required variables or groups are missing"
        
    - name: Display deployment information
      debug:
        msg: |
          Mitum Deployment Configuration:
          - Network ID: {{ mitum_network_id }}
          - Model Type: {{ mitum_model_type }}
          - Total Nodes: {{ groups['mitum_nodes'] | length }}
          - Consensus Nodes: {{ groups['mitum_nodes'] | map('extract', hostvars) | selectattr('mitum_api_enabled', 'defined') | rejectattr('mitum_api_enabled') | list | length }}
          - API Nodes: {{ groups['mitum_nodes'] | map('extract', hostvars) | selectattr('mitum_api_enabled', 'defined') | selectattr('mitum_api_enabled') | list | length }}
          
- name: Prepare bastion host
  hosts: bastion
  gather_facts: yes
  become: yes
  tasks:
    - name: Ensure bastion is ready
      ping:
      
    - name: Install required packages on bastion
      package:
        name:
          - python3
          - python3-pip
          - jq
          - curl
          - git
        state: present
        
    - name: Configure SSH multiplexing
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        state: present
      loop:
        - { regexp: '^MaxSessions', line: 'MaxSessions 50' }
        - { regexp: '^MaxStartups', line: 'MaxStartups 50:30:100' }
      notify: restart sshd
      
  handlers:
    - name: restart sshd
      service:
        name: sshd
        state: restarted

- name: Deploy MongoDB on nodes
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - mongodb
  tasks:
    - name: Install MongoDB
      include_role:
        name: mongodb
      vars:
        mongodb_version: "{{ mitum_mongodb_version }}"
        mongodb_port: "{{ mitum_mongodb_port }}"
        mongodb_replica_set: "{{ mitum_mongodb_replica_set }}"
        
    - name: Configure MongoDB replica set
      run_once: yes
      delegate_to: "{{ groups['mitum_nodes'][0] }}"
      mongodb_replicaset:
        replica_set: "{{ mitum_mongodb_replica_set }}"
        members: "{{ groups['mitum_nodes'] | map('extract', hostvars, 'ansible_default_ipv4') | map(attribute='address') | list }}"
      when: groups['mitum_nodes'] | length > 1

- name: Generate keys centrally
  hosts: localhost
  gather_facts: no
  tags:
    - keygen
  tasks:
    - name: Check if keys already exist
      stat:
        path: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
      register: keys_check
      
    - name: Generate keys using MitumJS
      when: not keys_check.stat.exists or mitum_force_keygen | default(false)
      block:
        - name: Create keys directory
          file:
            path: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
            state: directory
            mode: '0700'
            
        - name: Install MitumJS dependencies
          npm:
            path: "{{ playbook_dir }}/../tools/mitumjs"
            state: present
            
        - name: Generate node keys
          command: |
            node {{ playbook_dir }}/../tools/mitumjs/mitum-keygen.js \
              --network-id {{ mitum_network_id }} \
              --node-count {{ groups['mitum_nodes'] | length }} \
              --threshold {{ mitum_keys_threshold }} \
              --output {{ playbook_dir }}/../keys/{{ mitum_network_id }}
          register: keygen_result
          
        - name: Parse generated keys
          set_fact:
            generated_keys: "{{ keygen_result.stdout | from_json }}"
          
        - name: Save keys summary
          copy:
            content: "{{ generated_keys | to_nice_yaml }}"
            dest: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}/keys-summary.yml"

- name: Deploy Mitum nodes
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - install
    - mitum
  tasks:
    - name: Create Mitum user
      user:
        name: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        system: yes
        shell: /bin/bash
        home: "{{ mitum_base_dir }}"
        create_home: yes
        
    - name: Create directory structure
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
      loop:
        - "{{ mitum_install_dir }}"
        - "{{ mitum_data_dir }}"
        - "{{ mitum_config_dir }}"
        - "{{ mitum_keys_dir }}"
        - "{{ mitum_log_dir }}"
        - "{{ mitum_backup_dir }}"
        
    - name: Deploy Mitum binary
      include_role:
        name: mitum
        tasks_from: install
      vars:
        mitum_deployment_phase: install

- name: Configure Mitum nodes
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  serial: "{{ mitum_deployment_batch_size | default(5) }}"
  tags:
    - configure
    - mitum
  tasks:
    - name: Copy node keys
      copy:
        src: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}/node{{ mitum_node_id }}/"
        dest: "{{ mitum_keys_dir }}/"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Configure Mitum node
      include_role:
        name: mitum
        tasks_from: configure-nodes
      vars:
        mitum_deployment_phase: configure

- name: Initialize genesis block
  hosts: mitum_nodes[0]
  gather_facts: no
  become: yes
  run_once: yes
  tags:
    - init
    - genesis
  tasks:
    - name: Check if already initialized
      stat:
        path: "{{ mitum_data_dir }}/.initialized"
      register: init_check
      
    - name: Initialize genesis
      when: not init_check.stat.exists
      block:
        - name: Generate genesis configuration
          template:
            src: "{{ playbook_dir }}/../roles/mitum/templates/genesis.yml.j2"
            dest: "{{ mitum_config_dir }}/genesis.yml"
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"
            
        - name: Initialize blockchain
          become_user: "{{ mitum_service_user }}"
          command: |
            {{ mitum_install_dir }}/{{ mitum_model_type }} init \
              --config {{ mitum_config_dir }}/config.yml \
              {{ mitum_config_dir }}/genesis.yml
          register: init_result
          
        - name: Mark as initialized
          file:
            path: "{{ mitum_data_dir }}/.initialized"
            state: touch
            owner: "{{ mitum_service_user }}"
            group: "{{ mitum_service_group }}"

- name: Start Mitum services
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  serial: 1
  tags:
    - start
    - service
  tasks:
    - name: Start Mitum service
      include_role:
        name: mitum
        tasks_from: service
      vars:
        mitum_deployment_phase: start
        
    - name: Wait for node to be ready
      wait_for:
        port: "{{ mitum_node_port }}"
        host: "{{ ansible_host }}"
        timeout: 60
        
    - name: Verify node health
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/node"
        status_code: 200
      retries: 30
      delay: 2
      register: health_check
      until: health_check.status == 200

- name: Setup monitoring
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  tags:
    - monitoring
  tasks:
    - name: Configure monitoring
      include_role:
        name: mitum
        tasks_from: monitoring-prometheus
      when: mitum_monitoring.enabled | default(true)

- name: Post-deployment validation
  hosts: mitum_nodes
  gather_facts: no
  tags:
    - validate
  tasks:
    - name: Check node status
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/node"
      register: node_status
      
    - name: Check consensus state
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_node_port }}/v2/consensus/state"
      register: consensus_status
      when: not (mitum_api_enabled | default(false))
      
    - name: Check API endpoints
      uri:
        url: "http://{{ ansible_host }}:{{ mitum_api_port }}/{{ item }}"
      loop:
        - v2/node
        - healthz
      when: mitum_api_enabled | default(false)
      
    - name: Display deployment summary
      debug:
        msg: |
          Node: {{ inventory_hostname }}
          Status: {{ node_status.json.status | default('unknown') }}
          Type: {{ 'API/Syncer' if mitum_api_enabled | default(false) else 'Consensus' }}
          {% if not (mitum_api_enabled | default(false)) %}
          Consensus: {{ consensus_status.json.consensus.state | default('unknown') }}
          {% endif %}
      run_once: yes
      delegate_to: localhost
      
- name: Generate deployment report
  hosts: localhost
  gather_facts: no
  tags:
    - report
  tasks:
    - name: Create deployment report
      template:
        src: deployment-report.j2
        dest: "{{ playbook_dir }}/../reports/deployment-{{ ansible_date_time.epoch }}.txt"
      vars:
        deployment_timestamp: "{{ ansible_date_time.iso8601 }}"
        deployed_nodes: "{{ groups['mitum_nodes'] }}"

================================================================================
íŒŒì¼: playbooks/keygen-only.yml
================================================================================
---
- name: Generate keys for Mitum nodes
  hosts: localhost
  gather_facts: yes
  vars:
    mitum_version: "{{ lookup('env', 'MITUM_VERSION') | default('3.0.0') }}"
    network_id: "{{ lookup('env', 'NETWORK_ID') | default('testnet') }}"
    node_count: "{{ lookup('env', 'NODE_COUNT') | default(3) }}"
    key_type: "{{ lookup('env', 'KEY_TYPE') | default('btc') }}"
    threshold: "{{ lookup('env', 'THRESHOLD') | default(100) }}"
    keys_dir: "{{ playbook_dir }}/../keys/{{ network_id }}"
    mitumjs_dir: "{{ playbook_dir }}/../tools/mitumjs"

  tasks:
    - name: Debug environment variables
      debug:
        msg: |
          Environment Variables:
          - network_id: {{ network_id }}
          - keys_dir: {{ keys_dir }}
          - node_count: {{ node_count }}

    - name: Check for existing keys
      stat:
        path: "{{ keys_dir }}/keys-summary.json"
      register: existing_keys

    - name: Show existing keys status
      debug:
        msg: "Keys already exist at {{ keys_dir }}"
      when: existing_keys.stat.exists

    - name: Confirm key regeneration
      pause:
        prompt: "Keys already exist for network '{{ network_id }}'. Regenerate? (yes/no)"
      register: regenerate_keys
      when: existing_keys.stat.exists

    - block:
        - name: Create keys directory
          file:
            path: "{{ keys_dir }}"
            state: directory
            mode: '0755'

        - name: Install MitumJS dependencies
          npm:
            path: "{{ mitumjs_dir }}"
            state: present

        - name: Check MitumJS installation
          command: npm list @mitumjs/mitumjs
          args:
            chdir: "{{ mitumjs_dir }}"
          register: mitumjs_check
          changed_when: false
          failed_when: false

        - name: Display MitumJS version
          debug:
            msg: "MitumJS version: {{ mitumjs_check.stdout_lines[-1] | default('Not installed') }}"

        - name: Generate keys using MitumJS
          command: >
            node {{ mitumjs_dir }}/mitum-keygen.js
            --network-id {{ network_id }}
            --node-count {{ node_count }}
            --threshold {{ threshold }}
            --output {{ keys_dir }}
            --type {{ key_type }}
          register: keygen_output

        - name: Show keygen output
          debug:
            var: keygen_output
          when: keygen_output is defined

        - name: Check if keys-summary.json was created
          stat:
            path: "{{ keys_dir }}/keys-summary.json"
          register: keys_summary_check

        - name: Parse key generation output
          set_fact:
            keygen_summary: "{{ (keygen_output.stdout | regex_search('--- Key Generation Summary ---\\n(.+)', '\\1') | first | from_json) if keygen_output is defined and keygen_output.stdout is defined else {} }}"
          when: keygen_output is defined and keygen_output.stdout is defined

      when: not existing_keys.stat.exists or (regenerate_keys.user_input | default('no') | lower == 'yes')

    - name: Load generated keys summary
      slurp:
        src: "{{ keys_dir }}/keys-summary.json"
      register: keys_summary_file
      when: keys_summary_check is not defined or keys_summary_check.stat.exists

    - name: Display key generation summary
      debug:
        msg: |
          Key Generation Summary:
          - Network ID: {{ network_id }}
          - Total Nodes: {{ node_count }}
          - Key Type: {{ key_type }}
          - Threshold: {{ threshold }}%

          Generated Nodes:
          {% if keys_summary_file is defined and keys_summary_file.content is defined %}
          {% for node in (keys_summary_file.content | b64decode | from_json).nodes %}
          - {{ node.address }}: {{ node.public_key }}
          {% endfor %}

          Genesis Account:
          - Address: {{ (keys_summary_file.content | b64decode | from_json).genesis_account.address }}
          - Threshold: {{ (keys_summary_file.content | b64decode | from_json).genesis_account.threshold }}%
          {% else %}
          (Keys summary file not loaded)
          {% endif %}

    - name: Create keys archive
      archive:
        path: "{{ keys_dir }}"
        dest: "{{ playbook_dir }}/../keys/keys-{{ network_id }}-{{ ansible_date_time.epoch }}.tar.gz"
        format: gz
      when: keys_summary_file is defined

    - name: Set keys directory permissions
      file:
        path: "{{ keys_dir }}"
        state: directory
        mode: '0700'
        recurse: yes

    # Skip distribute-keys task if not needed
    - name: Key distribution note
      debug:
        msg: "Keys are stored locally. Distribution will be handled during deployment."

================================================================================
íŒŒì¼: playbooks/pre-deploy-check.yml
================================================================================
---
# Pre-deployment Validation Playbook
# Version: 4.0.0
#
# Validates the environment before deployment to catch issues early.
# 
# Validation items:
# - Connectivity check
# - OS compatibility
# - Required port availability
# - Disk space
# - Time synchronization
# - Existing service conflicts

- name: Pre-deployment validation for all hosts
  hosts: all
  gather_facts: yes
  any_errors_fatal: true  # Stop everything if any host fails
  tasks:
    # === Basic Connectivity Check ===
    - name: Verify ansible connectivity
      ping:
      register: ping_result

    - name: Display connection status
      debug:
        msg: "Host {{ inventory_hostname }} is reachable"

    # === OS Compatibility Check ===
    - name: Check supported OS
      assert:
        that:
          - ansible_os_family in ['Debian', 'RedHat']
          - ansible_distribution_version is version('18.04', '>=') or 
            ansible_distribution_version is version('7.0', '>=')
        fail_msg: |
          Unsupported OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          Supported: Ubuntu 18.04+, CentOS/RHEL 7+
        success_msg: "OS {{ ansible_distribution }} {{ ansible_distribution_version }} is supported"

    # === Python Version Check ===
    - name: Check Python version
      assert:
        that:
          - ansible_python_version is version('3.6', '>=')
        fail_msg: "Python 3.6+ required, found: {{ ansible_python_version }}"
        success_msg: "Python {{ ansible_python_version }} meets requirements"

    # === Disk Space Check ===
    - name: Check disk space
      set_fact:
        root_disk_free_gb: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/') | first).size_available / 1024 / 1024 / 1024 | round(2) }}"

    - name: Verify sufficient disk space
      assert:
        that:
          - root_disk_free_gb | float >= 20
        fail_msg: "Insufficient disk space: {{ root_disk_free_gb }}GB free (minimum 20GB required)"
        success_msg: "Disk space OK: {{ root_disk_free_gb }}GB free"

    # === Memory Check ===
    - name: Check available memory
      assert:
        that:
          - ansible_memtotal_mb >= 4096
        fail_msg: "Insufficient memory: {{ ansible_memtotal_mb }}MB (minimum 4GB required)"
        success_msg: "Memory OK: {{ ansible_memtotal_mb }}MB"

    # === Time Synchronization Check ===
    - name: Check time synchronization
      shell: |
        if command -v timedatectl &> /dev/null; then
          timedatectl status | grep -q "synchronized: yes" && echo "synced" || echo "not synced"
        elif command -v ntpstat &> /dev/null; then
          ntpstat &> /dev/null && echo "synced" || echo "not synced"
        else
          echo "unknown"
        fi
      register: time_sync_status
      changed_when: false

    - name: Warn if time not synchronized
      debug:
        msg: "WARNING: Time synchronization status: {{ time_sync_status.stdout }}"
      when: time_sync_status.stdout != "synced"

    # === Required Commands Check ===
    - name: Check required commands
      command: "which {{ item }}"
      loop:
        - python3
        - pip3
        - tar
        - gzip
        - curl
        - systemctl
      register: command_checks
      failed_when: false
      changed_when: false

    - name: Report missing commands
      fail:
        msg: "Required command not found: {{ item.item }}"
      when: item.rc != 0
      loop: "{{ command_checks.results }}"

    # === SELinux Status Check (RHEL/CentOS) ===
    - name: Check SELinux status
      command: getenforce
      register: selinux_status
      changed_when: false
      failed_when: false
      when: ansible_os_family == "RedHat"

    - name: Display SELinux status
      debug:
        msg: "SELinux is {{ selinux_status.stdout | default('not installed') }}"
      when: ansible_os_family == "RedHat"

    # === Firewall Status Check ===
    - name: Check firewall status
      systemd:
        name: "{{ item }}"
      register: firewall_status
      failed_when: false
      loop:
        - ufw
        - firewalld
      when: ansible_service_mgr == "systemd"

    - name: Display firewall status
      debug:
        msg: "{{ item.item }} is {{ item.status.ActiveState | default('not installed') }}"
      loop: "{{ firewall_status.results | default([]) }}"
      when: firewall_status is defined

# === Mitum Node Specific Validation ===
- name: Mitum nodes specific validation
  hosts: mitum_nodes
  gather_facts: no
  tasks:
    # === Port Availability Check ===
    - name: Check if Mitum ports are available
      wait_for:
        port: "{{ item }}"
        state: stopped
        timeout: 1
      register: port_checks
      failed_when: false
      loop:
        - "{{ mitum_node_port }}"
        - "{{ mitum_api_port | default(54320) }}"
        - "{{ mongodb_port | default(27017) }}"

    - name: Report ports in use
      debug:
        msg: "WARNING: Port {{ item.item }} is already in use"
      when: item.failed is defined and item.failed
      loop: "{{ port_checks.results }}"

    # === Check Existing Mitum Installation ===
    - name: Check for existing Mitum installation
      stat:
        path: "{{ mitum_install_dir }}/mitum"
      register: existing_mitum

    - name: Display existing installation
      debug:
        msg: "Existing Mitum installation found at {{ mitum_install_dir }}"
      when: existing_mitum.stat.exists

    # === Check Existing MongoDB ===
    - name: Check for existing MongoDB
      systemd:
        name: mongod
      register: existing_mongodb
      failed_when: false

    - name: Display MongoDB status
      debug:
        msg: "MongoDB service status: {{ existing_mongodb.status.ActiveState | default('not installed') }}"

# === Validation Summary ===
- name: Validation summary
  hosts: localhost
  gather_facts: no
  run_once: true
  tasks:
    - name: Create validation report
      set_fact:
        validation_report:
          timestamp: "{{ ansible_date_time.iso8601 }}"
          total_hosts: "{{ groups['all'] | length }}"
          validated_hosts: "{{ groups['all'] | length }}"  # If we reach here, all passed
          warnings: []  # Can add warning collection logic later

    - name: Display validation summary
      debug:
        msg: |
          ========================================
          Pre-deployment Validation Complete
          ========================================
          Total hosts validated: {{ validation_report.total_hosts }}
          All checks passed! âœ“
          
          Environment ready for deployment.
          ========================================

================================================================================
íŒŒì¼: playbooks/prepare-system.yml
================================================================================
---
# System Preparation Playbook
# Version: 4.0.0 - Cross-platform support with security hardening
#
# Performs OS-specific package installation and system configuration.
# Supported OS: Ubuntu/Debian, CentOS/RHEL, macOS (limited)

- name: Prepare systems for Mitum deployment
  hosts: all
  become: yes
  gather_facts: yes
  
  # Error handling strategy
  max_fail_percentage: 30
  serial: "{{ prepare_batch_size | default('100%') }}"
  
  pre_tasks:
    - name: Detect package manager
      set_fact:
        pkg_mgr: >-
          {%- if ansible_os_family == "Debian" -%}apt
          {%- elif ansible_os_family == "RedHat" -%}yum
          {%- elif ansible_os_family == "Darwin" -%}brew
          {%- else -%}unknown{%- endif -%}

    - name: Verify supported package manager
      assert:
        that:
          - pkg_mgr != "unknown"
        fail_msg: "Unsupported OS family: {{ ansible_os_family }}"

  tasks:
    # === Package Cache Update ===
    - name: Update package cache
      block:
        - name: Update apt cache (Debian/Ubuntu)
          apt:
            update_cache: yes
            cache_valid_time: 3600
          when: pkg_mgr == "apt"
          
        - name: Update yum cache (RHEL/CentOS)
          yum:
            update_cache: yes
          when: pkg_mgr == "yum"
          
      tags: [prepare, packages]

    # === Required Package Installation (OS Independent) ===
    - name: Install required packages
      package:
        name: "{{ item }}"
        state: present
      loop: "{{ base_packages[pkg_mgr] }}"
      vars:
        base_packages:
          apt:
            - python3
            - python3-pip
            - python3-venv
            - python3-dev
            - build-essential
            - curl
            - wget
            - git
            - jq
            - htop
            - iotop
            - net-tools
            - dnsutils
            - tar
            - gzip
            - unzip
            - ca-certificates
            - gnupg
            - lsb-release
            - software-properties-common
            - ufw
            - fail2ban
            - chrony  # Time synchronization
          yum:
            - python3
            - python3-pip
            - python3-devel
            - gcc
            - gcc-c++
            - make
            - curl
            - wget
            - git
            - jq
            - htop
            - iotop
            - net-tools
            - bind-utils
            - tar
            - gzip
            - unzip
            - ca-certificates
            - gnupg2
            - firewalld
            - fail2ban
            - chrony
          brew:
            - python3
            - curl
            - wget
            - git
            - jq
            - htop
      tags: [prepare, packages]

    # === Python Package Installation ===
    - name: Install Python packages
      pip:
        name:
          - pymongo
          - requests
          - cryptography
        state: present
        executable: pip3
      tags: [prepare, python]

    # === System User Creation ===
    - name: Create mitum system user
      user:
        name: "{{ mitum_service_user }}"
        system: yes
        shell: /bin/bash
        home: "/home/{{ mitum_service_user }}"
        createhome: yes
        comment: "Mitum blockchain service user"
      tags: [prepare, users]

    - name: Create mitum group
      group:
        name: "{{ mitum_service_group }}"
        system: yes
      tags: [prepare, users]

    # === Directory Structure Creation ===
    - name: Create required directories
      file:
        path: "{{ item.path }}"
        state: directory
        owner: "{{ item.owner | default(mitum_service_user) }}"
        group: "{{ item.group | default(mitum_service_group) }}"
        mode: "{{ item.mode | default('0755') }}"
      loop:
        - path: "{{ mitum_base_dir }}"
        - path: "{{ mitum_install_dir }}"
        - path: "{{ mitum_data_dir }}"
        - path: "{{ mitum_config_dir }}"
        - path: "{{ mitum_keys_dir }}"
          mode: "0700"  # Keys directory more restrictive
        - path: "{{ mitum_log_dir }}"
        - path: "{{ mitum_backup_dir }}"
        - path: "{{ mitum_temp_dir }}"
          owner: "root"
          mode: "1777"  # Temp with sticky bit
      tags: [prepare, directories]

    # === System Limits Configuration ===
    - name: Configure system limits
      pam_limits:
        domain: "{{ mitum_service_user }}"
        limit_type: "{{ item.type }}"
        limit_item: "{{ item.item }}"
        value: "{{ item.value }}"
      loop:
        - { type: 'soft', item: 'nofile', value: '{{ mitum_service_limits.nofile }}' }
        - { type: 'hard', item: 'nofile', value: '{{ mitum_service_limits.nofile }}' }
        - { type: 'soft', item: 'nproc', value: '{{ mitum_service_limits.nproc }}' }
        - { type: 'hard', item: 'nproc', value: '{{ mitum_service_limits.nproc }}' }
        - { type: 'soft', item: 'memlock', value: 'unlimited' }
        - { type: 'hard', item: 'memlock', value: 'unlimited' }
      tags: [prepare, limits]

    # === Kernel Parameter Optimization ===
    - name: Configure sysctl parameters
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
        sysctl_file: /etc/sysctl.d/99-mitum.conf
      loop:
        # Network optimization
        - { name: 'net.core.somaxconn', value: '32768' }
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '8192' }
        - { name: 'net.core.netdev_max_backlog', value: '5000' }
        - { name: 'net.ipv4.ip_local_port_range', value: '1024 65535' }
        - { name: 'net.ipv4.tcp_tw_reuse', value: '1' }
        - { name: 'net.ipv4.tcp_fin_timeout', value: '30' }
        
        # Memory optimization
        - { name: 'vm.swappiness', value: '10' }
        - { name: 'vm.dirty_ratio', value: '15' }
        - { name: 'vm.dirty_background_ratio', value: '5' }
        
        # File system
        - { name: 'fs.file-max', value: '2097152' }
      when: ansible_os_family != "Darwin"
      tags: [prepare, kernel]

    # === Time Synchronization Configuration ===
    - name: Configure time synchronization
      block:
        - name: Ensure chrony is running
          systemd:
            name: chrony
            state: started
            enabled: yes
          when: ansible_service_mgr == "systemd"

        - name: Configure chrony
          template:
            src: chrony.conf.j2
            dest: /etc/chrony/chrony.conf
            backup: yes
          notify: restart chrony
          when: ansible_os_family != "Darwin"
      tags: [prepare, time]

    # === Firewall Configuration ===
    - name: Configure firewall
      include_tasks: tasks/configure-firewall.yml
      when: security_hardening.firewall | default(true)
      tags: [prepare, firewall, security]

    # === Security Hardening ===
    - name: Basic security hardening
      block:
        - name: Disable root SSH login
          lineinfile:
            path: /etc/ssh/sshd_config
            regexp: '^PermitRootLogin'
            line: 'PermitRootLogin no'
            backup: yes
          notify: restart sshd
          when: security_hardening.disable_root_login | default(true)

        - name: Configure fail2ban
          template:
            src: fail2ban-jail.local.j2
            dest: /etc/fail2ban/jail.local
            backup: yes
          notify: restart fail2ban
          when: security_hardening.fail2ban | default(true)
      tags: [prepare, security]

    # === Log Rotation Configuration ===
    - name: Configure log rotation
      template:
        src: logrotate-mitum.j2
        dest: /etc/logrotate.d/mitum
      tags: [prepare, logging]

  handlers:
    - name: restart chrony
      systemd:
        name: chrony
        state: restarted
      when: ansible_service_mgr == "systemd"

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
      when: ansible_service_mgr == "systemd"

    - name: restart fail2ban
      systemd:
        name: fail2ban
        state: restarted
      when: ansible_service_mgr == "systemd"

  post_tasks:
    - name: Verify system preparation
      command: "{{ item }}"
      loop:
        - "id {{ mitum_service_user }}"
        - "ls -la {{ mitum_base_dir }}"
        - "sysctl net.core.somaxconn"
      register: verify_results
      changed_when: false

    - name: Display preparation summary
      debug:
        msg: |
          System preparation complete:
          - Package manager: {{ pkg_mgr }}
          - Service user: {{ mitum_service_user }}
          - Base directory: {{ mitum_base_dir }}
          - Security hardening: {{ security_hardening.enabled | default(true) }}

================================================================================
íŒŒì¼: playbooks/recovery.yml
================================================================================
---
# Automated recovery playbook for AWX

- name: Mitum node recovery
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  become: yes
  gather_facts: yes
  vars:
    recovery_action: "{{ recovery_action | default('restart') }}"
    
  tasks:
    - name: Check node health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: health_check
      failed_when: false
      
    - name: Determine recovery strategy
      set_fact:
        needs_recovery: "{{ health_check.status != 200 }}"
        recovery_reason: "{{ health_check.msg | default('Unknown') }}"
        
    - name: Log recovery attempt
      lineinfile:
        path: /var/log/mitum-recovery.log
        line: "[{{ ansible_date_time.iso8601 }}] Recovery attempt - Node: {{ inventory_hostname }}, Reason: {{ recovery_reason }}"
        create: yes
        
    - name: Execute recovery based on action
      block:
        - name: Restart service
          when: recovery_action == 'restart'
          systemd:
            name: mitum
            state: restarted
            
        - name: Full node recovery
          when: recovery_action == 'full'
          block:
            - name: Stop services
              systemd:
                name: "{{ item }}"
                state: stopped
              loop:
                - mitum
                - mongod
                
            - name: Clear temporary data
              file:
                path: "{{ mitum_data_dir }}/tmp"
                state: absent
                
            - name: Start services
              systemd:
                name: "{{ item }}"
                state: started
              loop:
                - mongod
                - mitum
                
        - name: Resync from network
          when: recovery_action == 'resync'
          block:
            - name: Stop Mitum
              systemd:
                name: mitum
                state: stopped
                
            - name: Remove block data
              file:
                path: "{{ mitum_data_dir }}/blockdata"
                state: absent
                
            - name: Start Mitum
              systemd:
                name: mitum
                state: started
      when: needs_recovery
      
    - name: Wait for recovery
      when: needs_recovery
      block:
        - name: Wait for service
          wait_for:
            port: "{{ mitum_node_port }}"
            timeout: 60
            
        - name: Verify recovery
          uri:
            url: "http://localhost:{{ mitum_node_port }}/v2/node"
            status_code: 200
          retries: 30
          delay: 5
          register: recovery_check
          
    - name: Report recovery status
      set_stats:
        data:
          recovery_results:
            - node: "{{ inventory_hostname }}"
              recovered: "{{ recovery_check.status == 200 if needs_recovery else 'N/A' }}"
              action: "{{ recovery_action }}"
              timestamp: "{{ ansible_date_time.iso8601 }}"
        aggregate: yes

================================================================================
íŒŒì¼: playbooks/restore.yml
================================================================================
---
# Restore Mitum nodes from backup

- name: Restore Mitum from backup
  hosts: "{{ target_nodes | default('mitum_nodes') }}"
  become: yes
  serial: 1
  vars:
    backup_dir: "{{ mitum_backup_dir | default('/var/backups/mitum') }}"
    backup_timestamp: "{{ backup_timestamp | mandatory('backup_timestamp is required') }}"
    
  pre_tasks:
    - name: Verify backup exists
      stat:
        path: "{{ backup_dir }}/{{ backup_timestamp }}"
      register: backup_check
      failed_when: not backup_check.stat.exists
      
    - name: Confirm restore operation
      pause:
        prompt: |
          WARNING: This will restore node {{ inventory_hostname }} from backup {{ backup_timestamp }}
          Current data will be overwritten!
          Press Enter to continue or Ctrl+C to abort
      when: confirm_restore | default(true)
      
  tasks:
    - name: Stop services
      systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - mitum
        - mongod
        
    - name: Create restore workspace
      file:
        path: /tmp/mitum-restore
        state: directory
        mode: '0700'
        
    - name: Restore configuration
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/config-backup.tar.gz"
        dest: /tmp/mitum-restore
        remote_src: yes
        
    - name: Restore keys
      copy:
        src: /tmp/mitum-restore/keys/
        dest: "{{ mitum_keys_dir }}/"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
        
    - name: Restore configuration files
      copy:
        src: /tmp/mitum-restore/config/
        dest: "{{ mitum_config_dir }}/"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        
    - name: Restore data (if available)
      when: restore_data | default(false)
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/data-backup.tar.gz"
        dest: "{{ mitum_data_dir | dirname }}"
        remote_src: yes
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        
    - name: Restore MongoDB (if backed up)
      when: restore_mongodb | default(false)
      shell: |
        mongorestore --drop \
          {% if mitum_mongodb_auth_enabled %}
          -u "{{ mitum_mongodb_user }}" \
          -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          {% endif %}
          --db mitum \
          {{ backup_dir }}/{{ backup_timestamp }}/mongodb-backup/mitum
          
    - name: Start services
      systemd:
        name: "{{ item }}"
        state: started
      loop:
        - mongod
        - mitum
        
    - name: Wait for services
      wait_for:
        port: "{{ item }}"
        timeout: 60
      loop:
        - "{{ mitum_mongodb_port }}"
        - "{{ mitum_node_port }}"
        
    - name: Verify restoration
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        status_code: 200
      retries: 30
      delay: 5
      
    - name: Clean up
      file:
        path: /tmp/mitum-restore
        state: absent
        
  post_tasks:
    - name: Display restore summary
      debug:
        msg: |
          Restore completed for {{ inventory_hostname }}
          Backup: {{ backup_timestamp }}
          Configuration: Restored
          Keys: Restored
          Data: {{ 'Restored' if restore_data else 'Not restored' }}
          MongoDB: {{ 'Restored' if restore_mongodb else 'Not restored' }}

================================================================================
íŒŒì¼: playbooks/rolling-upgrade.yml
================================================================================
---
# Safe Rolling Upgrade Playbook
# Version: 4.0.0 - With health checks and automatic rollback
#
# This playbook safely upgrades Mitum nodes one by one.
# 
# Features:
# - Upgrades one node at a time
# - Health checks at each step
# - Automatic rollback on failure
# - Maintains consensus
# - Zero downtime

- name: Rolling upgrade preparation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Validate upgrade parameters
      assert:
        that:
          - mitum_version is defined
          - mitum_version != "latest"  # Specific version required
        fail_msg: "Specific version required for upgrade (not 'latest')"

    - name: Set upgrade metadata
      set_fact:
        upgrade_id: "upgrade-{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
        upgrade_start_time: "{{ ansible_date_time.epoch }}"
        rollback_enabled: "{{ enable_rollback | default(true) }}"
        
    - name: Display upgrade plan
      debug:
        msg: |
          ========================================
          Rolling Upgrade Plan
          ========================================
          Upgrade ID: {{ upgrade_id }}
          Current Version: (will be detected)
          Target Version: {{ mitum_version }}
          Rollback Enabled: {{ rollback_enabled }}
          
          Nodes to upgrade: {{ groups['mitum_nodes'] | length }}
          Batch Size: {{ mitum_upgrade.batch_size | default(1) }}
          Batch Delay: {{ mitum_upgrade.batch_delay | default(60) }}s
          ========================================

# === Gather Current State ===
- name: Gather current state
  hosts: mitum_nodes
  gather_facts: yes
  tasks:
    - name: Get current Mitum version
      command: "{{ mitum_install_dir }}/mitum version"
      register: current_version_raw
      changed_when: false
      failed_when: false

    - name: Parse version
      set_fact:
        current_mitum_version: "{{ current_version_raw.stdout | regex_search('v[0-9.]+') | default('unknown') }}"

    - name: Check node health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: node_health
      failed_when: false

    - name: Get consensus state
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/consensus/state"
        timeout: 5
      register: consensus_state
      failed_when: false
      when: not (mitum_api_enabled | default(false))

    - name: Save current state
      set_fact:
        node_state:
          hostname: "{{ inventory_hostname }}"
          current_version: "{{ current_mitum_version }}"
          is_healthy: "{{ node_health.status | default(0) == 200 }}"
          consensus_state: "{{ consensus_state.json.consensus.state | default('N/A') if consensus_state.json is defined else 'N/A' }}"
          role: "{{ 'api' if mitum_api_enabled | default(false) else 'consensus' }}"

# === Pre-upgrade Validation ===
- name: Pre-upgrade validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Aggregate node states
      set_fact:
        all_nodes_state: "{{ groups['mitum_nodes'] | map('extract', hostvars, 'node_state') | list }}"

    - name: Check if upgrade needed
      set_fact:
        nodes_need_upgrade: "{{ all_nodes_state | selectattr('current_version', 'ne', mitum_version) | list }}"

    - name: Display current state
      debug:
        msg: |
          Current cluster state:
          {% for node in all_nodes_state %}
          - {{ node.hostname }}: {{ node.current_version }} ({{ node.role }}) - {{ 'Healthy' if node.is_healthy else 'Unhealthy' }}
          {% endfor %}
          
          Nodes requiring upgrade: {{ nodes_need_upgrade | length }}

    - name: Verify cluster health
      assert:
        that:
          - all_nodes_state | selectattr('is_healthy', 'equalto', true) | list | length >= (groups['mitum_nodes'] | length * 0.8)
        fail_msg: "Cluster not healthy enough for upgrade. Please fix issues first."

    - name: Skip if no upgrade needed
      meta: end_play
      when: nodes_need_upgrade | length == 0

# === Create Pre-upgrade Backup ===
- name: Create pre-upgrade backup
  import_playbook: backup.yml
  vars:
    backup_type: "pre-upgrade"
    backup_tag: "{{ upgrade_id }}"
  when: mitum_upgrade.backup_before_upgrade | default(true)

# === Upgrade Consensus Nodes ===
- name: Upgrade consensus nodes
  hosts: mitum_nodes
  serial: "{{ mitum_upgrade.batch_size | default(1) }}"
  max_fail_percentage: 0
  become: yes
  
  # Skip API nodes in this phase
  gather_facts: no
  tasks:
    - name: Skip API nodes in consensus phase
      meta: end_host
      when: mitum_api_enabled | default(false)

    - name: Include upgrade tasks
      include_tasks: tasks/upgrade-node.yml
      vars:
        node_type: "consensus"

# === Upgrade API/Syncer Nodes ===
- name: Upgrade API/syncer nodes
  hosts: mitum_nodes
  serial: "{{ mitum_upgrade.batch_size | default(1) }}"
  become: yes
  gather_facts: no
  
  tasks:
    - name: Skip consensus nodes
      meta: end_host
      when: not (mitum_api_enabled | default(false))

    - name: Include upgrade tasks
      include_tasks: tasks/upgrade-node.yml
      vars:
        node_type: "api"

# === Post-upgrade Validation ===
- name: Post-upgrade validation
  hosts: mitum_nodes
  gather_facts: no
  tasks:
    - name: Verify upgraded version
      command: "{{ mitum_install_dir }}/mitum version"
      register: new_version_raw
      changed_when: false

    - name: Parse new version
      set_fact:
        new_mitum_version: "{{ new_version_raw.stdout | regex_search('v[0-9.]+') | default('unknown') }}"

    - name: Verify version matches target
      assert:
        that:
          - new_mitum_version == mitum_version
        fail_msg: "Version mismatch: expected {{ mitum_version }}, got {{ new_mitum_version }}"

    - name: Check node health
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: final_health
      retries: 10
      delay: 6

    - name: Verify consensus participation
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/consensus/state"
        timeout: 5
      register: final_consensus
      when: not (mitum_api_enabled | default(false))
      retries: 10
      delay: 6

# === Final Cluster Validation ===
- name: Final cluster validation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Aggregate final states
      set_fact:
        final_nodes_state: "{{ groups['mitum_nodes'] | map('extract', hostvars, ['new_mitum_version']) | list }}"

    - name: Check all nodes upgraded
      assert:
        that:
          - final_nodes_state | select('equalto', mitum_version) | list | length == groups['mitum_nodes'] | length
        fail_msg: "Not all nodes successfully upgraded"

    - name: Calculate upgrade duration
      set_fact:
        upgrade_duration: "{{ (ansible_date_time.epoch | int) - (upgrade_start_time | int) }}"

    - name: Display upgrade summary
      debug:
        msg: |
          ========================================
          Rolling Upgrade Complete!
          ========================================
          Upgrade ID: {{ upgrade_id }}
          Duration: {{ upgrade_duration }} seconds
          
          All nodes successfully upgraded to {{ mitum_version }}
          
          Next steps:
          1. Monitor cluster: make status
          2. Check logs: make logs
          3. Verify API: curl http://<api-node>:{{ mitum_api_port }}/v2/node
          ========================================

# === Failure Handler ===
- name: Upgrade failure handler
  hosts: all
  gather_facts: no
  tasks:
    - name: Trigger rollback if enabled
      include_tasks: tasks/rollback-node.yml
      when: 
        - rollback_enabled | default(true)
        - ansible_failed_task is defined
        - ansible_failed_result is defined

================================================================================
íŒŒì¼: playbooks/setup-bastion.yml
================================================================================
---
# Setup SSH configuration for bastion host access

- name: Configure local SSH for bastion access
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Create .ssh directory
      file:
        path: "{{ ansible_env.HOME }}/.ssh"
        state: directory
        mode: '0700'
        
    - name: Generate SSH config from inventory
      template:
        src: ssh_config.j2
        dest: "{{ ansible_env.HOME }}/.ssh/config.d/mitum"
        mode: '0600'
      vars:
        bastion_host: "{{ groups['bastion'][0] }}"
        bastion_user: "{{ hostvars[groups['bastion'][0]]['ansible_user'] }}"
        bastion_port: "{{ hostvars[groups['bastion'][0]]['ansible_port'] | default(22) }}"
        
    - name: Include Mitum SSH config in main SSH config
      lineinfile:
        path: "{{ ansible_env.HOME }}/.ssh/config"
        line: "Include ~/.ssh/config.d/mitum"
        create: yes
        mode: '0600'
        
    - name: Test SSH multiplexing setup
      command: ssh -O check bastion
      register: multiplex_check
      failed_when: false
      changed_when: false
      
    - name: Establish SSH control connection to bastion
      command: ssh -N -f bastion
      when: multiplex_check.rc != 0

- name: Verify bastion connectivity
  hosts: bastion
  gather_facts: yes
  tasks:
    - name: Check bastion host
      ping:
      
    - name: Install required packages on bastion
      become: yes
      package:
        name:
          - netcat-openbsd
          - tcpdump
          - htop
          - iotop
        state: present
        
    - name: Configure bastion SSH daemon
      become: yes
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^MaxSessions', line: 'MaxSessions 50' }
        - { regexp: '^MaxStartups', line: 'MaxStartups 50:30:100' }
        - { regexp: '^ClientAliveInterval', line: 'ClientAliveInterval 60' }
        - { regexp: '^ClientAliveCountMax', line: 'ClientAliveCountMax 3' }
        - { regexp: '^TCPKeepAlive', line: 'TCPKeepAlive yes' }
      notify: restart sshd
      
  handlers:
    - name: restart sshd
      become: yes
      service:
        name: sshd
        state: restarted

- name: Test connectivity through bastion
  hosts: mitum_nodes
  gather_facts: no
  tasks:
    - name: Test connection through bastion
      ping:
      register: ping_result
      
    - name: Show connection info
      debug:
        msg: |
          Host: {{ inventory_hostname }}
          IP: {{ ansible_host }}
          Connection: {{ 'SUCCESS' if ping_result.ping == 'pong' else 'FAILED' }}
          
    - name: Check SSH multiplexing status
      local_action:
        module: command
        cmd: ssh -O check {{ inventory_hostname }}
      register: mux_status
      failed_when: false
      changed_when: false
      
    - name: Display multiplexing status
      debug:
        msg: "SSH Multiplexing: {{ 'Active' if mux_status.rc == 0 else 'Not Active' }}"

- name: Optimize SSH connections
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Create SSH ControlPath directory
      file:
        path: /tmp/ansible-ssh-sockets
        state: directory
        mode: '0700'
        
    - name: Setup connection pooling script
      copy:
        content: |
          #!/bin/bash
          # SSH connection pool manager for Mitum Ansible
          
          SOCKET_DIR="/tmp/ansible-ssh-sockets"
          HOSTS="{{ groups['mitum_nodes'] | join(' ') }}"
          
          case "$1" in
            start)
              echo "Starting SSH connection pool..."
              mkdir -p "$SOCKET_DIR"
              
              # Start bastion connection first
              ssh -M -N -f -o ControlPath="$SOCKET_DIR/bastion.sock" bastion
              
              # Start connections to all nodes
              for host in $HOSTS; do
                echo "Establishing connection to $host..."
                ssh -M -N -f -o ControlPath="$SOCKET_DIR/$host.sock" "$host"
              done
              echo "Connection pool established."
              ;;
              
            stop)
              echo "Stopping SSH connection pool..."
              for sock in "$SOCKET_DIR"/*.sock; do
                if [ -e "$sock" ]; then
                  ssh -O exit -o ControlPath="$sock" localhost 2>/dev/null || true
                fi
              done
              rm -f "$SOCKET_DIR"/*.sock
              echo "Connection pool stopped."
              ;;
              
            status)
              echo "SSH connection pool status:"
              for sock in "$SOCKET_DIR"/*.sock; do
                if [ -e "$sock" ]; then
                  host=$(basename "$sock" .sock)
                  if ssh -O check -o ControlPath="$sock" localhost 2>/dev/null; then
                    echo "  $host: Active"
                  else
                    echo "  $host: Inactive"
                  fi
                fi
              done
              ;;
              
            *)
              echo "Usage: $0 {start|stop|status}"
              exit 1
              ;;
          esac
        dest: "{{ ansible_env.HOME }}/bin/ssh-pool"
        mode: '0755'
        
    - name: Create systemd user service for SSH pool (optional)
      copy:
        content: |
          [Unit]
          Description=SSH Connection Pool for Mitum Ansible
          After=network.target
          
          [Service]
          Type=forking
          ExecStart={{ ansible_env.HOME }}/bin/ssh-pool start
          ExecStop={{ ansible_env.HOME }}/bin/ssh-pool stop
          RemainAfterExit=yes
          
          [Install]
          WantedBy=default.target
        dest: "{{ ansible_env.HOME }}/.config/systemd/user/ssh-pool.service"
      when: ansible_service_mgr == "systemd"

================================================================================
íŒŒì¼: playbooks/setup-monitoring-alerts.yml
================================================================================
---
# Enhanced Monitoring and Alerting Setup for Mitum Network
# Includes Prometheus, Grafana, AlertManager, and custom alerts

- name: Deploy monitoring and alerting stack
  hosts: monitoring
  become: true
  vars:
    prometheus_version: "2.40.0"
    grafana_version: "9.3.0"
    alertmanager_version: "0.25.0"
    node_exporter_version: "1.5.0"
    
  tasks:
    # Install Prometheus
    - name: Create Prometheus user
      user:
        name: prometheus
        system: true
        shell: /bin/false
        home: /var/lib/prometheus
        createhome: true
        
    - name: Download and install Prometheus
      unarchive:
        src: "https://github.com/prometheus/prometheus/releases/download/v{{ prometheus_version }}/prometheus-{{ prometheus_version }}.linux-amd64.tar.gz"
        dest: /tmp
        remote_src: yes
        
    - name: Install Prometheus binaries
      copy:
        src: "/tmp/prometheus-{{ prometheus_version }}.linux-amd64/{{ item }}"
        dest: "/usr/local/bin/{{ item }}"
        mode: '0755'
        owner: root
        group: root
        remote_src: yes
      loop:
        - prometheus
        - promtool
        
    - name: Create Prometheus configuration
      template:
        src: prometheus.yml.j2
        dest: /etc/prometheus/prometheus.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus
      
    - name: Create Prometheus service
      template:
        src: prometheus.service.j2
        dest: /etc/systemd/system/prometheus.service
      notify: restart prometheus
      
    # Install AlertManager
    - name: Download and install AlertManager
      unarchive:
        src: "https://github.com/prometheus/alertmanager/releases/download/v{{ alertmanager_version }}/alertmanager-{{ alertmanager_version }}.linux-amd64.tar.gz"
        dest: /tmp
        remote_src: yes
        
    - name: Install AlertManager binary
      copy:
        src: "/tmp/alertmanager-{{ alertmanager_version }}.linux-amd64/alertmanager"
        dest: /usr/local/bin/alertmanager
        mode: '0755'
        owner: root
        group: root
        remote_src: yes
        
    - name: Configure AlertManager
      template:
        src: alertmanager.yml.j2
        dest: /etc/alertmanager/alertmanager.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart alertmanager
      
    # Install Grafana
    - name: Add Grafana repository
      yum_repository:
        name: grafana
        description: Grafana repository
        baseurl: https://packages.grafana.com/oss/rpm
        gpgcheck: yes
        gpgkey: https://packages.grafana.com/gpg.key
      when: ansible_os_family == "RedHat"
      
    - name: Install Grafana
      package:
        name: grafana
        state: present
        
    - name: Configure Grafana
      template:
        src: grafana.ini.j2
        dest: /etc/grafana/grafana.ini
        owner: grafana
        group: grafana
        mode: '0640'
      notify: restart grafana
      
    # Configure Mitum-specific alerts
    - name: Create Mitum alert rules
      copy:
        content: |
          groups:
          - name: mitum_alerts
            interval: 30s
            rules:
            - alert: MitumNodeDown
              expr: up{job="mitum"} == 0
              for: 5m
              labels:
                severity: critical
              annotations:
                summary: "Mitum node {{ $labels.instance }} is down"
                description: "Mitum node {{ $labels.instance }} has been down for more than 5 minutes."
                
            - alert: MitumBlockHeightStalled
              expr: rate(mitum_block_height[5m]) == 0
              for: 10m
              labels:
                severity: warning
              annotations:
                summary: "Mitum block height stalled on {{ $labels.instance }}"
                description: "Block height has not increased for 10 minutes on {{ $labels.instance }}."
                
            - alert: MitumHighMemoryUsage
              expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) > 0.85
              for: 5m
              labels:
                severity: warning
              annotations:
                summary: "High memory usage on {{ $labels.instance }}"
                description: "Memory usage is above 85% on {{ $labels.instance }}."
                
            - alert: MitumDiskSpaceLow
              expr: (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"}) < 0.15
              for: 5m
              labels:
                severity: warning
              annotations:
                summary: "Low disk space on {{ $labels.instance }}"
                description: "Less than 15% disk space remaining on {{ $labels.instance }}."
                
            - alert: MitumPeerCountLow
              expr: mitum_peers_connected < 2
              for: 5m
              labels:
                severity: warning
              annotations:
                summary: "Low peer count on {{ $labels.instance }}"
                description: "Connected peers count is less than 2 on {{ $labels.instance }}."
        dest: /etc/prometheus/rules/mitum_alerts.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus
      
    # Setup notification channels
    - name: Configure Slack notifications
      blockinfile:
        path: /etc/alertmanager/alertmanager.yml
        block: |
          route:
            group_by: ['alertname', 'cluster', 'service']
            group_wait: 10s
            group_interval: 10s
            repeat_interval: 12h
            receiver: 'slack-notifications'
            routes:
            - match:
                severity: critical
              receiver: pagerduty-critical
              
          receivers:
          - name: 'slack-notifications'
            slack_configs:
            - api_url: '{{ slack_webhook_url }}'
              channel: '#mitum-alerts'
              title: 'Mitum Alert'
              text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
              
          - name: 'pagerduty-critical'
            pagerduty_configs:
            - service_key: '{{ pagerduty_service_key }}'
      when: slack_webhook_url is defined
      
    # Install Grafana dashboards
    - name: Create Mitum dashboard
      copy:
        src: mitum-dashboard.json
        dest: /var/lib/grafana/dashboards/mitum-dashboard.json
        owner: grafana
        group: grafana
        mode: '0644'
        
    # Start services
    - name: Start and enable monitoring services
      systemd:
        name: "{{ item }}"
        state: started
        enabled: yes
        daemon_reload: yes
      loop:
        - prometheus
        - alertmanager
        - grafana
        - node_exporter
        
  handlers:
    - name: restart prometheus
      systemd:
        name: prometheus
        state: restarted
        
    - name: restart alertmanager
      systemd:
        name: alertmanager
        state: restarted
        
    - name: restart grafana
      systemd:
        name: grafana-server
        state: restarted 

================================================================================
íŒŒì¼: playbooks/setup-monitoring.yml
================================================================================
---
# Setup Prometheus monitoring for Mitum nodes

- name: Deploy Prometheus monitoring stack
  hosts: monitoring
  become: yes
  vars:
    prometheus_version: "2.45.0"
    alertmanager_version: "0.26.0"
    grafana_version: "10.2.0"
  
  tasks:
    - name: Create monitoring user
      user:
        name: prometheus
        system: yes
        shell: /usr/sbin/nologin
        home: /var/lib/prometheus
        create_home: no

    - name: Create prometheus directories
      file:
        path: "{{ item }}"
        state: directory
        owner: prometheus
        group: prometheus
        mode: '0755'
      loop:
        - /etc/prometheus
        - /etc/prometheus/rules
        - /var/lib/prometheus

    - name: Download Prometheus
      unarchive:
        src: "https://github.com/prometheus/prometheus/releases/download/v{{ prometheus_version }}/prometheus-{{ prometheus_version }}.linux-amd64.tar.gz"
        dest: /tmp
        remote_src: yes
        creates: /tmp/prometheus-{{ prometheus_version }}.linux-amd64

    - name: Install Prometheus binaries
      copy:
        src: "/tmp/prometheus-{{ prometheus_version }}.linux-amd64/{{ item }}"
        dest: "/usr/local/bin/{{ item }}"
        owner: root
        group: root
        mode: '0755'
        remote_src: yes
      loop:
        - prometheus
        - promtool

    - name: Configure Prometheus
      template:
        src: prometheus.yml.j2
        dest: /etc/prometheus/prometheus.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus

    - name: Create Prometheus service
      template:
        src: prometheus.service.j2
        dest: /etc/systemd/system/prometheus.service
      notify:
        - reload systemd
        - restart prometheus

    - name: Configure Alertmanager
      when: mitum_alerting_enabled | default(true)
      block:
        - name: Download Alertmanager
          unarchive:
            src: "https://github.com/prometheus/alertmanager/releases/download/v{{ alertmanager_version }}/alertmanager-{{ alertmanager_version }}.linux-amd64.tar.gz"
            dest: /tmp
            remote_src: yes

        - name: Install Alertmanager
          copy:
            src: "/tmp/alertmanager-{{ alertmanager_version }}.linux-amd64/alertmanager"
            dest: /usr/local/bin/alertmanager
            mode: '0755'
            remote_src: yes

        - name: Configure Alertmanager
          template:
            src: alertmanager.yml.j2
            dest: /etc/prometheus/alertmanager.yml

        - name: Create Alertmanager service
          template:
            src: alertmanager.service.j2
            dest: /etc/systemd/system/alertmanager.service

    - name: Start monitoring services
      systemd:
        name: "{{ item }}"
        state: started
        enabled: yes
        daemon_reload: yes
      loop:
        - prometheus
        - alertmanager

- name: Configure nodes for monitoring
  hosts: mitum_nodes
  become: yes
  tasks:
    - name: Setup node monitoring
      include_role:
        name: mitum
        tasks_from: monitoring-prometheus

    - name: Configure firewall for monitoring
      ufw:
        rule: allow
        port: "{{ item }}"
        src: "{{ hostvars[groups['monitoring'][0]]['ansible_default_ipv4']['address'] }}"
      loop:
        - "9100"  # Node exporter
        - "9099"  # Mitum metrics
        - "9216"  # MongoDB exporter
      when: ansible_os_family == "Debian"

- name: Setup AWX integration
  hosts: localhost
  tasks:
    - name: Configure AWX monitoring
      include_tasks: awx-integration.yml
      when: awx_integration_enabled | default(false)

================================================================================
íŒŒì¼: playbooks/site.yml
================================================================================
---
# Main Site Playbook for Mitum Deployment
# Version: 4.0.0 - Enhanced with pre/post checks and modular structure
#
# This playbook orchestrates the entire Mitum blockchain deployment.
# 
# Execution order:
# 1. Pre-flight checks
# 2. System preparation
# 3. MongoDB installation and configuration
# 4. Mitum key generation
# 5. Mitum node deployment
# 6. Monitoring setup (optional)
# 7. Post-deployment validation
#
# Usage:
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml
#
# Execute specific stages only:
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml --tags prepare
#
# Dry run (preview changes):
# ansible-playbook -i inventories/production/hosts.yml playbooks/site.yml --check

# === Set Deployment Metadata ===
- name: Set deployment metadata
  hosts: all
  gather_facts: no
  tags: [always]
  tasks:
    - name: Set deployment ID and timestamp
      set_fact:
        deployment_id: "{{ deployment_id | default(lookup('pipe', 'date +%Y%m%d-%H%M%S')) }}"
        deployment_timestamp: "{{ ansible_date_time.iso8601 }}"
        deployment_user: "{{ lookup('env', 'USER') }}"
      run_once: true
      delegate_to: localhost

    - name: Display deployment information
      debug:
        msg: |
          ========================================
          Mitum Deployment Started
          ========================================
          Deployment ID: {{ deployment_id }}
          Environment: {{ mitum_environment }}
          Network ID: {{ mitum_network_id }}
          Model Type: {{ mitum_model_type }}
          User: {{ deployment_user }}
          Timestamp: {{ deployment_timestamp }}
          ========================================
      run_once: true

# === 1. Pre-deployment Validation ===
- name: Pre-deployment validation
  import_playbook: pre-deploy-check.yml
  tags: [precheck, validation]

# === 2. System Preparation ===
- name: Prepare systems
  import_playbook: prepare-system.yml
  tags: [prepare, system]
  when: not skip_prepare | default(false)

# === 3. SSH Host Key Collection (Security) ===
- name: Gather SSH host keys
  import_playbook: gather-host-keys.yml
  tags: [security, ssh]
  when: strict_host_key_checking | default(true)

# === 4. MongoDB Installation ===
- name: Setup MongoDB
  import_playbook: setup-mongodb.yml
  tags: [mongodb, database]
  when: not skip_mongodb | default(false)

# === 5. Key Generation ===
- name: Generate Mitum keys
  import_playbook: keygen.yml
  tags: [keygen, keys]
  when: not skip_keygen | default(false)

# === 6. Mitum Deployment ===
- name: Deploy Mitum nodes
  import_playbook: deploy-mitum.yml
  tags: [deploy, mitum]

# === 7. Monitoring Setup (Optional) ===
- name: Setup monitoring
  import_playbook: setup-monitoring.yml
  tags: [monitoring]
  when: 
    - mitum_monitoring.enabled | default(false)
    - groups['monitoring'] is defined
    - groups['monitoring'] | length > 0

# === 8. Backup Configuration ===
- name: Configure backup
  import_playbook: setup-backup.yml
  tags: [backup]
  when: mitum_backup.enabled | default(false)

# === 9. Post-deployment Validation ===
- name: Post-deployment validation
  import_playbook: post-deploy-check.yml
  tags: [postcheck, validation]

# === 10. Deployment Summary ===
- name: Deployment summary
  hosts: localhost
  gather_facts: no
  tags: [always]
  tasks:
    - name: Generate deployment report
      template:
        src: deployment-report.j2
        dest: "{{ playbook_dir }}/../reports/deployment-{{ deployment_id }}.txt"
      delegate_to: localhost
      run_once: true

    - name: Display deployment summary
      debug:
        msg: |
          ========================================
          Mitum Deployment Complete!
          ========================================
          Deployment ID: {{ deployment_id }}
          Duration: {{ (ansible_date_time.epoch | int) - (deployment_start_time | default(ansible_date_time.epoch) | int) }} seconds
          
          Nodes Deployed: {{ groups['mitum_nodes'] | length }}
          - Consensus: {{ groups['mitum_nodes'] | select('match', '.*consensus.*') | list | length }}
          - API/Syncer: {{ groups['mitum_nodes'] | select('match', '.*api.*') | list | length }}
          
          Services Status:
          - MongoDB: {{ mongodb_status | default('Unknown') }}
          - Mitum: {{ mitum_status | default('Unknown') }}
          - Monitoring: {{ monitoring_status | default('N/A') }}
          
          Next Steps:
          1. Check status: make status
          2. View logs: make logs
          3. Access API: curl http://<api-node>:{{ mitum_api_port }}/v2/node
          
          Report saved to: reports/deployment-{{ deployment_id }}.txt
          ========================================
      run_once: true

# === Error Handling ===
- name: Deployment failure handler
  hosts: all
  gather_facts: no
  tags: [always]
  tasks:
    - name: Deployment failed notification
      debug:
        msg: |
          ========================================
          DEPLOYMENT FAILED!
          ========================================
          Error in: {{ ansible_failed_task.name | default('Unknown task') }}
          Host: {{ ansible_hostname | default('Unknown host') }}
          
          Please check:
          1. Ansible logs: logs/ansible.log
          2. Host connectivity: make test
          3. Requirements: make validate
          
          Rollback instructions:
          1. Restore from backup: make restore BACKUP_TIMESTAMP=<timestamp>
          2. Or clean install: make clean-data && make deploy
          ========================================
      when: ansible_failed_task is defined
      run_once: true

================================================================================
íŒŒì¼: playbooks/test.yml
================================================================================
---
- name: Test connectivity and setup
  hosts: mitum_nodes
  gather_facts: yes
  tasks:
    - name: Test connection
      ping:
    
    - name: Show system info
      debug:
        msg: |
          Hostname: {{ ansible_hostname }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          CPU: {{ ansible_processor_vcpus }} cores
          Memory: {{ ansible_memtotal_mb }} MB
    
    - name: Check required tools
      command: "{{ item }} --version"
      loop:
        - python3
        - node
        - jq
      register: tool_versions
      changed_when: false
      failed_when: false
    
    - name: Display tool versions
      debug:
        msg: "{{ item.item }}: {{ item.stdout_lines[0] | default('Not installed') }}"
      loop: "{{ tool_versions.results }}"

================================================================================
íŒŒì¼: playbooks/validate.yml
================================================================================
---
# Comprehensive validation playbook for Mitum cluster

- name: Gather cluster information
  hosts: mitum_nodes
  gather_facts: yes
  tasks:
    - name: Check Mitum service status
      systemd:
        name: "{{ mitum_service_name }}"
      register: service_status
      
    - name: Get Mitum version
      command: "{{ mitum_install_dir }}/{{ mitum_model_type }} version"
      register: mitum_version
      changed_when: false
      failed_when: false
      
    - name: Check node API endpoint
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/node"
        timeout: 5
      register: node_api
      failed_when: false
      
    - name: Check consensus state (consensus nodes only)
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/consensus/state"
        timeout: 5
      register: consensus_state
      failed_when: false
      when: not (mitum_api_enabled | default(false))
      
    - name: Get block manifest
      uri:
        url: "http://localhost:{{ mitum_node_port }}/v2/block/manifest"
        timeout: 5
      register: block_manifest
      failed_when: false
      
    - name: Check MongoDB connection
      command: |
        mongosh --quiet --eval "db.adminCommand('ping')" \
        {% if mitum_mongodb_auth_enabled %}
        -u {{ mitum_mongodb_user }} -p {{ mitum_mongodb_password }} \
        {% endif %}
        mongodb://localhost:{{ mitum_mongodb_port }}/{{ mitum_mongodb_database }}
      register: mongodb_check
      failed_when: false
      changed_when: false
      
    - name: Collect validation results
      set_fact:
        node_validation:
          hostname: "{{ inventory_hostname }}"
          node_id: "{{ mitum_node_id }}"
          node_type: "{{ 'API/Syncer' if mitum_api_enabled | default(false) else 'Consensus' }}"
          service:
            name: "{{ mitum_service_name }}"
            state: "{{ service_status.status.ActiveState }}"
            enabled: "{{ service_status.status.UnitFileState == 'enabled' }}"
          version: "{{ mitum_version.stdout | default('Unknown') }}"
          api:
            available: "{{ node_api.status | default(0) == 200 }}"
            response_time: "{{ node_api.elapsed | default(-1) }}"
          consensus:
            available: "{{ consensus_state.status | default(0) == 200 }}"
            state: "{{ consensus_state.json.consensus.state | default('N/A') if consensus_state.json is defined else 'N/A' }}"
          block:
            height: "{{ block_manifest.json.height | default(-1) if block_manifest.json is defined else -1 }}"
            hash: "{{ block_manifest.json.hash | default('N/A') if block_manifest.json is defined else 'N/A' }}"
          mongodb:
            connected: "{{ mongodb_check.rc | default(1) == 0 }}"
          system:
            cpu_count: "{{ ansible_processor_vcpus }}"
            memory_mb: "{{ ansible_memtotal_mb }}"
            disk_free_gb: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/') | first).size_available | default(0) / 1024 / 1024 / 1024 | round(2) }}"

- name: Analyze cluster health
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Aggregate validation results
      set_fact:
        cluster_validation:
          timestamp: "{{ ansible_date_time.iso8601 }}"
          network_id: "{{ mitum_network_id }}"
          total_nodes: "{{ groups['mitum_nodes'] | length }}"
          nodes: "{{ groups['mitum_nodes'] | map('extract', hostvars, 'node_validation') | list }}"
          
    - name: Calculate cluster statistics
      set_fact:
        cluster_stats:
          services_running: "{{ cluster_validation.nodes | selectattr('service.state', 'equalto', 'active') | list | length }}"
          apis_available: "{{ cluster_validation.nodes | selectattr('api.available') | list | length }}"
          consensus_nodes: "{{ cluster_validation.nodes | selectattr('node_type', 'equalto', 'Consensus') | list | length }}"
          consensus_active: "{{ cluster_validation.nodes | selectattr('node_type', 'equalto', 'Consensus') | selectattr('consensus.state', 'in', ['CONSENSUS', 'SYNCING']) | list | length }}"
          mongodb_connected: "{{ cluster_validation.nodes | selectattr('mongodb.connected') | list | length }}"
          block_heights: "{{ cluster_validation.nodes | map(attribute='block.height') | select('>', -1) | list }}"
          
    - name: Determine cluster health status
      set_fact:
        cluster_health:
          overall: >-
            {%- if cluster_stats.services_running < cluster_validation.total_nodes -%}
            CRITICAL
            {%- elif cluster_stats.consensus_active < (cluster_stats.consensus_nodes * 0.67) | round(0, 'ceil') | int -%}
            CRITICAL
            {%- elif cluster_stats.block_heights | unique | length > 1 -%}
            WARNING
            {%- else -%}
            HEALTHY
            {%- endif -%}
          consensus_threshold_met: "{{ cluster_stats.consensus_active >= (cluster_stats.consensus_nodes * 0.67) | round(0, 'ceil') | int }}"
          block_sync_status: "{{ 'Synced' if cluster_stats.block_heights | unique | length == 1 else 'Out of sync' }}"
          max_block_height: "{{ cluster_stats.block_heights | max | default(0) }}"
          min_block_height: "{{ cluster_stats.block_heights | min | default(0) }}"
          
    - name: Generate validation report
      template:
        src: validation-report.j2
        dest: "{{ playbook_dir }}/../reports/validation-{{ ansible_date_time.epoch }}.txt"
        
    - name: Display validation summary
      debug:
        msg: |
          ========================================
          Mitum Cluster Validation Report
          ========================================
          Network ID: {{ mitum_network_id }}
          Timestamp: {{ cluster_validation.timestamp }}
          
          CLUSTER STATUS: {{ cluster_health.overall }}
          
          Node Summary:
          - Total Nodes: {{ cluster_validation.total_nodes }}
          - Services Running: {{ cluster_stats.services_running }}/{{ cluster_validation.total_nodes }}
          - APIs Available: {{ cluster_stats.apis_available }}
          - MongoDB Connected: {{ cluster_stats.mongodb_connected }}/{{ cluster_validation.total_nodes }}
          
          Consensus Status:
          - Consensus Nodes: {{ cluster_stats.consensus_nodes }}
          - Active in Consensus: {{ cluster_stats.consensus_active }}
          - Threshold Met: {{ cluster_health.consensus_threshold_met }}
          - Required for Consensus: {{ (cluster_stats.consensus_nodes * 0.67) | round(0, 'ceil') | int }}
          
          Blockchain Status:
          - Sync Status: {{ cluster_health.block_sync_status }}
          - Max Block Height: {{ cluster_health.max_block_height }}
          - Min Block Height: {{ cluster_health.min_block_height }}
          - Height Difference: {{ cluster_health.max_block_height - cluster_health.min_block_height }}
          
          Node Details:
          {% for node in cluster_validation.nodes %}
          
          {{ node.hostname }} (Node {{ node.node_id }}):
            Type: {{ node.node_type }}
            Service: {{ node.service.state }}
            Version: {{ node.version }}
            API: {{ 'Available' if node.api.available else 'Not Available' }}
            {% if node.node_type == 'Consensus' %}
            Consensus: {{ node.consensus.state }}
            {% endif %}
            Block Height: {{ node.block.height }}
            MongoDB: {{ 'Connected' if node.mongodb.connected else 'Not Connected' }}
          {% endfor %}
          ========================================
          
    - name: Alert on critical issues
      when: cluster_health.overall == "CRITICAL"
      fail:
        msg: |
          CRITICAL: Cluster health check failed!
          - Services Running: {{ cluster_stats.services_running }}/{{ cluster_validation.total_nodes }}
          - Consensus Active: {{ cluster_stats.consensus_active }}/{{ cluster_stats.consensus_nodes }}
          - Consensus Threshold Met: {{ cluster_health.consensus_threshold_met }}
          Please check the detailed report for more information.
          
    - name: Warn on issues
      when: cluster_health.overall == "WARNING"
      debug:
        msg: |
          WARNING: Cluster has some issues
          - Block sync status: {{ cluster_health.block_sync_status }}
          - Height difference: {{ cluster_health.max_block_height - cluster_health.min_block_height }}
          
    - name: Save validation results
      copy:
        content: "{{ cluster_validation | to_nice_yaml }}"
        dest: "{{ playbook_dir }}/../reports/validation-{{ ansible_date_time.epoch }}.yml"

================================================================================
íŒŒì¼: requirements.txt
================================================================================
# Python Requirements for Mitum Ansible
# Version: 4.0.0
#
# This file manages versions of Ansible and related Python packages.
# Installation: pip install -r requirements.txt

# === Core Ansible ===
ansible>=6.0.0,<7.0.0              # Ansible core package
ansible-core>=2.13.0,<2.14.0       # Ansible core engine

# === Ansible Tools ===
ansible-lint>=6.0.0                # Playbook quality checker
ansible-vault>=2.1.0               # Vault encryption management
ansible-runner>=2.3.0              # Ansible execution environment
molecule>=4.0.0                    # Ansible testing framework (optional)

# === Required Libraries ===
jmespath>=1.0.0                    # JSON query language (used in ec2_instance etc.)
netaddr>=0.8.0                     # IP address and network manipulation
pymongo>=4.0.0                     # MongoDB Python driver
dnspython>=2.3.0                   # DNS lookups (for MongoDB SRV records)
cryptography>=40.0.0               # Cryptographic operations (Vault, SSL)
paramiko>=3.0.0                    # SSH client library

# === Templating and Parsing ===
pyyaml>=6.0                        # YAML file processing
jinja2>=3.1.0                      # Template engine
MarkupSafe>=2.1.0                  # Jinja2 dependency
ruamel.yaml>=0.17.0                # YAML file preservation

# === Utilities ===
python-dateutil>=2.8.0             # Date/time handling
requests>=2.28.0                   # HTTP request handling
urllib3>=1.26.0,<2.0.0             # HTTP client
packaging>=23.0                    # Version comparison and handling
rich>=13.0.0                       # Rich terminal output

# === Cloud Providers (Optional) ===
# For AWS usage
boto3>=1.26.0                      # AWS SDK
botocore>=1.29.0                   # AWS core library

# For GCP usage
# google-auth>=2.16.0
# google-cloud-compute>=1.0.0

# For Azure usage
# azure-mgmt-compute>=29.0.0
# azure-mgmt-network>=22.0.0

# === Container Support (Optional) ===
# For Docker usage
docker>=6.0.0                      # Docker API client

# For Kubernetes usage
# kubernetes>=25.0.0
# openshift>=0.13.0

# === Development Tools (Optional) ===
pytest>=7.2.0                      # Testing framework
pytest-ansible>=3.0.0              # Ansible test plugin
black>=23.0.0                      # Python code formatter
flake8>=6.0.0                      # Python linter
pre-commit>=3.0.0                  # Git hook management
ipython>=8.0.0                     # Enhanced Python shell

# === Security Scanning (Optional) ===
bandit>=1.7.0                      # Python security vulnerability scanner
safety>=2.3.0                      # Dependency vulnerability checker

# === Documentation (Optional) ===
sphinx>=6.0.0                      # Documentation generator
sphinx-rtd-theme>=1.2.0            # Read the Docs theme

# === Performance Monitoring (Optional) ===
psutil>=5.9.0                      # System and process utilities
py-spy>=0.3.0                      # Python profiler

# === Version Pinning Notes ===
# - Major versions are fixed to prevent compatibility issues
# - Minor versions are flexible to allow security patches
# - For production, use: pip freeze > requirements-lock.txt

# === Installation Notes ===
# 1. Create and activate virtual environment:
#    python3 -m venv venv
#    source venv/bin/activate  # Linux/Mac
#    venv\Scripts\activate     # Windows
#
# 2. Install requirements:
#    pip install -r requirements.txt
#
# 3. Verify installation:
#    ansible --version
#    python -m pip list

================================================================================
íŒŒì¼: roles/mitum/defaults/main.yml
================================================================================
---
# Default variables for Mitum role
# These can be overridden in group_vars or host_vars

# === Environment Configuration ===
mitum_environment: "production"
mitum_network_id: "testnet"
mitum_model_type: "mitum-currency"
mitum_version: "latest"

# === Installation Configuration ===
mitum_install_method: "source"  # source, binary, docker
mitum_service_user: "mitum"
mitum_service_group: "mitum"
mitum_base_dir: "/opt/mitum"
mitum_config_dir: "{{ mitum_base_dir }}/config"
mitum_data_dir: "{{ mitum_base_dir }}/data"
mitum_logs_dir: "{{ mitum_base_dir }}/logs"

# === Network Configuration ===
mitum_api_port: 54320
mitum_node_port: 4320
mitum_metrics_port: 9090
mitum_bind_address: "0.0.0.0"

# === Resource Configuration ===
mitum_memory_limit: "4G"
mitum_cpu_limit: "2"
mitum_max_connections: 1000

# === Feature Flags ===
mitum_features:
  enable_api: true
  enable_digest: true
  enable_metrics: true
  enable_profiler: false

# === Security Configuration ===
mitum_ssh_port: 22
mitum_firewall_enabled: true
mitum_ssl_enabled: false

# === MongoDB Configuration ===
mongodb_enabled: true
mongodb_port: 27017
mongodb_replica_set: "mitum-rs"
mongodb_auth_enabled: true

# === Monitoring Configuration ===
mitum_monitoring_enabled: true
monitoring_node_exporter_port: 9100
monitoring_prometheus_port: 9090

# === Backup Configuration ===
mitum_backup_enabled: true
mitum_backup_schedule: "0 2 * * *"  # Daily at 2 AM
mitum_backup_retention_days: 7

# === Deployment Configuration ===
mitum_deployment_phase: "all"  # all, prepare, install, configure, start
mitum_validate_config: true
mitum_cleanup_enabled: false

# === Performance Configuration ===
mitum_parallel_processes: 4
mitum_connection_timeout: 30
mitum_operation_timeout: 300

# === Development/Debug Configuration ===
mitum_debug_enabled: false
mitum_log_level: "info"  # debug, info, warn, error

# === Skip Flags ===
skip_mongodb: false
skip_keygen: false
skip_monitoring: false
skip_backup: false

================================================================================
íŒŒì¼: roles/mitum/files/mitum-config.sh
================================================================================
#!/bin/bash
# Mitum configuration helper script

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default paths
MITUM_BASE_DIR="${MITUM_BASE_DIR:-/opt/mitum}"
MITUM_CONFIG_DIR="${MITUM_CONFIG_DIR:-$MITUM_BASE_DIR/config}"
MITUM_KEYS_DIR="${MITUM_KEYS_DIR:-$MITUM_BASE_DIR/keys}"
MITUM_DATA_DIR="${MITUM_DATA_DIR:-$MITUM_BASE_DIR/data}"

# Functions
log() { echo -e "${GREEN}[INFO]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
warning() { echo -e "${YELLOW}[WARN]${NC} $*"; }

usage() {
    cat << EOF
${GREEN}Mitum Configuration Helper${NC}

Usage: $0 [COMMAND] [OPTIONS]

Commands:
    validate     Validate configuration files
    show         Display current configuration
    diff         Show configuration differences
    backup       Create configuration backup
    restore      Restore configuration from backup
    generate     Generate configuration from template

Options:
    -c, --config FILE    Configuration file (default: $MITUM_CONFIG_DIR/config.yml)
    -k, --keys DIR       Keys directory (default: $MITUM_KEYS_DIR)
    -b, --backup DIR     Backup directory
    -h, --help           Show this help

Examples:
    $0 validate
    $0 show --config /path/to/config.yml
    $0 backup --backup /var/backups/mitum
    $0 generate --template consensus-node

EOF
}

# Validate configuration
validate_config() {
    local config_file="${1:-$MITUM_CONFIG_DIR/config.yml}"
    
    log "Validating configuration: $config_file"
    
    # Check if file exists
    if [[ ! -f "$config_file" ]]; then
        error "Configuration file not found: $config_file"
        return 1
    fi
    
    # Basic YAML validation
    if ! command -v yq &> /dev/null; then
        warning "yq not installed, skipping YAML validation"
    else
        if ! yq eval . "$config_file" > /dev/null 2>&1; then
            error "Invalid YAML syntax in $config_file"
            return 1
        fi
    fi
    
    # Check required fields
    local required_fields=(
        "address"
        "privatekey"
        "network-id"
        "storage"
        "database"
        "network"
        "consensus"
    )
    
    for field in "${required_fields[@]}"; do
        if ! grep -q "^${field}:" "$config_file"; then
            error "Missing required field: $field"
            return 1
        fi
    done
    
    # Validate keys
    local private_key=$(grep "^privatekey:" "$config_file" | cut -d' ' -f2)
    local public_key=$(grep "^publickey:" "$config_file" | cut -d' ' -f2)
    
    if [[ -z "$private_key" ]] || [[ -z "$public_key" ]]; then
        error "Invalid keys in configuration"
        return 1
    fi
    
    log "Configuration validation passed âœ“"
    return 0
}

# Show current configuration
show_config() {
    local config_file="${1:-$MITUM_CONFIG_DIR/config.yml}"
    
    if [[ ! -f "$config_file" ]]; then
        error "Configuration file not found: $config_file"
        return 1
    fi
    
    echo -e "${BLUE}=== Mitum Configuration ===${NC}"
    echo "File: $config_file"
    echo ""
    
    # Extract key information
    local network_id=$(grep "^network-id:" "$config_file" | cut -d' ' -f2)
    local address=$(grep "^address:" "$config_file" | cut -d' ' -f2)
    local bind=$(grep -A1 "^network:" "$config_file" | grep "bind:" | awk '{print $2}')
    local mongodb=$(grep -A2 "^database:" "$config_file" | grep "host:" | awk '{print $2}')
    
    echo "Network ID: $network_id"
    echo "Node Address: $address"
    echo "Bind Address: $bind"
    echo "MongoDB: $mongodb"
    echo ""
    
    # Show consensus nodes
    echo "Consensus Nodes:"
    sed -n '/^consensus:/,/^[^ ]/{/nodes:/,/^[^ ]/{/^ *- /p}}' "$config_file" | \
        sed 's/^ *- */  - /'
    
    echo ""
    echo -e "${BLUE}=== Full Configuration ===${NC}"
    cat "$config_file"
}

# Compare configurations
diff_config() {
    local config1="${1:-$MITUM_CONFIG_DIR/config.yml}"
    local config2="${2:-$MITUM_CONFIG_DIR/config.yml.backup}"
    
    if [[ ! -f "$config1" ]]; then
        error "First configuration file not found: $config1"
        return 1
    fi
    
    if [[ ! -f "$config2" ]]; then
        error "Second configuration file not found: $config2"
        return 1
    fi
    
    log "Comparing configurations:"
    echo "  Current: $config1"
    echo "  Compare: $config2"
    echo ""
    
    diff -u "$config2" "$config1" || true
}

# Backup configuration
backup_config() {
    local backup_dir="${1:-$MITUM_BASE_DIR/backups}"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_name="config-backup-$timestamp"
    
    mkdir -p "$backup_dir"
    
    log "Creating configuration backup: $backup_name"
    
    # Create backup archive
    tar -czf "$backup_dir/$backup_name.tar.gz" \
        -C "$MITUM_BASE_DIR" \
        config keys 2>/dev/null || true
    
    # Create backup manifest
    cat > "$backup_dir/$backup_name.manifest" << EOF
Backup: $backup_name
Date: $(date -Iseconds)
Files:
  - config/
  - keys/
Size: $(du -h "$backup_dir/$backup_name.tar.gz" | cut -f1)
EOF
    
    log "Backup created: $backup_dir/$backup_name.tar.gz"
}

# Restore configuration
restore_config() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        error "Backup file required"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        error "Backup file not found: $backup_file"
        return 1
    fi
    
    warning "This will overwrite current configuration!"
    read -p "Continue? [y/N] " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "Restore cancelled"
        return 0
    fi
    
    # Backup current config first
    backup_config "$MITUM_BASE_DIR/backups"
    
    # Extract backup
    log "Restoring from: $backup_file"
    tar -xzf "$backup_file" -C "$MITUM_BASE_DIR"
    
    log "Configuration restored successfully"
}

# Generate configuration from template
generate_config() {
    local template="${1:-consensus}"
    local output="${2:-$MITUM_CONFIG_DIR/config.yml.new}"
    
    log "Generating configuration from template: $template"
    
    case "$template" in
        consensus)
            cat > "$output" << 'EOF'
# Mitum Consensus Node Configuration
address: node0-mitum
privatekey: <PRIVATE_KEY>
publickey: <PUBLIC_KEY>
network-id: mitum

storage:
  type: leveldb
  path: /opt/mitum/data/blockdata
  options:
    cache_size: 128
    write_buffer_size: 4
    max_open_files: 10000

database:
  type: mongodb
  mongodb:
    host: 127.0.0.1
    port: 27017
    database: mitum

network:
  bind: 0.0.0.0:4320
  advertise: <NODE_IP>:4320

consensus:
  threshold: 67
  nodes:
    # Add consensus nodes here

sync:
  interval: 10s
  sources:
    # Add sync sources here
EOF
            ;;
            
        api)
            cat > "$output" << 'EOF'
# Mitum API Node Configuration
address: api-node-mitum
privatekey: <PRIVATE_KEY>
publickey: <PUBLIC_KEY>
network-id: mitum

storage:
  type: leveldb
  path: /opt/mitum/data/blockdata

database:
  type: mongodb
  mongodb:
    host: 127.0.0.1
    port: 27017
    database: mitum

network:
  bind: 0.0.0.0:4320
  advertise: <NODE_IP>:4320

api:
  bind: 0.0.0.0:54320
  cache: true

sync:
  interval: 10s
  sources:
    # Add sync sources here
EOF
            ;;
            
        *)
            error "Unknown template: $template"
            return 1
            ;;
    esac
    
    log "Configuration template generated: $output"
    echo "Edit the file and replace placeholder values before using"
}

# Main execution
main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        validate)
            validate_config "$@"
            ;;
        show)
            show_config "$@"
            ;;
        diff)
            diff_config "$@"
            ;;
        backup)
            backup_config "$@"
            ;;
        restore)
            restore_config "$@"
            ;;
        generate)
            generate_config "$@"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            error "Unknown command: $command"
            usage
            exit 1
            ;;
    esac
}

# Run main
main "$@"

================================================================================
íŒŒì¼: roles/mitum/files/mitum-keygen.js
================================================================================
#!/usr/bin/env node
/**
 * Mitum Key Generator using MitumJS SDK
 * Generates keys for Mitum nodes with support for multi-sig
 */

const fs = require('fs');
const path = require('path');

// Fix crypto issue for Node.js environments
const crypto = require('crypto');
if (!global.crypto) {
    global.crypto = crypto.webcrypto || {
        getRandomValues: (arr) => crypto.randomBytes(arr.length)
    };
}

// Import MitumJS after crypto fix
let Keypair, Address;
try {
    const mitumjs = require('@mitumjs/mitumjs');
    Keypair = mitumjs.Keypair;
    Address = mitumjs.Address;
} catch (error) {
    console.error('Error loading MitumJS:', error.message);
    console.error('Please run: npm install @mitumjs/mitumjs');
    process.exit(1);
}

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
    networkId: 'mitum',
    nodeCount: 1,
    threshold: 100,
    output: './keys',
    type: 'btc',
    seed: null
};

// Parse arguments
for (let i = 0; i < args.length; i += 2) {
    const key = args[i].replace('--', '');
    const value = args[i + 1];
    
    switch (key) {
        case 'network-id':
            options.networkId = value;
            break;
        case 'node-count':
            options.nodeCount = parseInt(value);
            break;
        case 'threshold':
            options.threshold = parseInt(value);
            break;
        case 'output':
            options.output = value;
            break;
        case 'type':
            options.type = value;
            break;
        case 'seed':
            options.seed = value;
            break;
    }
}

// Validate options
if (options.nodeCount < 1) {
    console.error('Error: node-count must be at least 1');
    process.exit(1);
}

if (options.threshold < 1 || options.threshold > 100) {
    console.error('Error: threshold must be between 1 and 100');
    process.exit(1);
}

// Create output directory
const outputDir = path.resolve(options.output);
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

// Generate keys
function generateKeys() {
    const keys = [];
    const summary = {
        network_id: options.networkId,
        generated_at: new Date().toISOString(),
        node_count: options.nodeCount,
        threshold: options.threshold,
        key_type: options.type,
        nodes: []
    };

    console.log(`Generating ${options.nodeCount} key pairs for network: ${options.networkId}`);

    try {
        for (let i = 0; i < options.nodeCount; i++) {
            // Generate keypair with error handling
            let keypair;
            try {
                const seed = options.seed ? `${options.seed}-node${i}` : null;
                keypair = seed ? 
                    Keypair.fromSeed(seed, options.type) : 
                    Keypair.random(options.type);
            } catch (error) {
                console.error(`Error generating keypair for node${i}:`, error.message);
                // Fallback to manual generation if MitumJS fails
                keypair = generateFallbackKeypair(i);
            }

            // Generate node address
            const nodeAddress = `node${i}-${options.networkId}`;
            
            // Create node info
            const nodeInfo = {
                node_id: i,
                address: nodeAddress,
                public_key: keypair.publicKey,
                private_key: keypair.privateKey,
                type: keypair.type || options.type,
                hint: keypair.hint || 'mpr'
            };

            keys.push(nodeInfo);

            // Add to summary (without private key)
            summary.nodes.push({
                node_id: i,
                address: nodeAddress,
                public_key: keypair.publicKey,
                type: keypair.type || options.type
            });

            // Create node directory
            const nodeDir = path.join(outputDir, `node${i}`);
            if (!fs.existsSync(nodeDir)) {
                fs.mkdirSync(nodeDir, { recursive: true });
            }

            // Write individual key files
            fs.writeFileSync(
                path.join(nodeDir, 'node.json'),
                JSON.stringify(nodeInfo, null, 2)
            );

            // Write separate key files for easy access
            fs.writeFileSync(
                path.join(nodeDir, 'publickey'),
                keypair.publicKey
            );

            fs.writeFileSync(
                path.join(nodeDir, 'privatekey'),
                keypair.privateKey
            );

            fs.writeFileSync(
                path.join(nodeDir, 'address'),
                nodeAddress
            );

            console.log(`âœ“ Generated keys for node${i}`);
        }

        // Generate genesis account if requested
        if (options.nodeCount > 0) {
            const genesisKeys = [];
            const keysForMultisig = keys.slice(0, Math.min(3, keys.length));
            
            for (const key of keysForMultisig) {
                genesisKeys.push({
                    key: key.public_key,
                    weight: Math.floor(100 / keysForMultisig.length)
                });
            }

            // Adjust last weight to ensure total is 100
            if (genesisKeys.length > 0) {
                const totalWeight = genesisKeys.reduce((sum, k) => sum + k.weight, 0);
                genesisKeys[genesisKeys.length - 1].weight += (100 - totalWeight);
            }

            let genesisAddress;
            try {
                genesisAddress = Address.from(genesisKeys, options.threshold, options.networkId);
            } catch (error) {
                // Fallback genesis address
                genesisAddress = `genesis-${options.networkId}-${Date.now()}`;
            }

            const genesisAccount = {
                address: genesisAddress,
                keys: genesisKeys,
                threshold: options.threshold
            };

            summary.genesis_account = genesisAccount;

            // Write genesis account info
            fs.writeFileSync(
                path.join(outputDir, 'genesis-account.json'),
                JSON.stringify(genesisAccount, null, 2)
            );
        }

        // Write summary file
        fs.writeFileSync(
            path.join(outputDir, 'keys-summary.json'),
            JSON.stringify(summary, null, 2)
        );

        // Write summary in YAML format for Ansible
        const yamlSummary = generateYAML(summary);
        fs.writeFileSync(
            path.join(outputDir, 'keys-summary.yml'),
            yamlSummary
        );

        // Output summary to stdout for Ansible to capture
        console.log('\n--- Key Generation Summary ---');
        console.log(JSON.stringify(summary));

        return summary;
    } catch (error) {
        console.error('Error during key generation:', error.message);
        throw error;
    }
}

// Fallback keypair generation if MitumJS fails
function generateFallbackKeypair(index) {
    const timestamp = Date.now();
    const random = crypto.randomBytes(32).toString('hex');
    
    return {
        privateKey: `FALLBACK${random}${index}mpr`,
        publicKey: `PUB${random.substring(0, 40)}${index}mpr`,
        type: 'btc'
    };
}

// Generate YAML format for Ansible
function generateYAML(obj) {
    let yaml = '---\n';
    yaml += `# Generated by mitum-keygen.js\n`;
    yaml += `# Network: ${obj.network_id}\n`;
    yaml += `# Generated at: ${obj.generated_at}\n\n`;
    
    yaml += `network_id: "${obj.network_id}"\n`;
    yaml += `node_count: ${obj.node_count}\n`;
    yaml += `threshold: ${obj.threshold}\n`;
    yaml += `key_type: "${obj.key_type}"\n\n`;
    
    yaml += `nodes:\n`;
    for (const node of obj.nodes) {
        yaml += `  - node_id: ${node.node_id}\n`;
        yaml += `    address: "${node.address}"\n`;
        yaml += `    public_key: "${node.public_key}"\n`;
        yaml += `    type: "${node.type}"\n`;
    }
    
    if (obj.genesis_account) {
        yaml += `\ngenesis_account:\n`;
        yaml += `  address: "${obj.genesis_account.address}"\n`;
        yaml += `  threshold: ${obj.genesis_account.threshold}\n`;
        yaml += `  keys:\n`;
        for (const key of obj.genesis_account.keys) {
            yaml += `    - key: "${key.key}"\n`;
            yaml += `      weight: ${key.weight}\n`;
        }
    }
    
    return yaml;
}

// Main execution
try {
    const result = generateKeys();
    console.log('\nâœ“ Key generation completed successfully');
    console.log(`âœ“ Keys saved to: ${outputDir}`);
    process.exit(0);
} catch (error) {
    console.error('Error generating keys:', error.message);
    console.error(error.stack);
    process.exit(1);
}

================================================================================
íŒŒì¼: roles/mitum/files/package.json
================================================================================
{
  "name": "mitum-ansible-tools",
  "version": "1.0.0",
  "description": "MitumJS tools for Mitum Ansible deployment",
  "main": "mitum-keygen.js",
  "scripts": {
    "keygen": "node mitum-keygen.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "mitum",
    "blockchain",
    "ansible",
    "deployment"
  ],
  "author": "Mitum Team",
  "license": "MIT",
  "dependencies": {
    "@mitumjs/mitumjs": "^2.1.15",
    "commander": "^11.0.0",
    "js-yaml": "^4.1.0"
  },
  "devDependencies": {
    "eslint": "^8.50.0",
    "prettier": "^3.0.3"
  },
  "engines": {
    "node": ">=14.0.0"
  }
}

================================================================================
íŒŒì¼: roles/mitum/handlers/main.yml
================================================================================
---
# Handlers for Mitum role

- name: reload systemd
  systemd:
    daemon_reload: yes
  become: yes

- name: restart mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    state: restarted
    enabled: yes
  become: yes
  when: 
    - not (ansible_check_mode | default(false))
    - mitum_service_state | default('started') == 'started'

- name: reload mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    state: reloaded
  become: yes
  when: 
    - not (ansible_check_mode | default(false))
    - mitum_service_state | default('started') == 'started'
  ignore_errors: yes

- name: restart mongod
  systemd:
    name: mongod
    state: restarted
  become: yes
  when: mitum_mongodb_enabled | default(true)

- name: reload prometheus
  systemd:
    name: prometheus
    state: reloaded
  become: yes
  when: mitum_prometheus_enabled | default(false)
  delegate_to: "{{ groups['monitoring'][0] | default(inventory_hostname) }}"
  run_once: yes

- name: restart node_exporter
  systemd:
    name: node_exporter
    state: restarted
  become: yes
  when: mitum_node_exporter_enabled | default(true)

- name: restart mongodb_exporter
  systemd:
    name: mongodb_exporter
    state: restarted
  become: yes
  when: 
    - mitum_mongodb_enabled | default(true)
    - mitum_mongodb_exporter_enabled | default(true)

- name: verify mitum service
  wait_for:
    port: "{{ mitum_node_port }}"
    host: "{{ ansible_default_ipv4.address }}"
    state: started
    timeout: 60
  when: mitum_validate_startup | default(true)

- name: check mitum health
  uri:
    url: "http://{{ ansible_default_ipv4.address }}:{{ mitum_node_port }}/v2/node"
    status_code: 200
    timeout: 10
  retries: 5
  delay: 5
  register: health_check
  until: health_check.status == 200
  when: mitum_validate_startup | default(true)

- name: reload logrotate
  command: logrotate -f /etc/logrotate.d/mitum
  become: yes
  when: mitum_log_rotate_enabled | default(true)

- name: update consensus nodes
  uri:
    url: "http://{{ ansible_default_ipv4.address }}:{{ mitum_node_port }}/v2/consensus/nodes"
    method: POST
    body_format: json
    body: "{{ mitum_consensus_nodes }}"
    status_code: [200, 201]
  when: 
    - mitum_consensus_nodes is defined
    - mitum_consensus_nodes | length > 0
  ignore_errors: yes

- name: notify monitoring system
  uri:
    url: "{{ mitum_monitoring_webhook_url }}"
    method: POST
    body_format: json
    body:
      event: "mitum_service_restarted"
      node: "{{ inventory_hostname }}"
      timestamp: "{{ ansible_date_time.iso8601 }}"
      details: "{{ mitum_restart_reason | default('Configuration change') }}"
  when: 
    - mitum_monitoring_webhook_url is defined
    - mitum_monitoring_webhook_url | length > 0
  delegate_to: localhost
  run_once: yes

- name: backup before restart
  include_tasks: backup-node.yml
  when: 
    - mitum_upgrade_backup_before | default(false)
    - mitum_restart_required | default(false)

================================================================================
íŒŒì¼: roles/mitum/tasks/backup-node.yml
================================================================================
---
# Backup tasks for individual Mitum node

- name: Set backup timestamp
  set_fact:
    backup_timestamp: "{{ ansible_date_time.epoch }}"
    backup_dir: "{{ mitum_backup_dir }}/{{ ansible_date_time.epoch }}"

- name: Create backup directory
  file:
    path: "{{ backup_dir }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0750'

- name: Create backup manifest
  copy:
    content: |
      ---
      backup_info:
        timestamp: {{ backup_timestamp }}
        date: {{ ansible_date_time.iso8601 }}
        hostname: {{ inventory_hostname }}
        node_id: {{ mitum_node_id }}
        network_id: {{ mitum_network_id }}
        mitum_version: {{ mitum_version | default('unknown') }}
        backup_type: node
    dest: "{{ backup_dir }}/manifest.yml"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"

- name: Backup configuration
  archive:
    path:
      - "{{ mitum_config_dir }}"
      - "{{ mitum_keys_dir }}"
    dest: "{{ backup_dir }}/config-backup.tar.gz"
    format: gz
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0600'

- name: Backup data directory
  when: mitum_backup_include_data | default(false)
  block:
    - name: Check data directory size
      command: du -sh {{ mitum_data_dir }}
      register: data_size
      changed_when: false

    - name: Create data backup
      archive:
        path: "{{ mitum_data_dir }}"
        dest: "{{ backup_dir }}/data-backup.tar.gz"
        format: gz
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'
      async: 1800
      poll: 30

- name: Backup MongoDB data
  when: 
    - mitum_mongodb_enabled | default(true)
    - mitum_backup_include_mongodb | default(true)
  block:
    - name: Create MongoDB backup
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongodump -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase {{ mitum_mongodb_database }} \
          --db {{ mitum_mongodb_database }} \
          --gzip \
          --archive={{ backup_dir }}/mongodb-backup.gz
        {% else %}
        mongodump --db {{ mitum_mongodb_database }} \
          --gzip \
          --archive={{ backup_dir }}/mongodb-backup.gz
        {% endif %}
      become_user: "{{ mitum_service_user }}"

- name: Create backup summary
  shell: |
    echo "Backup Summary" > {{ backup_dir }}/summary.txt
    echo "=============" >> {{ backup_dir }}/summary.txt
    echo "Timestamp: {{ ansible_date_time.iso8601 }}" >> {{ backup_dir }}/summary.txt
    echo "Node: {{ inventory_hostname }}" >> {{ backup_dir }}/summary.txt
    echo "" >> {{ backup_dir }}/summary.txt
    echo "Files:" >> {{ backup_dir }}/summary.txt
    ls -lh {{ backup_dir }}/*.gz >> {{ backup_dir }}/summary.txt
    echo "" >> {{ backup_dir }}/summary.txt
    echo "Total size:" >> {{ backup_dir }}/summary.txt
    du -sh {{ backup_dir }} >> {{ backup_dir }}/summary.txt
  changed_when: false

- name: Set backup complete flag
  file:
    path: "{{ backup_dir }}/.complete"
    state: touch
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"

- name: Return backup information
  set_stats:
    data:
      backup_results:
        - node: "{{ inventory_hostname }}"
          timestamp: "{{ backup_timestamp }}"
          location: "{{ backup_dir }}"
          success: true
    aggregate: yes

================================================================================
íŒŒì¼: roles/mitum/tasks/common-package-install.yml
================================================================================
---
# Common package installation tasks for different OS families
# This reduces duplication across multiple playbooks

- name: Install common packages based on OS
  block:
    - name: Install packages on Debian/Ubuntu
      apt:
        name: "{{ packages }}"
        state: present
        update_cache: yes
        cache_valid_time: 3600
      when: ansible_os_family == "Debian"
      
    - name: Install packages on RHEL/CentOS
      yum:
        name: "{{ packages }}"
        state: present
        update_cache: yes
      when: ansible_os_family == "RedHat"
      
    - name: Install packages on macOS
      homebrew:
        name: "{{ packages }}"
        state: present
      when: ansible_os_family == "Darwin"
      
    - name: Install Python packages via pip
      pip:
        name: "{{ pip_packages | default([]) }}"
        state: present
      when: pip_packages is defined and pip_packages | length > 0
  
  rescue:
    - name: Package installation failed
      fail:
        msg: |
          Failed to install packages: {{ packages }}
          OS Family: {{ ansible_os_family }}
          Error: {{ ansible_failed_result.msg | default('Unknown error') }} 

================================================================================
íŒŒì¼: roles/mitum/tasks/common-validation.yml
================================================================================
---
# Common validation tasks that can be included in multiple playbooks
# This file helps reduce code duplication across playbooks

- name: Validate deployment environment
  assert:
    that:
      - mitum_environment is defined
      - mitum_environment in ['development', 'staging', 'production']
    fail_msg: "mitum_environment must be one of: development, staging, production"
  tags: [validation]

- name: Validate required core variables
  assert:
    that:
      - mitum_network_id is defined
      - mitum_model_type is defined
      - mitum_service_user is defined
      - mitum_base_dir is defined
      - groups['mitum_nodes'] is defined
      - groups['mitum_nodes'] | length > 0
    fail_msg: "Required variables are not defined. Check group_vars/all.yml"
  tags: [validation]

- name: Display deployment information
  debug:
    msg: |
      ========================================
      Mitum Deployment Configuration
      ========================================
      Network ID: {{ mitum_network_id }}
      Model Type: {{ mitum_model_type }}
      Environment: {{ mitum_environment }}
      Total Nodes: {{ groups['mitum_nodes'] | length }}
      Base Directory: {{ mitum_base_dir }}
      Service User: {{ mitum_service_user }}
      ========================================
  run_once: true
  tags: [validation] 

================================================================================
íŒŒì¼: roles/mitum/tasks/configure-nodes.yml
================================================================================
---
# Configure Mitum nodes

- name: Ensure configuration directory exists
  file:
    path: "{{ mitum_config_dir }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'

- name: Read node keys
  slurp:
    src: "{{ mitum_keys_dir }}/node.json"
  register: node_keys_raw
  when: mitum_node_privatekey is not defined

- name: Parse node keys
  set_fact:
    node_keys: "{{ node_keys_raw.content | b64decode | from_json }}"
  when: node_keys_raw is defined and node_keys_raw.content is defined

- name: Set node key facts
  set_fact:
    mitum_node_address: "{{ node_keys.address | default(mitum_node_address) }}"
    mitum_node_publickey: "{{ node_keys.public_key | default(mitum_node_publickey) }}"
    mitum_node_privatekey: "{{ node_keys.private_key | default(mitum_node_privatekey) }}"
  when: node_keys is defined

- name: Validate node keys
  assert:
    that:
      - mitum_node_address | length > 0
      - mitum_node_publickey | length > 0
      - mitum_node_privatekey | length > 0
    fail_msg: "Node keys are not properly configured"

- name: Generate Mitum configuration
  template:
    src: config.yml.j2
    dest: "{{ mitum_config_dir }}/config.yml"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0640'
    backup: yes
  notify: restart mitum service

- name: Validate configuration file
  command: |
    {{ mitum_install_dir }}/{{ mitum_model_type }} validate-config \
      {{ mitum_config_dir }}/config.yml
  register: config_validation
  changed_when: false
  failed_when: 
    - config_validation.rc != 0
    - "'not implemented' not in config_validation.stderr"

- name: Configure logging
  when: mitum_log_rotate_enabled
  block:
    - name: Install logrotate
      package:
        name: logrotate
        state: present

    - name: Configure log rotation
      template:
        src: logrotate.j2
        dest: /etc/logrotate.d/mitum
        owner: root
        group: root
        mode: '0644'

- name: Setup TLS certificates
  when: mitum_security_ssl_enabled
  block:
    - name: Ensure certificate directory exists
      file:
        path: "{{ mitum_config_dir }}/certs"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0700'

    - name: Copy TLS certificate
      copy:
        src: "{{ mitum_security_ssl_cert }}"
        dest: "{{ mitum_config_dir }}/certs/cert.pem"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'

    - name: Copy TLS key
      copy:
        src: "{{ mitum_security_ssl_key }}"
        dest: "{{ mitum_config_dir }}/certs/key.pem"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0600'

- name: Configure firewall rules
  when: mitum_security_firewall_enabled and ansible_os_family in ["Debian", "RedHat"]
  block:
    - name: Install firewall package
      package:
        name: "{{ 'ufw' if ansible_os_family == 'Debian' else 'firewalld' }}"
        state: present

    - name: Configure UFW rules (Debian/Ubuntu)
      when: ansible_os_family == "Debian"
      ufw:
        rule: allow
        port: "{{ item.port }}"
        proto: "{{ item.proto | default('tcp') }}"
        src: "{{ item.src | default('any') }}"
        comment: "{{ item.comment | default('Mitum') }}"
      loop: "{{ mitum_firewall_rules }}"

    - name: Configure firewalld rules (RedHat/CentOS)
      when: ansible_os_family == "RedHat"
      firewalld:
        port: "{{ item.port }}/{{ item.proto | default('tcp') }}"
        permanent: yes
        state: enabled
        immediate: yes
      loop: "{{ mitum_firewall_rules }}"

- name: Create systemd service file
  template:
    src: mitum.service.j2
    dest: /etc/systemd/system/{{ mitum_service_name }}.service
    owner: root
    group: root
    mode: '0644'
  notify:
    - reload systemd
    - restart mitum service

- name: Set service environment file
  template:
    src: mitum.env.j2
    dest: "{{ mitum_config_dir }}/mitum.env"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0640'
  when: mitum_service_environment | length > 0

- name: Create helper scripts
  template:
    src: "{{ item }}.j2"
    dest: "{{ mitum_install_dir }}/{{ item }}"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'
  loop:
    - mitum-health-check.sh
    - mitum-backup.sh
    - mitum-logs.sh

- name: Setup configuration backup
  cron:
    name: "Mitum configuration backup"
    minute: "0"
    hour: "*/6"
    job: |
      tar -czf {{ mitum_backup_dir }}/config-backup-$(date +\%Y\%m\%d-\%H\%M\%S).tar.gz \
        -C {{ mitum_base_dir }} config keys
    user: "{{ mitum_service_user }}"
    state: present
  when: mitum_backup_enabled

================================================================================
íŒŒì¼: roles/mitum/tasks/generate-configs.yml
================================================================================
---
# Generate Mitum configuration files based on generated keys

- name: Generate Mitum configurations
  hosts: mitum_nodes
  gather_facts: yes
  become: yes
  vars:
    keys_base_dir: "{{ playbook_dir }}/../keys/{{ mitum_network_id }}"
    
  tasks:
    - name: Load generated keys summary
      include_vars:
        file: "{{ keys_base_dir }}/keys-summary.yml"
        name: keys_summary
      run_once: true
      delegate_to: localhost
      
    - name: Load node-specific keys
      include_vars:
        file: "{{ keys_base_dir }}/node{{ mitum_node_id }}/node.json"
        name: node_keys
      delegate_to: localhost
      
    - name: Create configuration directory
      file:
        path: "{{ mitum_config_dir }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        
    - name: Generate node configuration
      template:
        src: node-config.yml.j2
        dest: "{{ mitum_config_dir }}/config.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        backup: yes
      vars:
        node_id: "{{ mitum_node_id }}"
        all_node_keys: "{{ keys_summary.nodes }}"
        
    - name: Generate genesis configuration (on first node only)
      template:
        src: genesis.yml.j2
        dest: "{{ mitum_config_dir }}/genesis.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
      vars:
        genesis_node_key: "{{ keys_summary.nodes[0] }}"
        all_node_keys: "{{ keys_summary.nodes }}"
      when: mitum_node_id | int == 0
      
    - name: Create storage directory
      file:
        path: "{{ mitum_data_dir }}/node-{{ mitum_node_id }}"
        state: directory
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        
    - name: Save node information
      copy:
        content: |
          # Node Information
          NODE_ID={{ mitum_node_id }}
          NODE_ADDRESS={{ mitum_network_id }}{{ mitum_node_id }}sas
          NODE_PORT={{ mitum_node_port }}
          API_ENABLED={{ mitum_api_enabled | default(false) }}
          {% if mitum_api_enabled | default(false) %}
          API_PORT={{ mitum_api_port | default(54320) }}
          {% endif %}
        dest: "{{ mitum_config_dir }}/node.info"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        
- name: Validate generated configurations
  hosts: mitum_nodes
  gather_facts: no
  become: yes
  tasks:
    - name: Check configuration files exist
      stat:
        path: "{{ item }}"
      register: config_files
      loop:
        - "{{ mitum_config_dir }}/config.yml"
        - "{{ mitum_config_dir }}/node.info"
        
    - name: Check genesis file on node0
      stat:
        path: "{{ mitum_config_dir }}/genesis.yml"
      register: genesis_file
      when: mitum_node_id | int == 0
      
    - name: Display configuration summary
      debug:
        msg: |
          Configuration Summary for {{ inventory_hostname }}:
          - Node ID: {{ mitum_node_id }}
          - Config directory: {{ mitum_config_dir }}
          - Data directory: {{ mitum_data_dir }}
          - Network ID: {{ mitum_network_id }}
          - Node Port: {{ mitum_node_port }}
          - API Enabled: {{ mitum_api_enabled | default(false) }}
          {% if mitum_node_id | int == 0 %}
          - Genesis: Available
          {% endif %}

================================================================================
íŒŒì¼: roles/mitum/tasks/install-mitumjs.yml
================================================================================
---
# Install MitumJS SDK for key generation

- name: Create MitumJS installation directory
  file:
    path: "{{ mitum_install_dir }}/mitumjs"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'

- name: Copy package.json for MitumJS
  copy:
    content: |
      {
        "name": "mitum-keygen-tool",
        "version": "1.0.0",
        "description": "Mitum key generation tool using MitumJS SDK",
        "type": "module",
        "dependencies": {
          "@mitumjs/mitumjs": "{{ mitum_mitumjs_version | default('^2.1.15') }}"
        }
      }
    dest: "{{ mitum_install_dir }}/mitumjs/package.json"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0644'

- name: Install MitumJS SDK
  become: yes
  become_user: "{{ mitum_service_user }}"
  npm:
    path: "{{ mitum_install_dir }}/mitumjs"
    production: yes
  environment:
    NODE_ENV: production
    NPM_CONFIG_PREFIX: "{{ mitum_install_dir }}/mitumjs"
  register: mitumjs_install

- name: Copy key generation scripts
  copy:
    src: "{{ item }}"
    dest: "{{ mitum_install_dir }}/mitumjs/"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'
  loop:
    - mitum-config.sh
    - mitum-keygen.js

- name: Make scripts executable
  file:
    path: "{{ mitum_install_dir }}/mitumjs/{{ item }}"
    mode: '0755'
  loop:
    - mitum-config.sh
    - mitum-keygen.js

- name: Test MitumJS installation
  become: yes
  become_user: "{{ mitum_service_user }}"
  command: |
    node -e "import('@mitumjs/mitumjs').then(m => console.log('MitumJS SDK v' + m.default.VERSION + ' installed successfully')).catch(e => process.exit(1))"
  args:
    chdir: "{{ mitum_install_dir }}/mitumjs"
  register: mitumjs_test
  changed_when: false

- name: Display MitumJS installation status
  debug:
    msg: "{{ mitumjs_test.stdout }}"

- name: Create symlink for mitum-config.sh
  file:
    src: "{{ mitum_install_dir }}/mitumjs/mitum-config.sh"
    dest: /usr/local/bin/mitum-config
    state: link
  when: mitum_create_symlinks | default(true)

================================================================================
íŒŒì¼: roles/mitum/tasks/install-nodejs.yml
================================================================================
---
# Install Node.js for MitumJS SDK

- name: Check if Node.js is already installed
  command: node --version
  register: node_installed
  failed_when: false
  changed_when: false

- name: Get installed Node.js version
  set_fact:
    installed_node_version: "{{ node_installed.stdout | regex_search('v([0-9]+)', '\\1') | first | default('0') }}"
  when: node_installed.rc == 0

- name: Determine if Node.js installation is needed
  set_fact:
    need_nodejs_install: >-
      {{ node_installed.rc != 0 or 
         (installed_node_version | int < mitum_nodejs_min_version | default(14) | int) }}

- name: Install Node.js
  when: need_nodejs_install
  block:
    - name: Install Node.js (Debian/Ubuntu)
      when: ansible_os_family == "Debian"
      block:
        - name: Install Node.js prerequisites
          apt:
            name:
              - ca-certificates
              - curl
              - gnupg
            state: present
            update_cache: yes

        - name: Add NodeSource GPG key
          apt_key:
            url: https://deb.nodesource.com/gpgkey/nodesource.gpg.key
            state: present

        - name: Add NodeSource repository
          apt_repository:
            repo: "deb https://deb.nodesource.com/node_{{ mitum_nodejs_version | default('18') }}.x {{ ansible_distribution_release }} main"
            state: present
            update_cache: yes

        - name: Install Node.js and npm
          apt:
            name:
              - nodejs
            state: present

    - name: Install Node.js (RedHat/CentOS)
      when: ansible_os_family == "RedHat"
      block:
        - name: Install Node.js repository
          shell: |
            curl -fsSL https://rpm.nodesource.com/setup_{{ mitum_nodejs_version | default('18') }}.x | bash -
          args:
            creates: /etc/yum.repos.d/nodesource-*.repo

        - name: Install Node.js and npm
          yum:
            name:
              - nodejs
            state: present

    - name: Install Node.js (Generic - using snap)
      when: ansible_os_family not in ["Debian", "RedHat"]
      block:
        - name: Install snapd
          package:
            name: snapd
            state: present

        - name: Install Node.js via snap
          snap:
            name: node
            classic: yes
            channel: "{{ mitum_nodejs_version | default('18') }}/stable"

- name: Verify Node.js installation
  command: node --version
  register: node_version_check
  changed_when: false

- name: Verify npm installation
  command: npm --version
  register: npm_version_check
  changed_when: false

- name: Display Node.js versions
  debug:
    msg: |
      Node.js version: {{ node_version_check.stdout }}
      npm version: {{ npm_version_check.stdout }}

- name: Set npm registry (if configured)
  command: npm config set registry {{ mitum_npm_registry }}
  when: mitum_npm_registry is defined

- name: Create npm global directory for system-wide packages
  file:
    path: /usr/local/lib/node_modules
    state: directory
    mode: '0755'

================================================================================
íŒŒì¼: roles/mitum/tasks/install.yml
================================================================================
---
# Install Mitum based on selected method

- name: Check current installation
  stat:
    path: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
  register: mitum_binary_check

- name: Get current version
  command: "{{ mitum_install_dir }}/{{ mitum_model_type }} version"
  register: current_version
  changed_when: false
  failed_when: false
  when: mitum_binary_check.stat.exists

- name: Display installation info
  debug:
    msg: |
      Installation method: {{ mitum_install_method }}
      Target version: {{ mitum_version }}
      Current version: {{ current_version.stdout | default('Not installed') }}
      Force install: {{ mitum_force_install }}

- name: Install from source
  when: mitum_install_method == "source"
  block:
    - name: Install build dependencies
      package:
        name:
          - git
          - make
          - gcc
          - g++
          - wget
          - tar
        state: present

    - name: Install Go
      when: ansible_os_family in ["Debian", "RedHat"]
      block:
        - name: Check Go version
          command: go version
          register: go_version_check
          changed_when: false
          failed_when: false

        - name: Download and install Go
          when: go_version_check.rc != 0 or mitum_go_version not in go_version_check.stdout
          unarchive:
            src: "https://go.dev/dl/go{{ mitum_go_version }}.linux-amd64.tar.gz"
            dest: /usr/local
            remote_src: yes
            owner: root
            group: root
            mode: '0755'

        - name: Setup Go environment
          lineinfile:
            path: /etc/profile.d/go.sh
            line: "{{ item }}"
            create: yes
            mode: '0644'
          loop:
            - 'export PATH=$PATH:/usr/local/go/bin'
            - 'export GOPATH=/opt/go'
            - 'export GO111MODULE=on'

    - name: Create build directory
      file:
        path: "{{ mitum_temp_dir }}"
        state: directory
        mode: '0755'

    - name: Clone Mitum repository
      git:
        repo: "{{ mitum_source_repo }}"
        dest: "{{ mitum_temp_dir }}/mitum"
        version: "{{ mitum_source_branch }}"
        force: yes

    - name: Build Mitum
      shell: |
        source /etc/profile.d/go.sh
        cd {{ mitum_temp_dir }}/mitum
        make build-linux MODEL={{ mitum_model_type }}
      args:
        executable: /bin/bash
        creates: "{{ mitum_temp_dir }}/mitum/bin/{{ mitum_model_type }}"
      environment:
        GOPATH: /opt/go
        PATH: "{{ ansible_env.PATH }}:/usr/local/go/bin"

    - name: Install Mitum binary
      copy:
        src: "{{ mitum_temp_dir }}/mitum/bin/{{ mitum_model_type }}"
        dest: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        remote_src: yes
      notify: restart mitum service

- name: Install from binary
  when: mitum_install_method == "binary"
  block:
    - name: Create temp directory
      file:
        path: "{{ mitum_temp_dir }}"
        state: directory
        mode: '0755'

    - name: Download Mitum binary
      get_url:
        url: "{{ mitum_binary_url }}"
        dest: "{{ mitum_temp_dir }}/mitum.tar.gz"
        checksum: "{{ mitum_binary_checksum | default(omit) }}"
        mode: '0644'

    - name: Extract Mitum binary
      unarchive:
        src: "{{ mitum_temp_dir }}/mitum.tar.gz"
        dest: "{{ mitum_temp_dir }}"
        remote_src: yes
        creates: "{{ mitum_temp_dir }}/{{ mitum_model_type }}"

    - name: Install Mitum binary
      copy:
        src: "{{ mitum_temp_dir }}/{{ mitum_model_type }}"
        dest: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'
        remote_src: yes
      notify: restart mitum service

- name: Install from Docker
  when: mitum_install_method == "docker"
  block:
    - name: Install Docker
      include_tasks: install-docker.yml

    - name: Pull Mitum Docker image
      docker_image:
        name: "{{ mitum_docker_image }}:{{ mitum_docker_tag }}"
        source: pull
        force_source: "{{ mitum_docker_pull_always }}"

    - name: Create wrapper script for Docker
      template:
        src: mitum-docker-wrapper.sh.j2
        dest: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0755'

- name: Verify installation
  command: "{{ mitum_install_dir }}/{{ mitum_model_type }} version"
  register: verify_install
  changed_when: false
  failed_when: verify_install.rc != 0

- name: Display installed version
  debug:
    msg: "Mitum installed successfully: {{ verify_install.stdout }}"

- name: Cleanup temp directory
  file:
    path: "{{ mitum_temp_dir }}"
    state: absent
  when: mitum_temp_dir is defined

================================================================================
íŒŒì¼: roles/mitum/tasks/keygen-centralized.yml
================================================================================
---
# Centralized key generation using MitumJS

- name: Install Node.js and dependencies on controller
  block:
    - name: Check if Node.js is installed
      command: node --version
      register: node_check
      failed_when: false
      changed_when: false

    - name: Install Node.js if needed
      package:
        name: nodejs
        state: present
      when: node_check.rc != 0
      become: yes

    - name: Check if npm is installed
      command: npm --version
      register: npm_check
      failed_when: false
      changed_when: false

    - name: Install npm if needed
      package:
        name: npm
        state: present
      when: npm_check.rc != 0
      become: yes

- name: Prepare key generation environment
  block:
    - name: Create temporary directory for key generation
      tempfile:
        state: directory
        prefix: mitum_keygen_
      register: keygen_temp_dir

    - name: Copy key generation files
      copy:
        src: "{{ item }}"
        dest: "{{ keygen_temp_dir.path }}/"
        mode: '0755'
      loop:
        - mitum-keygen.js
        - package.json

    - name: Install MitumJS dependencies
      npm:
        path: "{{ keygen_temp_dir.path }}"
        production: yes
      environment:
        NODE_ENV: production

- name: Generate keys for all nodes
  block:
    - name: Get total node count
      set_fact:
        total_nodes: "{{ groups['mitum_nodes'] | length }}"

    - name: Run MitumJS key generation script
      command: |
        node mitum-keygen.js {{ total_nodes }} ./keys
      args:
        chdir: "{{ keygen_temp_dir.path }}"
      environment:
        NODE_ENV: production
      register: keygen_result

    - name: Display key generation output
      debug:
        var: keygen_result.stdout_lines
      when: mitum_debug | default(false)

    - name: Load generated keys
      set_fact:
        all_node_keys: "{{ lookup('file', keygen_temp_dir.path + '/keys/node-keys.json') | from_json }}"

    - name: Verify key count
      assert:
        that:
          - all_node_keys | length == total_nodes | int
        fail_msg: "Generated keys ({{ all_node_keys | length }}) don't match node count ({{ total_nodes }})"

    - name: Create key mapping for each node
      set_fact:
        node_key_mapping: >-
          {{
            node_key_mapping | default({}) | combine({
              item.0: {
                'node_id': idx,
                'address': 'node' + idx|string + '-' + mitum_network_id,
                'privatekey': item.1.privatekey,
                'publickey': item.1.publickey,
                'network_address': mitum_network_id + idx|string + 'sas',
                'mitum_address': item.1.address
              }
            })
          }}
      loop: "{{ groups['mitum_nodes'] | zip(all_node_keys) | list }}"
      loop_control:
        index_var: idx

    - name: Save key mapping for distribution
      copy:
        content: "{{ node_key_mapping | to_nice_json }}"
        dest: "{{ keygen_temp_dir.path }}/key-mapping.json"

- name: Generate configurations
  block:
    - name: Create configurations directory
      file:
        path: "{{ keygen_temp_dir.path }}/configs"
        state: directory

    - name: Generate node configurations
      template:
        src: "node-config.yml.j2"
        dest: "{{ keygen_temp_dir.path }}/configs/n{{ item }}.yml"
      loop: "{{ range(0, total_nodes | int) | list }}"
      vars:
        node_id: "{{ item }}"
        node_keys: "{{ all_node_keys[item] }}"

    - name: Generate genesis configuration
      template:
        src: "genesis.yml.j2"
        dest: "{{ keygen_temp_dir.path }}/configs/genesis.yml"
      vars:
        genesis_node_key: "{{ all_node_keys[0] }}"

    - name: Create configuration archive
      archive:
        path:
          - "{{ keygen_temp_dir.path }}/keys"
          - "{{ keygen_temp_dir.path }}/configs"
          - "{{ keygen_temp_dir.path }}/key-mapping.json"
        dest: "{{ keygen_temp_dir.path }}/mitum-configs.tar.gz"
        format: gz

    - name: Fetch configuration archive
      fetch:
        src: "{{ keygen_temp_dir.path }}/mitum-configs.tar.gz"
        dest: "{{ playbook_dir }}/generated/"
        flat: yes

- name: Store keys in memory for distribution
  set_fact:
    mitum_generated_keys: "{{ node_key_mapping }}"
    mitum_keygen_temp_dir: "{{ keygen_temp_dir.path }}"
  delegate_facts: true

- name: Generate AWX artifact data
  set_stats:
    data:
      generated_keys_summary:
        total_nodes: "{{ total_nodes }}"
        network_id: "{{ mitum_network_id }}"
        timestamp: "{{ ansible_date_time.iso8601 }}"
        nodes: "{{ node_key_mapping.keys() | list }}"
    aggregate: no
  when: awx_job_id is defined

================================================================================
íŒŒì¼: roles/mitum/tasks/keygen-distribute.yml
================================================================================
---
# Distribute centrally generated keys to each node

- name: Get node-specific keys
  set_fact:
    my_node_keys: "{{ hostvars['localhost']['mitum_generated_keys'][inventory_hostname] }}"
  when: hostvars['localhost']['mitum_generated_keys'] is defined

- name: Verify key assignment
  assert:
    that:
      - my_node_keys is defined
      - my_node_keys.privatekey is defined
      - my_node_keys.publickey is defined
      - my_node_keys.address is defined
    fail_msg: "No keys found for {{ inventory_hostname }}"
    success_msg: "Keys found for {{ inventory_hostname }}"

- name: Create keys directory on node
  file:
    path: "{{ mitum_keys_dir }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0700'

- name: Save node keys
  copy:
    content: |
      {
        "node_id": {{ my_node_keys.node_id }},
        "address": "{{ my_node_keys.address }}",
        "privatekey": "{{ my_node_keys.privatekey }}",
        "publickey": "{{ my_node_keys.publickey }}",
        "network_address": "{{ my_node_keys.network_address }}"
      }
    dest: "{{ mitum_keys_dir }}/node-{{ my_node_keys.node_id }}.json"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0600'
    backup: yes

- name: Set node-specific facts
  set_fact:
    mitum_node_id: "{{ my_node_keys.node_id }}"
    mitum_node_address: "{{ my_node_keys.address }}"
    mitum_node_privatekey: "{{ my_node_keys.privatekey }}"
    mitum_node_publickey: "{{ my_node_keys.publickey }}"
    mitum_node_network_address: "{{ my_node_keys.network_address }}"

- name: Extract and save configurations
  block:
    - name: Create temporary directory
      tempfile:
        state: directory
      register: extract_temp_dir

    - name: Copy configuration archive
      copy:
        src: "{{ hostvars['localhost']['mitum_keygen_temp_dir'] }}/mitum-configs.tar.gz"
        dest: "{{ extract_temp_dir.path }}/mitum-configs.tar.gz"

    - name: Extract configurations
      unarchive:
        src: "{{ extract_temp_dir.path }}/mitum-configs.tar.gz"
        dest: "{{ extract_temp_dir.path }}"
        remote_src: yes

    - name: Copy node-specific configuration
      copy:
        src: "{{ extract_temp_dir.path }}/configs/{{ 'n' + mitum_node_id|string + '.yml' if groups['mitum_nodes'] | length > 1 else 'standalone.yml' }}"
        dest: "{{ mitum_config_dir }}/node.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        remote_src: yes

    - name: Copy genesis configuration
      copy:
        src: "{{ extract_temp_dir.path }}/configs/genesis.yml"
        dest: "{{ mitum_config_dir }}/genesis.yml"
        owner: "{{ mitum_service_user }}"
        group: "{{ mitum_service_group }}"
        mode: '0644'
        remote_src: yes
      when: mitum_node_id == 0

    - name: Clean up temporary directory
      file:
        path: "{{ extract_temp_dir.path }}"
        state: absent

- name: Create all nodes reference file
  copy:
    content: "{{ hostvars['localhost']['mitum_generated_keys'] | to_nice_json }}"
    dest: "{{ mitum_config_dir }}/all-nodes.json"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0644'

- name: Display node configuration summary
  debug:
    msg: |
      Node Configuration Summary:
      - Hostname: {{ inventory_hostname }}
      - Node ID: {{ mitum_node_id }}
      - Network Address: {{ mitum_node_network_address }}
      - Public Key: {{ mitum_node_publickey }}
      - Port: {{ mitum_node_port }}
      - API Enabled: {{ mitum_api_enabled | default(false) }}

================================================================================
íŒŒì¼: roles/mitum/tasks/keygen.yml
================================================================================
---
# Key generation main tasks - supports multiple modes

- name: Determine key generation strategy
  set_fact:
    keygen_strategy: "{{ mitum_keygen_strategy | default('centralized') }}"
    # Options: centralized, distributed, external
  tags:
    - keygen

- name: Display key generation strategy
  debug:
    msg: "Using {{ keygen_strategy }} key generation strategy"
  tags:
    - keygen

# Centralized key generation (recommended for AWX)
- name: Centralized key generation
  when: keygen_strategy == 'centralized'
  block:
    - name: Generate all keys on controller
      include_tasks: keygen-centralized.yml
      run_once: true
      delegate_to: localhost
      tags:
        - keygen
        - keygen-centralized

    - name: Distribute keys to nodes
      include_tasks: keygen-distribute.yml
      tags:
        - keygen
        - keygen-distribute

# Distributed key generation (each node generates its own)
- name: Distributed key generation
  when: keygen_strategy == 'distributed'
  include_tasks: keygen-distributed.yml
  tags:
    - keygen
    - keygen-distributed

# External key generation (keys provided via variables)
- name: External key provisioning
  when: keygen_strategy == 'external'
  include_tasks: keygen-external.yml
  tags:
    - keygen
    - keygen-external

# Verify keys are available
- name: Verify key availability
  block:
    - name: Check key file exists
      stat:
        path: "{{ mitum_keys_dir }}/node-{{ mitum_node_id }}.json"
      register: key_file
      
    - name: Load node keys
      set_fact:
        node_keys: "{{ lookup('file', mitum_keys_dir + '/node-' + mitum_node_id|string + '.json') | from_json }}"
      when: key_file.stat.exists
      
    - name: Set key facts
      set_fact:
        mitum_node_address: "{{ node_keys.address }}"
        mitum_node_privatekey: "{{ node_keys.privatekey }}"
        mitum_node_publickey: "{{ node_keys.publickey }}"
        mitum_node_network_address: "{{ node_keys.network_address }}"
        mitum_node_mitum_address: "{{ node_keys.mitum_address | default('') }}"
      when: node_keys is defined
      
    - name: Validate keys
      assert:
        that:
          - mitum_node_address is defined
          - mitum_node_privatekey is defined
          - mitum_node_publickey is defined
          - mitum_node_network_address is defined
        fail_msg: "Node keys are not properly configured"
        success_msg: "Node keys validated successfully"
  tags:
    - keygen
    - keygen-verify

# Store keys in AWX for future use
- name: Update AWX with node information
  set_stats:
    data:
      mitum_nodes:
        "{{ inventory_hostname }}":
          node_id: "{{ mitum_node_id }}"
          address: "{{ mitum_node_address }}"
          publickey: "{{ mitum_node_publickey }}"
          network_address: "{{ mitum_node_network_address }}"
          mitum_address: "{{ mitum_node_mitum_address | default('') }}"
          port: "{{ mitum_node_port }}"
          api_enabled: "{{ mitum_api_enabled | default(false) }}"
    aggregate: yes
  when: awx_job_id is defined
  tags:
    - keygen
    - awx-update

================================================================================
íŒŒì¼: roles/mitum/tasks/main.yml
================================================================================
---
# Mitum Role Main Tasks
# Version: 4.0.0 - Modular task organization
#
# This file is the main entry point for the Mitum role.
# You can run specific tasks using tags.
#
# Usage examples:
# - Full execution: ansible-playbook site.yml
# - Install only: ansible-playbook site.yml --tags install
# - Configure only: ansible-playbook site.yml --tags configure

# === Variable Validation ===
- name: Validate required variables
  assert:
    that:
      - mitum_network_id is defined
      - mitum_model_type is defined
      - mitum_service_user is defined
      - mitum_base_dir is defined
    fail_msg: "Required variables are not defined. Check group_vars/all.yml"
  tags: [always]

# === Load OS-specific Variables ===
- name: Include OS-specific variables
  include_vars: "{{ item }}"
  with_first_found:
    - files:
        - "{{ ansible_distribution }}-{{ ansible_distribution_major_version }}.yml"
        - "{{ ansible_distribution }}.yml"
        - "{{ ansible_os_family }}.yml"
        - "default.yml"
      paths:
        - vars
  tags: [always]

# === Execute Tasks by Phase ===

# 1. System Preparation
- name: System preparation tasks
  include_tasks: system-prepare.yml
  when: mitum_deployment_phase | default('all') in ['all', 'prepare']
  tags: [prepare, system]

# 2. MongoDB Setup
- name: MongoDB setup tasks
  include_tasks: mongodb.yml
  when: 
    - mitum_deployment_phase | default('all') in ['all', 'mongodb']
    - not skip_mongodb | default(false)
  tags: [mongodb, database]

# 3. Mitum Installation
- name: Install Mitum
  include_tasks: install.yml
  when: mitum_deployment_phase | default('all') in ['all', 'install']
  tags: [install]

# 4. Key Generation
- name: Key generation tasks
  include_tasks: keygen.yml
  when: 
    - mitum_deployment_phase | default('all') in ['all', 'keygen']
    - not skip_keygen | default(false)
  tags: [keygen, keys]

# 5. Node Configuration
- name: Configure Mitum nodes
  include_tasks: configure-nodes.yml
  when: mitum_deployment_phase | default('all') in ['all', 'configure']
  tags: [configure]

# 6. Service Setup
- name: Setup Mitum service
  include_tasks: service.yml
  when: mitum_deployment_phase | default('all') in ['all', 'service']
  tags: [service]

# 7. Monitoring Setup
- name: Setup monitoring
  include_tasks: monitoring-prometheus.yml
  when: 
    - mitum_deployment_phase | default('all') in ['all', 'monitoring']
    - mitum_monitoring.enabled | default(false)
  tags: [monitoring]

# 8. Backup Setup
- name: Setup backup
  include_tasks: backup-setup.yml
  when: 
    - mitum_deployment_phase | default('all') in ['all', 'backup']
    - mitum_backup.enabled | default(false)
  tags: [backup]

# === Verify Deployment ===
- name: Verify deployment
  include_tasks: verify.yml
  when: mitum_deployment_phase | default('all') in ['all', 'verify']
  tags: [verify, check]

# === Flush Handlers ===
- name: Flush handlers
  meta: flush_handlers

================================================================================
íŒŒì¼: roles/mitum/tasks/mongodb.yml
================================================================================
---
# MongoDB installation and configuration for Mitum

- name: MongoDB Setup
  block:
    - name: Check if MongoDB is already installed
      stat:
        path: /usr/bin/mongod
      register: mongodb_installed
      tags:
        - mongodb
        - mongodb-check

    - name: Add MongoDB GPG key
      apt_key:
        url: https://www.mongodb.org/static/pgp/server-7.0.asc
        state: present
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Add MongoDB repository
      apt_repository:
        repo: "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu {{ ansible_distribution_release }}/mongodb-org/7.0 multiverse"
        state: present
        update_cache: yes
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Install MongoDB packages
      apt:
        name:
          - mongodb-org
          - mongodb-org-server
          - mongodb-org-shell
          - mongodb-org-mongos
          - mongodb-org-tools
        state: present
      when: 
        - not mongodb_installed.stat.exists
        - mitum_mongodb_install_method == 'native'
      tags:
        - mongodb
        - mongodb-install

    - name: Create MongoDB directories
      file:
        path: "{{ item }}"
        state: directory
        owner: mongodb
        group: mongodb
        mode: '0755'
      loop:
        - /data/db
        - /data/configdb
        - /var/log/mongodb
        - /var/run/mongodb
      tags:
        - mongodb
        - mongodb-dirs

    - name: Generate MongoDB keyfile for replica set
      shell: |
        openssl rand -base64 756 > {{ mitum_mongodb_keyfile }}
        chmod 400 {{ mitum_mongodb_keyfile }}
        chown mongodb:mongodb {{ mitum_mongodb_keyfile }}
      args:
        creates: "{{ mitum_mongodb_keyfile }}"
      when: mitum_mongodb_auth_enabled
      tags:
        - mongodb
        - mongodb-keyfile

    - name: Create MongoDB configuration file
      template:
        src: mongod.conf.j2
        dest: /etc/mongod.conf
        owner: root
        group: root
        mode: '0644'
        backup: yes
      notify: restart mongodb
      tags:
        - mongodb
        - mongodb-config

    - name: Start and enable MongoDB service
      systemd:
        name: mongod
        state: started
        enabled: yes
        daemon_reload: yes
      register: mongodb_started
      tags:
        - mongodb
        - mongodb-service

    - name: Wait for MongoDB to be ready
      wait_for:
        port: "{{ mitum_mongodb_port }}"
        host: "{{ mitum_mongodb_bind_ip }}"
        delay: 5
        timeout: 60
      tags:
        - mongodb
        - mongodb-wait

    - name: Check if replica set is already initialized
      shell: |
        mongosh --quiet --eval "rs.status().ok" || echo "0"
      register: rs_status
      changed_when: false
      tags:
        - mongodb
        - mongodb-replica

    - name: Initialize MongoDB replica set
      shell: |
        mongosh --eval '
        rs.initiate({
          _id: "{{ mitum_mongodb_replica_set }}",
          members: [
            { _id: 0, host: "{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}" }
          ]
        })'
      when: rs_status.stdout == "0"
      register: rs_init_result
      tags:
        - mongodb
        - mongodb-replica

    - name: Wait for PRIMARY state
      shell: |
        mongosh --quiet --eval "rs.status().myState"
      register: rs_state
      until: rs_state.stdout == "1"
      retries: 30
      delay: 2
      when: rs_init_result is changed
      tags:
        - mongodb
        - mongodb-replica

    - name: Create MongoDB admin user
      shell: |
        mongosh admin --eval '
        db.createUser({
          user: "{{ mitum_mongodb_admin_user }}",
          pwd: "{{ mitum_mongodb_admin_password }}",
          roles: [
            { role: "userAdminAnyDatabase", db: "admin" },
            { role: "dbAdminAnyDatabase", db: "admin" },
            { role: "readWriteAnyDatabase", db: "admin" },
            { role: "clusterAdmin", db: "admin" }
          ]
        })'
      when: 
        - mitum_mongodb_auth_enabled
        - rs_state.stdout == "1"
      no_log: true
      ignore_errors: yes  # User might already exist
      tags:
        - mongodb
        - mongodb-auth

    - name: Create Mitum database and user
      shell: |
        mongosh -u "{{ mitum_mongodb_admin_user }}" -p "{{ mitum_mongodb_admin_password }}" --authenticationDatabase admin --eval '
        use mitum;
        db.createUser({
          user: "{{ mitum_mongodb_user }}",
          pwd: "{{ mitum_mongodb_password }}",
          roles: [
            { role: "readWrite", db: "mitum" },
            { role: "dbAdmin", db: "mitum" }
          ]
        })'
      when: 
        - mitum_mongodb_auth_enabled
        - rs_state.stdout == "1"
      no_log: true
      ignore_errors: yes  # User might already exist
      tags:
        - mongodb
        - mongodb-auth

  rescue:
    - name: MongoDB setup failed
      debug:
        msg: |
          MongoDB setup encountered an error: {{ ansible_failed_result.msg }}
          Please check the logs at /var/log/mongodb/mongod.log
      tags:
        - mongodb
        - mongodb-error

- name: MongoDB Docker Setup (Alternative)
  block:
    - name: Pull MongoDB Docker image
      docker_image:
        name: "mongo:{{ mitum_mongodb_version }}"
        source: pull
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Create Docker volumes for MongoDB
      docker_volume:
        name: "{{ item }}"
        state: present
      loop:
        - mitum_mongodb_data
        - mitum_mongodb_config
        - mitum_mongodb_logs
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Copy MongoDB configuration for Docker
      copy:
        content: |
          storage:
            dbPath: /data/db
          systemLog:
            destination: file
            path: /var/log/mongodb/mongod.log
            logAppend: true
          net:
            port: {{ mitum_mongodb_port }}
            bindIp: 0.0.0.0
          security:
            authorization: {{ 'enabled' if mitum_mongodb_auth_enabled else 'disabled' }}
          replication:
            replSetName: "{{ mitum_mongodb_replica_set }}"
        dest: /tmp/mongod-docker.conf
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Run MongoDB container
      docker_container:
        name: mitum-mongodb
        image: "mongo:{{ mitum_mongodb_version }}"
        state: started
        restart_policy: unless-stopped
        ports:
          - "{{ mitum_mongodb_port }}:{{ mitum_mongodb_port }}"
        volumes:
          - mitum_mongodb_data:/data/db
          - mitum_mongodb_config:/data/configdb
          - mitum_mongodb_logs:/var/log/mongodb
          - /tmp/mongod-docker.conf:/etc/mongod.conf:ro
        command: ["mongod", "--config", "/etc/mongod.conf"]
        env:
          MONGO_INITDB_ROOT_USERNAME: "{{ mitum_mongodb_admin_user if mitum_mongodb_auth_enabled else '' }}"
          MONGO_INITDB_ROOT_PASSWORD: "{{ mitum_mongodb_admin_password if mitum_mongodb_auth_enabled else '' }}"
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Wait for MongoDB container to be ready
      wait_for:
        port: "{{ mitum_mongodb_port }}"
        host: localhost
        delay: 10
        timeout: 60
      when: mitum_mongodb_install_method == 'docker'
      tags:
        - mongodb
        - mongodb-docker

    - name: Initialize replica set in Docker
      docker_container_exec:
        container: mitum-mongodb
        command: |
          mongosh --eval '
          rs.initiate({
            _id: "{{ mitum_mongodb_replica_set }}",
            members: [
              { _id: 0, host: "127.0.0.1:{{ mitum_mongodb_port }}" }
            ]
          })'
      when: mitum_mongodb_install_method == 'docker'
      register: docker_rs_init
      ignore_errors: yes
      tags:
        - mongodb
        - mongodb-docker

- name: Verify MongoDB connectivity for Mitum
  block:
    - name: Test MongoDB connection
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongosh -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% else %}
        mongosh --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% endif %}
      register: mongodb_ping
      changed_when: false
      tags:
        - mongodb
        - mongodb-verify

    - name: Display MongoDB connection status
      debug:
        msg: "MongoDB is {{ 'connected and ready' if mongodb_ping.rc == 0 else 'not accessible' }}"
      tags:
        - mongodb
        - mongodb-verify

    - name: Set MongoDB connection fact for Mitum
      set_fact:
        mitum_mongodb_uri: >-
          {% if mitum_mongodb_auth_enabled %}
          mongodb://{{ mitum_mongodb_user }}:{{ mitum_mongodb_password }}@{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}/mitum?replicaSet={{ mitum_mongodb_replica_set }}
          {% else %}
          mongodb://{{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }}/mitum?replicaSet={{ mitum_mongodb_replica_set }}
          {% endif %}
      tags:
        - mongodb
        - mongodb-verify

================================================================================
íŒŒì¼: roles/mitum/tasks/monitoring-prometheus.yml
================================================================================
---
# Configure Prometheus monitoring for Mitum nodes

- name: Install Node Exporter
  when: mitum_node_exporter_enabled | default(true)
  block:
    - name: Create node_exporter user
      user:
        name: node_exporter
        system: yes
        shell: /usr/sbin/nologin
        home: /var/lib/node_exporter
        create_home: no

    - name: Download Node Exporter
      get_url:
        url: "https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz"
        dest: /tmp/node_exporter.tar.gz
        mode: '0644'

    - name: Extract Node Exporter
      unarchive:
        src: /tmp/node_exporter.tar.gz
        dest: /tmp
        remote_src: yes
        creates: /tmp/node_exporter-1.6.1.linux-amd64/node_exporter

    - name: Install Node Exporter binary
      copy:
        src: /tmp/node_exporter-1.6.1.linux-amd64/node_exporter
        dest: /usr/local/bin/node_exporter
        owner: root
        group: root
        mode: '0755'
        remote_src: yes

    - name: Create Node Exporter service
      template:
        src: node_exporter.service.j2
        dest: /etc/systemd/system/node_exporter.service
        owner: root
        group: root
        mode: '0644'
      notify:
        - reload systemd
        - restart node_exporter

    - name: Start Node Exporter
      systemd:
        name: node_exporter
        state: started
        enabled: yes
        daemon_reload: yes

- name: Install MongoDB Exporter
  when: 
    - mitum_mongodb_enabled | default(true)
    - mitum_mongodb_exporter_enabled | default(true)
  block:
    - name: Download MongoDB Exporter
      get_url:
        url: "https://github.com/percona/mongodb_exporter/releases/download/v0.39.0/mongodb_exporter-0.39.0.linux-amd64.tar.gz"
        dest: /tmp/mongodb_exporter.tar.gz
        mode: '0644'

    - name: Extract MongoDB Exporter
      unarchive:
        src: /tmp/mongodb_exporter.tar.gz
        dest: /tmp
        remote_src: yes

    - name: Install MongoDB Exporter binary
      copy:
        src: /tmp/mongodb_exporter-0.39.0.linux-amd64/mongodb_exporter
        dest: /usr/local/bin/mongodb_exporter
        owner: root
        group: root
        mode: '0755'
        remote_src: yes

    - name: Create MongoDB Exporter service
      template:
        src: mongodb_exporter.service.j2
        dest: /etc/systemd/system/mongodb_exporter.service
        owner: root
        group: root
        mode: '0644'
      notify:
        - reload systemd
        - restart mongodb_exporter

    - name: Start MongoDB Exporter
      systemd:
        name: mongodb_exporter
        state: started
        enabled: yes
        daemon_reload: yes

- name: Configure Mitum metrics endpoint
  when: mitum_prometheus_enabled | default(true)
  block:
    - name: Verify Mitum metrics endpoint
      uri:
        url: "http://localhost:{{ mitum_prometheus_port }}/metrics"
        status_code: 200
        timeout: 5
      retries: 3
      delay: 5
      register: metrics_check
      failed_when: false

    - name: Display metrics status
      debug:
        msg: "Mitum metrics endpoint: {{ 'Available' if metrics_check.status == 200 else 'Not Available' }}"

- name: Configure firewall for monitoring
  when: mitum_security_firewall_enabled and ansible_os_family in ["Debian", "RedHat"]
  block:
    - name: Allow monitoring ports (UFW)
      when: ansible_os_family == "Debian"
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
        comment: "Prometheus monitoring"
      loop:
        - "{{ mitum_prometheus_port }}"
        - "{{ mitum_node_exporter_port }}"
        - "9216"  # MongoDB exporter

    - name: Allow monitoring ports (firewalld)
      when: ansible_os_family == "RedHat"
      firewalld:
        port: "{{ item }}/tcp"
        permanent: yes
        state: enabled
        immediate: yes
      loop:
        - "{{ mitum_prometheus_port }}"
        - "{{ mitum_node_exporter_port }}"
        - "9216"

- name: Register node with Prometheus
  when: groups['monitoring'] is defined and groups['monitoring'] | length > 0
  delegate_to: "{{ groups['monitoring'][0] }}"
  block:
    - name: Add node to Prometheus targets
      lineinfile:
        path: /etc/prometheus/targets/mitum.yml
        line: "    - {{ ansible_default_ipv4.address }}:{{ mitum_prometheus_port }}"
        create: yes
        state: present
      notify: reload prometheus

    - name: Add node exporter target
      lineinfile:
        path: /etc/prometheus/targets/node.yml
        line: "    - {{ ansible_default_ipv4.address }}:{{ mitum_node_exporter_port }}"
        create: yes
        state: present
      notify: reload prometheus

================================================================================
íŒŒì¼: roles/mitum/tasks/service.yml
================================================================================
---
# Service management tasks for Mitum

- name: Ensure systemd service file exists
  stat:
    path: "/etc/systemd/system/{{ mitum_service_name }}.service"
  register: service_file

- name: Create systemd service if not exists
  when: not service_file.stat.exists
  template:
    src: mitum.service.j2
    dest: "/etc/systemd/system/{{ mitum_service_name }}.service"
    owner: root
    group: root
    mode: '0644'
  notify:
    - reload systemd

- name: Reload systemd daemon
  systemd:
    daemon_reload: yes
  when: not service_file.stat.exists

- name: Enable Mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    enabled: yes

- name: Check if initial start
  stat:
    path: "{{ mitum_data_dir }}/.initialized"
  register: initialized

- name: Start Mitum service
  systemd:
    name: "{{ mitum_service_name }}"
    state: started
  register: service_start
  when: mitum_deployment_phase | default('all') in ['all', 'start']

- name: Wait for service to be ready
  wait_for:
    port: "{{ mitum_node_port }}"
    host: "{{ ansible_default_ipv4.address }}"
    state: started
    delay: 5
    timeout: 60
  when: service_start is changed

- name: Verify service health
  uri:
    url: "http://localhost:{{ mitum_node_port }}/v2/node"
    status_code: 200
    timeout: 10
  retries: 10
  delay: 3
  register: health_check
  until: health_check.status == 200
  when: 
    - service_start is changed
    - mitum_validate_startup | default(true)

- name: Check API service (API nodes only)
  uri:
    url: "http://localhost:{{ mitum_api_port }}/v2/node"
    status_code: 200
    timeout: 10
  retries: 10
  delay: 3
  when: 
    - mitum_api_enabled | default(false)
    - service_start is changed

- name: Mark as initialized
  file:
    path: "{{ mitum_data_dir }}/.initialized"
    state: touch
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
  when: 
    - not initialized.stat.exists
    - health_check is succeeded

================================================================================
íŒŒì¼: roles/mitum/tasks/system-prepare.yml
================================================================================
---
# System preparation tasks

- name: Install required system packages
  package:
    name:
      - git
      - build-essential
      - jq
      - curl
      - wget
      - ca-certificates
      - gnupg
      - lsb-release
    state: present
    update_cache: yes

- name: Create mitum group
  group:
    name: "{{ mitum_service_group }}"
    state: present
    system: yes

- name: Create mitum user
  user:
    name: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    home: "{{ mitum_install_dir }}"
    shell: /bin/bash
    system: yes
    create_home: yes

- name: Create required directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0755'
  loop:
    - "{{ mitum_install_dir }}"
    - "{{ mitum_config_dir }}"
    - "{{ mitum_keys_dir }}"
    - "{{ mitum_data_dir }}"
    - "{{ mitum_log_dir }}"
    - "{{ mitum_backup_dir }}"

================================================================================
íŒŒì¼: roles/mitum/tasks/validate.yml
================================================================================
---
# Validation tasks for Mitum and MongoDB

- name: Validate MongoDB connectivity
  block:
    - name: Check MongoDB connection
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongosh -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% else %}
        mongosh --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "db.runCommand('ping')"
        {% endif %}
      register: mongodb_ping
      changed_when: false

    - name: Check MongoDB replica set status
      shell: |
        {% if mitum_mongodb_auth_enabled %}
        mongosh -u "{{ mitum_mongodb_user }}" -p "{{ mitum_mongodb_password }}" \
          --authenticationDatabase mitum \
          --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "rs.status().ok"
        {% else %}
        mongosh --host {{ mitum_mongodb_bind_ip }}:{{ mitum_mongodb_port }} \
          --eval "rs.status().ok"
        {% endif %}
      register: rs_status_check
      changed_when: false

    - name: Display MongoDB status
      debug:
        msg: |
          MongoDB Connection: {{ 'SUCCESS' if mongodb_ping.rc == 0 else 'FAILED' }}
          Replica Set Status: {{ 'OK' if rs_status_check.stdout == '1' else 'NOT OK' }}
  tags:
    - validate-mongodb

- name: Validate Mitum installation
  block:
    - name: Check Mitum binary exists
      stat:
        path: "{{ mitum_install_dir }}/{{ mitum_model_type }}"
      register: mitum_binary

    - name: Check Mitum version
      command: "{{ mitum_install_dir }}/{{ mitum_model_type }} version"
      register: mitum_version_check
      when: mitum_binary.stat.exists
      changed_when: false

    - name: Check Mitum configuration files
      stat:
        path: "{{ item }}"
      register: config_files
      loop:
        - "{{ mitum_install_dir }}/config/standalone.yml"
        - "{{ mitum_install_dir }}/config/genesis-design.yml"

    - name: Validate Mitum data directory
      stat:
        path: "{{ mitum_data_dir }}"
      register: data_dir

    - name: Check if Mitum is initialized
      stat:
        path: "{{ mitum_data_dir }}/.initialized"
      register: init_marker

    - name: Display Mitum installation status
      debug:
        msg: |
          Mitum Binary: {{ 'Found' if mitum_binary.stat.exists else 'Not Found' }}
          {% if mitum_binary.stat.exists %}
          Version: {{ mitum_version_check.stdout | default('Unknown') }}
          {% endif %}
          Configuration Files: {{ 'All Present' if config_files.results | selectattr('stat.exists') | list | length == 2 else 'Missing' }}
          Data Directory: {{ 'Exists' if data_dir.stat.exists else 'Not Found' }}
          Initialized: {{ 'Yes' if init_marker.stat.exists else 'No' }}
  tags:
    - validate-mitum

- name: Validate Mitum service
  block:
    - name: Check Mitum service status
      systemd:
        name: "{{ mitum_service_name }}"
      register: mitum_service_status

    - name: Get Mitum service logs (last 20 lines)
      shell: |
        journalctl -u {{ mitum_service_name }} -n 20 --no-pager
      register: mitum_logs
      changed_when: false
      when: mitum_service_status.status.ActiveState == 'active'

    - name: Check Mitum API endpoint
      uri:
        url: "http://{{ mitum_bind_host }}:{{ mitum_bind_port }}/v1/status"
        method: GET
        timeout: 10
      register: api_check
      failed_when: false
      when: mitum_service_status.status.ActiveState == 'active'

    - name: Display service status
      debug:
        msg: |
          Service State: {{ mitum_service_status.status.ActiveState }}
          Service Status: {{ mitum_service_status.status.SubState }}
          {% if mitum_service_status.status.ActiveState == 'active' %}
          API Endpoint: {{ 'Responsive' if api_check.status is defined and api_check.status == 200 else 'Not Responsive' }}
          {% endif %}
  tags:
    - validate-service

- name: Generate validation report
  set_fact:
    validation_report:
      timestamp: "{{ ansible_date_time.iso8601 }}"
      mongodb:
        connected: "{{ mongodb_ping.rc == 0 }}"
        replica_set_ok: "{{ rs_status_check.stdout == '1' }}"
      mitum:
        binary_exists: "{{ mitum_binary.stat.exists }}"
        config_complete: "{{ config_files.results | selectattr('stat.exists') | list | length == 2 }}"
        initialized: "{{ init_marker.stat.exists }}"
        service_active: "{{ mitum_service_status.status.ActiveState == 'active' }}"
        api_responsive: "{{ api_check.status is defined and api_check.status == 200 }}"
  tags:
    - validate-report

- name: Display validation summary
  debug:
    msg: |
      ====== Mitum Validation Summary ======
      Timestamp: {{ validation_report.timestamp }}
      
      MongoDB Status:
        - Connected: {{ 'âœ“' if validation_report.mongodb.connected else 'âœ—' }}
        - Replica Set: {{ 'âœ“' if validation_report.mongodb.replica_set_ok else 'âœ—' }}
      
      Mitum Status:
        - Binary: {{ 'âœ“' if validation_report.mitum.binary_exists else 'âœ—' }}
        - Config: {{ 'âœ“' if validation_report.mitum.config_complete else 'âœ—' }}
        - Initialized: {{ 'âœ“' if validation_report.mitum.initialized else 'âœ—' }}
        - Service: {{ 'âœ“' if validation_report.mitum.service_active else 'âœ—' }}
        - API: {{ 'âœ“' if validation_report.mitum.api_responsive else 'âœ—' }}
      
      Overall Status: {{ 'HEALTHY' if (validation_report.values() | map(attribute='values') | flatten | select('equalto', true) | list | length) == 7 else 'ISSUES DETECTED' }}
  tags:
    - validate-summary

- name: Export validation report to file
  copy:
    content: "{{ validation_report | to_nice_json }}"
    dest: "{{ mitum_install_dir }}/validation-report-{{ ansible_date_time.epoch }}.json"
    owner: "{{ mitum_service_user }}"
    group: "{{ mitum_service_group }}"
    mode: '0644'
  when: mitum_export_validation_report | default(false)
  tags:
    - validate-export

================================================================================
íŒŒì¼: scripts/add-key.sh
================================================================================
#!/bin/bash
# Simple key addition script

set -e

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
KEYS_DIR="$ROOT_DIR/keys"

# Check arguments
if [ $# -lt 2 ]; then
    echo "Usage: $0 <environment> <key-file> [name]"
    echo "Example: $0 production ~/mitum_sit.pem bastion.pem"
    exit 1
fi

ENV=$1
SOURCE=$2
NAME=${3:-$(basename "$SOURCE")}

# Validate environment
if [[ ! "$ENV" =~ ^(production|staging|development)$ ]]; then
    echo -e "${RED}Error: Invalid environment '$ENV'${NC}"
    echo "Valid: production, staging, development"
    exit 1
fi

# Check source file
if [ ! -f "$SOURCE" ]; then
    echo -e "${RED}Error: Key file not found: $SOURCE${NC}"
    exit 1
fi

# Create directory
mkdir -p "$KEYS_DIR/ssh/$ENV"

# Copy key
TARGET="$KEYS_DIR/ssh/$ENV/$NAME"
cp "$SOURCE" "$TARGET"
chmod 600 "$TARGET"

echo -e "${GREEN}âœ“ Key added successfully${NC}"
echo "  Environment: $ENV"
echo "  Key name: $NAME"
echo "  Location: $TARGET"

# List all keys
echo -e "\n${GREEN}Current keys in $ENV:${NC}"
ls -la "$KEYS_DIR/ssh/$ENV/"

================================================================================
íŒŒì¼: scripts/autocomplete.sh
================================================================================
#!/bin/bash

# Mitum Ansible Autocomplete Script
# Enhanced bash completion for Makefile targets

_mitum_ansible_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Extract make targets from Makefile
    local targets=$(grep -E '^[a-zA-Z_-]+:.*?## .*$$' Makefile 2>/dev/null | awk -F':' '{print $1}' | sort -u)
    
    # Environment options
    local environments="development staging production"
    
    # Common options
    local options="ENV= DRY_RUN= SAFE_MODE= PARALLEL_FORKS= USE_VAULT="
    
    case "${prev}" in
        ENV=)
            COMPREPLY=( $(compgen -W "${environments}" -- ${cur}) )
            return 0
            ;;
        DRY_RUN=|SAFE_MODE=|USE_VAULT=)
            COMPREPLY=( $(compgen -W "yes no" -- ${cur}) )
            return 0
            ;;
        PARALLEL_FORKS=)
            COMPREPLY=( $(compgen -W "25 50 75 100" -- ${cur}) )
            return 0
            ;;
        make)
            # Show all targets and common options
            COMPREPLY=( $(compgen -W "${targets} ${options}" -- ${cur}) )
            return 0
            ;;
        *)
            # Check if we're completing an option
            if [[ ${cur} == *=* ]]; then
                local option="${cur%%=*}="
                local value="${cur#*=}"
                
                case "${option}" in
                    ENV=)
                        COMPREPLY=( $(compgen -W "${environments}" -P "${option}" -- ${value}) )
                        ;;
                    DRY_RUN=|SAFE_MODE=|USE_VAULT=)
                        COMPREPLY=( $(compgen -W "yes no" -P "${option}" -- ${value}) )
                        ;;
                    PARALLEL_FORKS=)
                        COMPREPLY=( $(compgen -W "25 50 75 100" -P "${option}" -- ${value}) )
                        ;;
                esac
            else
                # Show options for current context
                COMPREPLY=( $(compgen -W "${options}" -- ${cur}) )
            fi
            ;;
    esac
}

# Register completion
complete -F _mitum_ansible_completion make

# Install instructions
echo "# Mitum Ansible Autocomplete Installed!"
echo "# To enable permanently, add this line to your ~/.bashrc or ~/.zshrc:"
echo "# source $(pwd)/scripts/autocomplete.sh" 

================================================================================
íŒŒì¼: scripts/deploy-mitum.sh
================================================================================
#!/bin/bash
# deploy-mitum.sh - Enhanced Mitum deployment script for beginners
# Version: 4.0.0 - Improved with better UX and integration with Makefile
#
# This script provides a user-friendly way to deploy Mitum blockchain
# It can be used standalone or in conjunction with Makefile commands
#
# Features:
# - Interactive mode for beginners
# - Automatic prerequisite checking
# - Integration with Makefile commands
# - Clear error messages and guidance

set -euo pipefail

# Colors for better readability
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Script configuration
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
MAKEFILE="$ROOT_DIR/Makefile"

# Default values
INVENTORY="${INVENTORY:-inventories/production/hosts.yml}"
ENVIRONMENT="${ENV:-production}"
INTERACTIVE_MODE=false
USE_MAKEFILE=true
SKIP_KEYGEN=false
SKIP_MONGODB=false
SKIP_PREPARE=false
KEYGEN_STRATEGY="centralized"
VERBOSE=false
DRY_RUN=false

# Logging functions
log() { echo -e "${GREEN}[INFO]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
warning() { echo -e "${YELLOW}[WARN]${NC} $*"; }
info() { echo -e "${CYAN}[INFO]${NC} $*"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
prompt() { echo -ne "${PURPLE}[?]${NC} $*"; }

# Display banner
show_banner() {
    echo -e "${BLUE}"
    cat << 'EOF'
    __  ____  __                   ___              _ __    __   
   /  |/  (_)/ /___  ______ ___   /   |  ____  ___(_) /__ / /__ 
  / /|_/ / / __/ / / / __ `__ \ / /| | / __ \/ ___/ / __ \/ / _ \
 / /  / / / /_/ /_/ / / / / / // ___ |/ / / (__  ) / /_/ / /  __/
/_/  /_/_/\__/\__,_/_/ /_/ /_//_/  |_/_/ /_/____/_/_.___/_/\___/ 
                                                                  
EOF
    echo -e "${NC}"
    echo -e "${CYAN}Mitum Blockchain Deployment Tool v4.0.0${NC}"
    echo -e "${CYAN}========================================${NC}"
    echo ""
}

# Usage help
usage() {
    cat << EOF
${GREEN}Usage:${NC} $0 [OPTIONS] [INVENTORY]

${YELLOW}Description:${NC}
    Deploy Mitum blockchain network with easy-to-use interface.
    Can be used standalone or with Makefile integration.

${YELLOW}Arguments:${NC}
    INVENTORY           Path to inventory file (default: inventories/production/hosts.yml)

${YELLOW}Options:${NC}
    -i, --interactive   Run in interactive mode (recommended for beginners)
    -e, --env ENV       Target environment (production/staging/development)
    --skip-keygen       Skip key generation step
    --skip-mongodb      Skip MongoDB installation
    --skip-prepare      Skip system preparation
    --no-make          Don't use Makefile (direct Ansible execution)
    --dry-run          Show what would be executed without making changes
    -v, --verbose      Enable verbose output
    -h, --help         Show this help message

${YELLOW}Examples:${NC}
    # Interactive mode (easiest for beginners)
    $0 --interactive

    # Quick deployment with defaults
    $0

    # Deploy to staging environment
    $0 --env staging

    # Skip key generation (use existing keys)
    $0 --skip-keygen

    # Dry run to preview changes
    $0 --dry-run

${YELLOW}Integration with Makefile:${NC}
    This script can use Makefile commands for better integration:
    - Uses 'make test' for connectivity testing
    - Uses 'make keygen' for key generation
    - Uses 'make deploy' for full deployment

    To use direct Ansible commands instead, add --no-make option.

${YELLOW}Requirements:${NC}
    - Python 3.8+
    - Ansible 6.0+
    - Node.js 14+ (for key generation)
    - SSH access to target servers

EOF
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check if make target exists
make_target_exists() {
    make -n "$1" >/dev/null 2>&1
}

# Interactive mode for beginners
interactive_mode() {
    show_banner
    
    echo -e "${CYAN}Welcome to Mitum Deployment Interactive Mode!${NC}"
    echo -e "${CYAN}This wizard will guide you through the deployment process.${NC}"
    echo ""
    
    # Step 1: Environment selection
    echo -e "${YELLOW}Step 1: Select Environment${NC}"
    PS3="Please select environment (1-3): "
    options=("Production" "Staging" "Development")
    select opt in "${options[@]}"; do
        case $REPLY in
            1) ENVIRONMENT="production"; break;;
            2) ENVIRONMENT="staging"; break;;
            3) ENVIRONMENT="development"; break;;
            *) echo "Invalid option. Please try again.";;
        esac
    done
    echo -e "${GREEN}âœ“ Selected: $ENVIRONMENT${NC}"
    echo ""
    
    # Step 2: Check inventory
    INVENTORY="inventories/$ENVIRONMENT/hosts.yml"
    if [[ ! -f "$INVENTORY" ]]; then
        echo -e "${YELLOW}Step 2: Create Inventory${NC}"
        echo "No inventory found for $ENVIRONMENT environment."
        prompt "Would you like to create one now? (y/n): "
        read -r create_inventory
        
        if [[ "$create_inventory" =~ ^[Yy]$ ]]; then
            if command_exists make && make_target_exists inventory; then
                info "Starting inventory creation wizard..."
                make inventory
            else
                error "Inventory creation not available. Please create manually."
                exit 1
            fi
        else
            error "Cannot proceed without inventory file."
            exit 1
        fi
    else
        success "Inventory found: $INVENTORY"
    fi
    echo ""
    
    # Step 3: Deployment options
    echo -e "${YELLOW}Step 3: Deployment Options${NC}"
    
    prompt "Generate new blockchain keys? (y/n) [y]: "
    read -r gen_keys
    if [[ ! "$gen_keys" =~ ^[Nn]$ ]]; then
        SKIP_KEYGEN=false
        prompt "Key generation strategy (centralized/distributed) [centralized]: "
        read -r keygen_strat
        KEYGEN_STRATEGY="${keygen_strat:-centralized}"
    else
        SKIP_KEYGEN=true
    fi
    
    prompt "Install MongoDB? (y/n) [y]: "
    read -r install_mongo
    [[ "$install_mongo" =~ ^[Nn]$ ]] && SKIP_MONGODB=true
    
    prompt "Prepare systems (install dependencies)? (y/n) [y]: "
    read -r prepare_sys
    [[ "$prepare_sys" =~ ^[Nn]$ ]] && SKIP_PREPARE=true
    
    prompt "Setup monitoring (Prometheus/Grafana)? (y/n) [n]: "
    read -r setup_mon
    [[ "$setup_mon" =~ ^[Yy]$ ]] && SETUP_MONITORING=true
    
    prompt "Run in dry-run mode (preview only)? (y/n) [n]: "
    read -r dry_run
    [[ "$dry_run" =~ ^[Yy]$ ]] && DRY_RUN=true
    
    # Advanced options
    prompt "Show advanced options? (y/n) [n]: "
    read -r show_advanced
    if [[ "$show_advanced" =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${YELLOW}Advanced Options:${NC}"
        
        prompt "Mitum version [latest]: "
        read -r mitum_ver
        [[ -n "$mitum_ver" ]] && MITUM_VERSION="$mitum_ver"
        
        prompt "Mitum model (mitum-currency/mitum-nft/mitum-document) [mitum-currency]: "
        read -r mitum_model
        [[ -n "$mitum_model" ]] && MITUM_MODEL="$mitum_model"
        
        prompt "MongoDB version [7.0]: "
        read -r mongo_ver
        [[ -n "$mongo_ver" ]] && MONGODB_VERSION="$mongo_ver"
        
        prompt "Update group_vars even if exists? (y/n) [n]: "
        read -r update_vars
        [[ "$update_vars" =~ ^[Yy]$ ]] && UPDATE_GROUP_VARS=true
    fi
    
    echo ""
    
    # Step 4: Summary
    echo -e "${YELLOW}Step 4: Deployment Summary${NC}"
    echo "================================"
    echo "Environment: $ENVIRONMENT"
    echo "Inventory: $INVENTORY"
    echo "Generate Keys: $([ "$SKIP_KEYGEN" == "true" ] && echo "No" || echo "Yes ($KEYGEN_STRATEGY)")"
    echo "Install MongoDB: $([ "$SKIP_MONGODB" == "true" ] && echo "No" || echo "Yes")"
    echo "Prepare Systems: $([ "$SKIP_PREPARE" == "true" ] && echo "No" || echo "Yes")"
    echo "Dry Run: $([ "$DRY_RUN" == "true" ] && echo "Yes" || echo "No")"
    echo "================================"
    echo ""
    
    prompt "Proceed with deployment? (y/n): "
    read -r proceed
    if [[ ! "$proceed" =~ ^[Yy]$ ]]; then
        warning "Deployment cancelled by user."
        exit 0
    fi
    
    echo ""
    info "Starting deployment..."
    echo ""
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -i|--interactive)
                INTERACTIVE_MODE=true
                shift
                ;;
            -e|--env)
                ENVIRONMENT="$2"
                INVENTORY="inventories/$2/hosts.yml"
                shift 2
                ;;
            --skip-keygen)
                SKIP_KEYGEN=true
                shift
                ;;
            --skip-mongodb)
                SKIP_MONGODB=true
                shift
                ;;
            --skip-prepare)
                SKIP_PREPARE=true
                shift
                ;;
            --no-make)
                USE_MAKEFILE=false
                shift
                ;;
            --keygen-strategy)
                KEYGEN_STRATEGY="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                # Assume it's inventory path
                INVENTORY="$1"
                shift
                ;;
        esac
    done
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    local missing_deps=()
    
    # Check Python
    if ! command_exists python3; then
        missing_deps+=("Python 3.8+")
    fi
    
    # Check virtual environment
    if [[ -z "${VIRTUAL_ENV:-}" ]]; then
        if [[ -f "$ROOT_DIR/venv/bin/activate" ]]; then
            info "Activating Python virtual environment..."
            source "$ROOT_DIR/venv/bin/activate"
        else
            missing_deps+=("Python virtual environment (run: make setup)")
        fi
    fi
    
    # Check Ansible
    if ! command_exists ansible; then
        missing_deps+=("Ansible 6.0+")
    fi
    
    # Check Node.js (for key generation)
    if [[ "$SKIP_KEYGEN" == "false" ]] && [[ "$KEYGEN_STRATEGY" == "centralized" ]]; then
        if ! command_exists node; then
            missing_deps+=("Node.js 14+ (for key generation)")
        else
            local node_version=$(node --version | grep -oE '[0-9]+' | head -1)
            if [[ $node_version -lt 14 ]]; then
                missing_deps+=("Node.js 14+ (current: $(node --version))")
            fi
        fi
    fi
    
    # Check Make (if using Makefile)
    if [[ "$USE_MAKEFILE" == "true" ]] && ! command_exists make; then
        warning "Make not found. Switching to direct Ansible execution."
        USE_MAKEFILE=false
    fi
    
    # Report missing dependencies
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error "Missing prerequisites:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Please run: ${GREEN}make setup${NC} or install missing dependencies manually."
        exit 1
    fi
    
    success "All prerequisites satisfied âœ“"
}

# Check inventory and SSH keys
check_inventory_and_keys() {
    log "Checking inventory and SSH keys..."
    
    # Check inventory file
    if [[ ! -f "$INVENTORY" ]]; then
        error "Inventory file not found: $INVENTORY"
        echo ""
        echo "To create inventory, run one of:"
        echo "  ${GREEN}make inventory BASTION_IP=x.x.x.x NODE_IPS=10.0.1.10,10.0.1.11${NC}"
        echo "  ${GREEN}$0 --interactive${NC}"
        exit 1
    fi
    
    # Extract environment from inventory path
    local env=$(basename $(dirname "$INVENTORY"))
    
    # Check SSH keys
    local bastion_key="$ROOT_DIR/keys/ssh/$env/bastion.pem"
    local keys_found=true
    
    if [[ ! -f "$bastion_key" ]]; then
        error "Bastion SSH key not found: $bastion_key"
        keys_found=false
    fi
    
    if [[ "$keys_found" == "false" ]]; then
        echo ""
        echo "To add SSH keys, run:"
        echo "  ${GREEN}./scripts/add-key.sh $env ~/path/to/your-key.pem bastion.pem${NC}"
        echo "Or:"
        echo "  ${GREEN}make keys-add ENV=$env KEY=~/path/to/your-key.pem NAME=bastion.pem${NC}"
        exit 1
    fi
    
    success "Inventory and SSH keys verified âœ“"
}

# Run command with proper error handling
run_command() {
    local description="$1"
    shift
    local command="$@"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "DRY RUN: $description"
        echo "  Command: $command"
        return 0
    fi
    
    log "$description..."
    
    if [[ "$VERBOSE" == "true" ]]; then
        echo "  Command: $command"
    fi
    
    if eval "$command"; then
        success "$description completed âœ“"
        return 0
    else
        error "$description failed!"
        return 1
    fi
}

# Test connectivity
test_connectivity() {
    if [[ "$USE_MAKEFILE" == "true" ]] && make_target_exists test; then
        run_command "Testing connectivity" "make test ENV=$ENVIRONMENT"
    else
        run_command "Testing connectivity" "ansible -i '$INVENTORY' all -m ping"
    fi
}

# Generate keys
generate_keys() {
    if [[ "$SKIP_KEYGEN" == "true" ]]; then
        info "Skipping key generation (--skip-keygen)"
        return 0
    fi
    
    local keygen_args="-e mitum_keygen_strategy=$KEYGEN_STRATEGY"
    
    if [[ "$USE_MAKEFILE" == "true" ]] && make_target_exists keygen; then
        run_command "Generating blockchain keys" "make keygen ENV=$ENVIRONMENT"
    else
        run_command "Generating blockchain keys" \
            "ansible-playbook -i '$INVENTORY' playbooks/keygen.yml $keygen_args"
    fi
}

# Main deployment function
deploy() {
    # Show banner if not in interactive mode
    if [[ "$INTERACTIVE_MODE" == "false" ]]; then
        show_banner
    fi
    
    # Change to project root
    cd "$ROOT_DIR"
    
    # Step 1: Check prerequisites
    check_prerequisites
    
    # Step 2: Check inventory and keys
    check_inventory_and_keys
    
    # Step 3: Test connectivity
    test_connectivity || {
        error "Connectivity test failed. Please check:"
        echo "  1. SSH keys are correct"
        echo "  2. Bastion host is accessible"
        echo "  3. Security groups allow SSH access"
        exit 1
    }
    
    # Step 4: Generate keys
    generate_keys || {
        error "Key generation failed!"
        exit 1
    }
    
    # Step 5: Full deployment
    if [[ "$USE_MAKEFILE" == "true" ]] && make_target_exists deploy; then
        local make_args="ENV=$ENVIRONMENT"
        [[ "$SKIP_PREPARE" == "true" ]] && make_args="$make_args SKIP_PREPARE=true"
        [[ "$SKIP_MONGODB" == "true" ]] && make_args="$make_args SKIP_MONGODB=true"
        [[ "$DRY_RUN" == "true" ]] && make_args="$make_args DRY_RUN=yes"
        [[ "$VERBOSE" == "true" ]] && make_args="$make_args VERBOSE=true"
        
        run_command "Deploying Mitum cluster" "make deploy $make_args"
    else
        # Direct Ansible execution
        local playbook="$ROOT_DIR/playbooks/site.yml"
        local ansible_args="-i '$INVENTORY'"
        [[ "$DRY_RUN" == "true" ]] && ansible_args="$ansible_args --check"
        [[ "$VERBOSE" == "true" ]] && ansible_args="$ansible_args -vv"
        
        run_command "Deploying Mitum cluster" "ansible-playbook $ansible_args $playbook"
    fi
    
    # Step 6: Show completion message
    echo ""
    success "ðŸŽ‰ Mitum deployment completed successfully! ðŸŽ‰"
    echo ""
    echo -e "${YELLOW}Next Steps:${NC}"
    echo "1. Check cluster status:"
    echo "   ${GREEN}make status ENV=$ENVIRONMENT${NC}"
    echo ""
    echo "2. View logs:"
    echo "   ${GREEN}make logs ENV=$ENVIRONMENT${NC}"
    echo ""
    echo "3. Access API (find API node IP first):"
    echo "   ${GREEN}curl http://<api-node-ip>:54320/v2/node${NC}"
    echo ""
    echo "4. SSH to nodes:"
    echo "   ${GREEN}ssh -F inventories/$ENVIRONMENT/ssh_config node0${NC}"
    echo ""
    echo -e "${CYAN}For help: make help${NC}"
}

# Main execution
main() {
    # Parse arguments
    parse_args "$@"
    
    # Run interactive mode if requested
    if [[ "$INTERACTIVE_MODE" == "true" ]]; then
        interactive_mode
    fi
    
    # Check if running in CI/CD
    if [[ -n "${CI:-}" ]] || [[ -n "${JENKINS_HOME:-}" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        info "Running in CI/CD environment"
        VERBOSE=true
        USE_MAKEFILE=false  # Direct Ansible in CI/CD
    fi
    
    # Run deployment
    deploy
}

# Execute if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

================================================================================
íŒŒì¼: scripts/generate-group-vars.sh
================================================================================
#!/bin/bash
# generate-group-vars.sh - Generate comprehensive group_vars based on inventory
# Version: 1.0.0
#
# This script analyzes the inventory and generates optimized group_vars

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Functions
log() { echo -e "${GREEN}[INFO]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
warning() { echo -e "${YELLOW}[WARN]${NC} $*"; }

# Default values
INVENTORY="${1:-inventories/production/hosts.yml}"
FORCE="${2:-false}"

# Check inventory exists
if [[ ! -f "$INVENTORY" ]]; then
    error "Inventory not found: $INVENTORY"
    exit 1
fi

# Extract environment and paths
ENV_NAME=$(basename $(dirname "$INVENTORY"))
GROUP_VARS_DIR="$(dirname "$INVENTORY")/group_vars"
GROUP_VARS_FILE="$GROUP_VARS_DIR/all.yml"

# Check if already exists
if [[ -f "$GROUP_VARS_FILE" ]] && [[ "$FORCE" != "force" ]]; then
    warning "group_vars/all.yml already exists. Use 'force' to overwrite."
    exit 0
fi

log "Analyzing inventory: $INVENTORY"

# Parse inventory to extract information
parse_inventory() {
    # Count total nodes
    TOTAL_NODES=$(grep -E "^\s*node[0-9]+:" "$INVENTORY" | wc -l | tr -d ' ')
    
    # Count consensus vs API nodes
    CONSENSUS_NODES=0
    API_NODES=0
    
    # Extract node information
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*node[0-9]+: ]]; then
            NODE_NAME=$(echo "$line" | sed 's/://g' | tr -d ' ')
            # Check next few lines for mitum_api_enabled
            if grep -A5 "$line" "$INVENTORY" | grep -q "mitum_api_enabled: true"; then
                ((API_NODES++))
            else
                ((CONSENSUS_NODES++))
            fi
        fi
    done < "$INVENTORY"
    
    # Extract network info from inventory
    NETWORK_ID=$(grep -E "mitum_network_id:" "$INVENTORY" | head -1 | awk -F'"' '{print $2}' || echo "$ENV_NAME-network")
    MODEL_TYPE=$(grep -E "mitum_model_type:" "$INVENTORY" | head -1 | awk -F'"' '{print $2}' || echo "mitum-currency")
    
    # Extract MongoDB settings
    MONGODB_RS=$(grep -E "mitum_mongodb_replica_set:" "$INVENTORY" | head -1 | awk -F'"' '{print $2}' || echo "mitum-rs")
    
    log "Inventory analysis complete:"
    log "  - Total nodes: $TOTAL_NODES"
    log "  - Consensus nodes: $CONSENSUS_NODES"
    log "  - API nodes: $API_NODES"
    log "  - Network ID: $NETWORK_ID"
    log "  - Model: $MODEL_TYPE"
}

# Calculate optimal settings based on node count
calculate_optimal_settings() {
    # Consensus settings
    if [[ $CONSENSUS_NODES -le 3 ]]; then
        CONSENSUS_THRESHOLD=100
        BALLOT_INTERVAL="1.5s"
        PROPOSAL_INTERVAL="5s"
        WAIT_TIME="10s"
    elif [[ $CONSENSUS_NODES -le 5 ]]; then
        CONSENSUS_THRESHOLD=67
        BALLOT_INTERVAL="2.0s"
        PROPOSAL_INTERVAL="6s"
        WAIT_TIME="12s"
    else
        CONSENSUS_THRESHOLD=67
        BALLOT_INTERVAL="2.5s"
        PROPOSAL_INTERVAL="8s"
        WAIT_TIME="15s"
    fi
    
    # MongoDB settings
    if [[ $TOTAL_NODES -le 3 ]]; then
        MONGO_CACHE_GB=2
        MONGO_CONNECTIONS=1000
    elif [[ $TOTAL_NODES -le 7 ]]; then
        MONGO_CACHE_GB=4
        MONGO_CONNECTIONS=2000
    else
        MONGO_CACHE_GB=8
        MONGO_CONNECTIONS=5000
    fi
    
    # API rate limiting
    API_RATE_LIMIT=$((TOTAL_NODES * 1000))
    API_CACHE_SIZE=$((TOTAL_NODES * 200))
    
    log "Calculated optimal settings:"
    log "  - Consensus threshold: $CONSENSUS_THRESHOLD%"
    log "  - MongoDB cache: ${MONGO_CACHE_GB}GB"
    log "  - API rate limit: $API_RATE_LIMIT req/min"
}

# Generate group_vars file
generate_group_vars() {
    mkdir -p "$GROUP_VARS_DIR"
    
    cat > "$GROUP_VARS_FILE" << EOF
---
# Mitum Ansible Configuration
# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
# Environment: $ENV_NAME
# Based on: $TOTAL_NODES nodes ($CONSENSUS_NODES consensus, $API_NODES API)
#
# This file was auto-generated based on your inventory configuration.
# Feel free to modify it according to your needs.

# === Environment ===
mitum_environment: "$ENV_NAME"
mitum_deployment_timestamp: "{{ ansible_date_time.iso8601 }}"

# === Mitum Core Configuration ===
mitum_version: "latest"  # Change to specific version for production
mitum_model_type: "$MODEL_TYPE"
mitum_network_id: "$NETWORK_ID"
mitum_install_method: "binary"
mitum_service_name: "mitum"

# === Directory Layout ===
mitum_base_dir: "/opt/mitum"
mitum_install_dir: "{{ mitum_base_dir }}/bin"
mitum_data_dir: "{{ mitum_base_dir }}/data"
mitum_config_dir: "{{ mitum_base_dir }}/config"
mitum_keys_dir: "{{ mitum_base_dir }}/keys"
mitum_log_dir: "/var/log/mitum"
mitum_backup_dir: "/var/backups/mitum"
mitum_temp_dir: "/tmp/mitum"

# === Service Account ===
mitum_service_user: "mitum"
mitum_service_group: "mitum"
mitum_service_shell: "/bin/bash"
mitum_service_home: "/home/mitum"

# === Resource Limits ===
# Optimized for $TOTAL_NODES nodes
mitum_service_limits:
  nofile: $(( TOTAL_NODES > 10 ? 131072 : 65536 ))
  nproc: $(( TOTAL_NODES > 10 ? 65536 : 32768 ))
  memlock: unlimited

# === Network Ports ===
mitum_node_port_start: 4320
mitum_api_port: 54320
mitum_metrics_port: 9099
mitum_bind_host: "0.0.0.0"
mitum_publish_host: "{{ ansible_default_ipv4.address }}"

# === MongoDB Configuration ===
# Optimized for $TOTAL_NODES nodes
mongodb_version: "7.0"
mongodb_install_method: "native"
mongodb_package_name: "mongodb-org"
mongodb_bind_ip: "0.0.0.0"
mongodb_port: 27017
mongodb_database: "mitum"
mongodb_replica_set: "$MONGODB_RS"
mongodb_auth_enabled: true
mongodb_admin_user: "admin"
mongodb_mitum_user: "mitum"

# Performance tuning
mongodb_config:
  storage:
    wiredTiger:
      engineConfig:
        cacheSizeGB: $MONGO_CACHE_GB
    directoryPerDB: true
    journal:
      enabled: true
  net:
    maxIncomingConnections: $MONGO_CONNECTIONS
    compression:
      compressors: "snappy,zlib,zstd"
  operationProfiling:
    mode: "slowOp"
    slowOpThresholdMs: 100
  replication:
    oplogSizeMB: $(( TOTAL_NODES * 1024 ))  # 1GB per node

# === Key Generation ===
mitum_keygen_strategy: "centralized"
mitum_keys_threshold: 100
mitum_keygen_type: "btc"
mitum_keys_prefix: "{{ mitum_network_id }}"
mitum_genesis_amount: "999999999999999999999"

# MitumJS configuration
mitum_nodejs_version: "18"
mitum_mitumjs_version: "^2.1.15"
mitum_mitumjs_install_dir: "{{ mitum_base_dir }}/tools/mitumjs"

# === Consensus Settings ===
# Optimized for $CONSENSUS_NODES consensus nodes
mitum_consensus:
  threshold: $CONSENSUS_THRESHOLD
  interval_broadcast_ballot: "$BALLOT_INTERVAL"
  interval_broadcast_proposal: "$PROPOSAL_INTERVAL"
  wait_broadcast_ballot: "$WAIT_TIME"
  wait_broadcast_proposal: "$WAIT_TIME"
  timeout_wait_ballot: "$WAIT_TIME"
  timeout_wait_proposal: "$(( ${WAIT_TIME%s} * 2 ))s"
  max_operations_in_proposal: $(( CONSENSUS_NODES > 5 ? 999 : 500 ))
  max_suffrage_size: $(( CONSENSUS_NODES * 2 + 1 ))

# === API Configuration ===
# Optimized for $API_NODES API nodes
mitum_api:
  bind: "{{ mitum_bind_host }}"
  port: "{{ mitum_api_port }}"
  cache_size: $API_CACHE_SIZE
  timeout: "30s"
  max_request_size: "10MB"
  rate_limit:
    enabled: true
    requests_per_minute: $API_RATE_LIMIT
    burst: $(( API_RATE_LIMIT / 10 ))
  cors:
    enabled: true
    allowed_origins: ["*"]
    allowed_methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
    allowed_headers: ["*"]
    max_age: 3600

# === Logging ===
mitum_logging:
  level: "{{ 'debug' if mitum_environment == 'development' else 'info' }}"
  format: "json"
  output: "file"
  file:
    path: "{{ mitum_log_dir }}/mitum.log"
    max_size: "100MB"
    max_age: 30
    max_backups: $(( TOTAL_NODES > 10 ? 30 : 10 ))
    compress: true

# === Monitoring ===
mitum_monitoring:
  enabled: true
  prometheus:
    enabled: true
    port: "{{ mitum_metrics_port }}"
    path: "/metrics"
    retention: "$(( TOTAL_NODES > 10 ? 90 : 30 ))d"
  node_exporter:
    enabled: true
    port: 9100
  alerts:
    enabled: true
    rules_path: "{{ mitum_config_dir }}/alerts"

# Monitoring server (if separate)
monitoring_server: "{{ groups['monitoring'][0] | default(groups['mitum_nodes'][0]) }}"
prometheus_scrape_interval: "$(( TOTAL_NODES > 10 ? 30 : 15 ))s"
grafana_admin_password: "{{ vault_grafana_admin_password | default('admin') }}"

# === Backup Strategy ===
mitum_backup:
  enabled: true
  schedule: "0 2 * * *"  # 2 AM daily
  retention_days: $(( ENV_NAME == "production" ? 30 : 7 ))
  include_mongodb: true
  compression: "gzip"
  parallel: $(( TOTAL_NODES > 5 ? "true" : "false" ))
  encryption:
    enabled: "{{ mitum_environment == 'production' }}"
    algorithm: "aes-256-cbc"

# === Security ===
# Environment-specific security settings
security_hardening:
  enabled: true
  disable_root_login: "{{ mitum_environment != 'development' }}"
  fail2ban: true
  firewall: true
  selinux: "{{ 'enforcing' if mitum_environment == 'production' else 'permissive' }}"
  audit: "{{ mitum_environment == 'production' }}"

# SSH hardening
ssh_hardening:
  enabled: true
  port: 22
  permit_root_login: "no"
  password_authentication: "no"
  pubkey_authentication: "yes"
  max_auth_tries: 3
  client_alive_interval: 300
  client_alive_count_max: 2

# Firewall rules (auto-generated based on node configuration)
firewall_rules:
  # Mitum node communication
  - port: "{{ mitum_node_port_start }}:{{ mitum_node_port_start + groups['mitum_nodes'] | length }}"
    proto: tcp
    comment: "Mitum node P2P"
  # API access (only on API nodes)
  - port: "{{ mitum_api_port }}"
    proto: tcp
    comment: "Mitum API"
    when: "mitum_api_enabled | default(false)"
  # MongoDB (internal only)
  - port: "{{ mongodb_port }}"
    proto: tcp
    source: "{{ hostvars[inventory_hostname]['ansible_default_ipv4']['network'] }}/24"
    comment: "MongoDB internal"
  # Monitoring
  - port: "{{ mitum_metrics_port }}"
    proto: tcp
    source: "{{ hostvars[monitoring_server]['ansible_default_ipv4']['address'] | default('127.0.0.1') }}/32"
    comment: "Prometheus metrics"

# === Rolling Upgrade Strategy ===
# Conservative settings for safety
mitum_upgrade:
  strategy: "rolling"
  batch_size: 1
  batch_delay: $(( CONSENSUS_NODES > 5 ? 120 : 60 ))
  health_check_retries: 30
  health_check_delay: 5
  consensus_wait_time: $(( CONSENSUS_NODES * 10 ))
  rollback_on_failure: true
  backup_before_upgrade: true
  drain_api_traffic: true

# === Development/Debug ===
debug_mode: "{{ mitum_environment == 'development' }}"
verbose_logging: "{{ debug_mode }}"
enable_profiling: false
enable_tracing: false

# === Feature Flags ===
mitum_features:
  enable_api: true
  enable_digest: true
  enable_metrics: true
  enable_contract: "{{ mitum_model_type == 'mitum-contract' }}"
  enable_nft: "{{ mitum_model_type == 'mitum-nft' }}"
  enable_document: "{{ mitum_model_type == 'mitum-document' }}"
  enable_currency: "{{ mitum_model_type == 'mitum-currency' }}"
  enable_feefi: false
  experimental_features: false

# === Ansible Execution ===
# Control Ansible behavior
ansible_ssh_pipelining: true
ansible_ssh_retries: 3
ansible_timeout: 30
mitum_deployment_serial: "{{ '20%' if groups['mitum_nodes'] | length > 10 else '100%' }}"

# === Tags ===
# Available tags for selective execution
mitum_tags:
  - prepare
  - install
  - configure
  - keygen
  - deploy
  - upgrade
  - backup
  - restore
  - monitoring
  - security
  - validate

# === Notes ===
# 1. This file was auto-generated based on inventory analysis
# 2. Sensitive values should be in vault.yml (see vault.yml.template)
# 3. Environment-specific overrides can be added at the bottom
# 4. For optimal performance, review and adjust settings based on actual workload
EOF

    log "Generated optimized group_vars: $GROUP_VARS_FILE"
    
    # Create vault template
    create_vault_template
    
    # Create host_vars if needed
    create_host_vars
}

# Create vault template
create_vault_template() {
    local vault_template="$GROUP_VARS_DIR/vault.yml.template"
    
    if [[ ! -f "$vault_template" ]]; then
        cat > "$vault_template" << 'EOF'
---
# Ansible Vault Template
# Environment: ENVIRONMENT_NAME
# 
# IMPORTANT: 
# 1. Copy to vault.yml
# 2. Replace ALL CHANGE_ME values
# 3. Encrypt: ansible-vault encrypt vault.yml
# 4. Add to .gitignore: echo "vault.yml" >> .gitignore

# === MongoDB Credentials ===
vault_mongodb_admin_password: "CHANGE_ME_USE_STRONG_PASSWORD"
vault_mongodb_mitum_password: "CHANGE_ME_USE_STRONG_PASSWORD"

# MongoDB keyfile for replica set authentication
# Generate: openssl rand -base64 756 > keyfile.txt
vault_mongodb_keyfile_content: |
  CHANGE_ME_PASTE_YOUR_756_BYTE_BASE64_STRING_HERE

# === Monitoring Credentials ===
vault_grafana_admin_password: "CHANGE_ME_GRAFANA_ADMIN"
vault_prometheus_admin_password: "CHANGE_ME_PROMETHEUS_ADMIN"

# === Backup Encryption ===
vault_backup_encryption_key: "CHANGE_ME_32_CHAR_ENCRYPTION_KEY"

# === API Security ===
vault_api_admin_token: "CHANGE_ME_RANDOM_API_TOKEN"
vault_api_jwt_secret: "CHANGE_ME_RANDOM_JWT_SECRET"

# === Notification Webhooks (optional) ===
vault_slack_webhook_url: ""
vault_discord_webhook_url: ""
vault_email_smtp_password: ""
EOF
        
        log "Created vault template: $vault_template"
        warning "Don't forget to create and encrypt vault.yml!"
    fi
}

# Create host-specific vars if needed
create_host_vars() {
    local host_vars_dir="$GROUP_VARS_DIR/../host_vars"
    
    # Create host_vars for nodes with special configurations
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*node[0-9]+: ]]; then
            NODE_NAME=$(echo "$line" | sed 's/://g' | tr -d ' ')
            NODE_ID=$(echo "$NODE_NAME" | grep -oE '[0-9]+')
            
            # Check if this node has special settings
            if grep -A5 "$line" "$INVENTORY" | grep -q "mitum_api_enabled: true"; then
                mkdir -p "$host_vars_dir"
                cat > "$host_vars_dir/${NODE_NAME}.yml" << EOF
---
# Host-specific variables for $NODE_NAME
# API/Syncer node configuration

# This node serves API requests
mitum_api_enabled: true
mitum_api_bind: "0.0.0.0"
mitum_api_port: 54320

# API-specific settings
mitum_api_cache_size: 2000
mitum_api_max_connections: 1000

# Logging (more verbose for API nodes)
mitum_logging:
  level: "info"
  format: "json"
  output: "file"
  api_access_log: true
EOF
                log "Created host vars for API node: $NODE_NAME"
            fi
        fi
    done < "$INVENTORY"
}

# Main execution
main() {
    log "Starting group_vars generation for environment: $ENV_NAME"
    
    # Parse inventory
    parse_inventory
    
    # Calculate optimal settings
    calculate_optimal_settings
    
    # Generate files
    generate_group_vars
    
    success "Group vars generation complete!"
    echo ""
    echo "Generated files:"
    echo "  - $GROUP_VARS_FILE"
    echo "  - $GROUP_VARS_DIR/vault.yml.template"
    [[ -d "$GROUP_VARS_DIR/../host_vars" ]] && echo "  - host_vars/ (for special nodes)"
    echo ""
    echo "Next steps:"
    echo "1. Review and adjust $GROUP_VARS_FILE"
    echo "2. Create vault.yml from template"
    echo "3. Encrypt: ansible-vault encrypt $GROUP_VARS_DIR/vault.yml"
}

# Execute
main


================================================================================
## ðŸ“Š íŒŒíŠ¸ 1 í†µê³„

- ì´ íŒŒíŠ¸ì˜ íŒŒì¼ ìˆ˜: 95ê°œ
- ì´ íŒŒíŠ¸ì˜ ë¼ì¸ ìˆ˜: 15,805ì¤„
- ì´ íŒŒíŠ¸ì˜ í¬ê¸°: 490,271 bytes
